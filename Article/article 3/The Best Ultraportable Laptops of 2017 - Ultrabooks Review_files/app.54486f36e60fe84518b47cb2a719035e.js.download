
/**
 * Account
 * 
 * Acts as a proxy for the logged in AccountAccessor, and makes it easier to
 * bind events to an all-purpose helper.
 * 
 * @note     This proxy is useful especially with login, since the
 *           AccountAccessor for a guest account ceases to exist after a login.
 *           Therefore binding to this singleton gets around issues with that.
 * @fires    upgrade
 * @abstract
 */
var Account = (function() {

    // Public
    return {

        /**
         * coupon
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        coupon: function() {
            return Stencil.account().coupon();
        },

        /**
         * delinquent
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        delinquent: function() {
            return Stencil.account().delinquent();
        },

        /**
         * draftIsLocked
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        draftIsLocked: function() {
            return Stencil.account().draftIsLocked();
        },

        /**
         * free
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        free: function() {
            return Stencil.account().free();
        },

        /**
         * guest
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        guest: function() {
            return Stencil.account().guest();
        },

        /**
         * highlightAllDrawingsOnSnap
         * 
         * @access public
         * @return Boolean
         */
        highlightAllDrawingsOnSnap: function() {
            return Stencil.get('config').defaults.highlightAllDrawingsOnSnap === true;
        },

        /**
         * highlightCenterGuidesOnSnap
         * 
         * @access public
         * @return Boolean
         */
        highlightCenterGuidesOnSnap: function() {
            return Stencil.get('config').defaults.highlightCenterGuidesOnSnap === true;
        },

        /**
         * highlightDrawingsOnSnap
         * 
         * @access public
         * @return Boolean
         */
        highlightDrawingsOnSnap: function() {
            return Stencil.get('config').defaults.highlightDrawingsOnSnap === true
                || (
                    Stencil.account().userAccount() !== undefined
                    && Stencil.account().userAccount().setting('highlightDrawingsOnSnap').toInt() === 1
                );
        },

        /**
         * max
         * 
         * @access public
         * @return Object
         */
        max: {

            /**
             * bonus
             * 
             * @note   proxy
             * @access public
             * @return Boolean
             */
            bonus: function() {
                var account = Stencil.account();
                return account.max.bonus.call(account);
            },

            /**
             * images
             * 
             * @note   proxy
             * @access public
             * @return Boolean
             */
            images: function() {
                var account = Stencil.account();
                return account.max.images.call(account);
            },

            /**
             * sms
             * 
             * @note   proxy
             * @access public
             * @return Boolean
             */
            sms: function() {
                var account = Stencil.account();
                return account.max.sms.call(account);
            },

            /**
             * stars
             * 
             * @note   proxy
             * @access public
             * @return Boolean
             */
            stars: function() {
                var account = Stencil.account();
                return account.max.stars.call(account);
            }
        },

        /**
         * on
         * 
         * @access public
         * @return void
         */
        on: function() {
            $(Account).on.apply($(Account), $(arguments).toArray());
        },

        /**
         * onboard
         * 
         * Loads the appropriate modal if the loaded account has not yet seen
         * a specific just in time onboarding screen.
         * 
         * @access public
         * @param  String key
         * @return void
         */
        onboard: function(key) {
            var account = Stencil.account(),
                jitOnboarding = account.setting('jitOnboarding');
            jitOnboarding = JSON.parse(jitOnboarding);
            if (jitOnboarding[key] === undefined) {
                jitOnboarding[key] = true;
                account.set({
                    'settings.jitOnboarding': JSON.stringify(jitOnboarding)
                });
                account.save(['settings.jitOnboarding']);
                key += 'Onboarding';
                Modals.showTemplate(key);
            }
        },

        /**
         * once
         * 
         * @access public
         * @return void
         */
        once: function() {
            $(Account).one.apply($(Account), $(arguments).toArray());
        },

        /**
         * plan
         * 
         * @note   proxy
         * @access public
         * @param  String plan
         * @return Boolean
         */
        plan: function(plan) {
            return Stencil.account().plan(plan);
        },

        /**
         * promo
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        promo: function() {
            return Stencil.account().promo();
        },

        /**
         * rates
         * 
         * @access public
         * @var    Object
         */
        rates: {

            /**
             * raw
             * 
             * Provides object breaking down annual and monthly rates for the
             * available plans.
             * 
             * @access public
             * @return Object
             */
            raw: function() {
                var upgrade = Account.upgrade(),
                    plans = Stencil.get('config').defaults.plans;
                if (upgrade !== undefined) {
                    var plan = upgrade.get('plan');
                    if (plan === 'pro') {
                        return {
                            annually: {
                                pro: upgrade.get('annuallyProRate'),
                                unlimited: plans.unlimited.rates.annually
                            },
                            monthly: {
                                pro: upgrade.get('monthlyProRate'),
                                unlimited: plans.unlimited.rates.monthly
                            }
                        };
                    } else if (plan === 'unlimited') {
                        return {
                            annually: {
                                pro: plans.pro.rates.annually,
                                unlimited: upgrade.get('annuallyUnlimitedRate')
                            },
                            monthly: {
                                pro: plans.pro.rates.monthly,
                                unlimited: upgrade.get('monthlyUnlimitedRate')
                            }
                        };
                    }
                    throw new Error('Invalid plan during raw lookup');
                }
                return {
                    annually: {
                        pro: plans.pro.rates.annually,
                        unlimited: plans.unlimited.rates.annually
                    },
                    monthly: {
                        pro: plans.pro.rates.monthly,
                        unlimited: plans.unlimited.rates.monthly
                    }
                };
            },

            /**
             * relative
             * 
             * Returns the annual rate broken down to relative-monthly pricing.
             * 
             * @access public
             * @param  String plan
             * @return Number
             */
            relative: function(plan) {
                var raw = Account.rates.raw(),
                    annually = raw.annually[plan];
                return Math.round(annually / 12);
            }
        },

        /**
         * showWelcomeTour
         * 
         * Goal is to determine whether the welcome tour should automatically be
         * shown. This is determined by first ensuring the account is a
         * guest-account, then checking to see if the user is in the curtain
         * authentication flow, and then finally ensuring the guest account has
         * not yet seen the welcome tour.
         * 
         * Check for the curtain to prevent the WelcomeTour modal from taking
         * over when a guest attempts to signup or login from the public site.
         * 
         * @access public
         * @return Boolean
         */
        showWelcomeTour: function() {
            if (Account.guest() === false) {
                return false;
            }
            if (location.href.match(/curtain/) !== null) {
                return false;
            }
            return Stencil.account().setting('hasSeenWelcomeTour').toInt() === 0;
        },

        /**
         * triggerHandler
         * 
         * @access public
         * @return void
         */
        triggerHandler: function() {
            var msg = arguments[0];
            Stencil.log('account', 'Account Event', msg);
            $(Account).triggerHandler.apply($(Account), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * @access public
         * @return void
         */
        unbind: function() {
            $(Account).unbind.apply($(Account), $(arguments).toArray());
        },

        /**
         * upgrade
         * 
         * @note   proxy
         * @access public
         * @return UpgradeAccessor|undefined
         */
        upgrade: function() {
            return Stencil.account().reference('upgrade');
        },

        /**
         * upgraded
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        upgraded: function() {
            return Stencil.account().upgraded();
        }
    };
})();

/**
 * Alerts
 * 
 * @todo     Move this to the server side
 * @abstract
 */
var Alerts = (function() {

    /**
     * _settings
     * 
     * @access private
     * @return Object
     */
    var _settings = {
        'accountDock.extension.disabled': {
            headline: 'Some embarrassing news..',
            message: 'Unfortunately your billing history cannot be accessed ' +
                'through the Stencil extension.<br /><br />Please access it at: ' +
                '<a href="https://getstencil.com/app/settings/payment" target="_blank" class="text">https://getstencil.com/app/settings/payment</a>'
        },
        'adBlocker.found': {
            headline: 'AdBlockers may affect your experience',
            message: 'We detected that you\'re using an AdBlocker. Just a ' +
                'heads-up this may affect your experience on Stencil.<br /><br />We ' +
                'recommend you turn it off for getstencil.com to ensure ' +
                'things run smoothly.<br /><br />' +
                'If you\'re not able to, you may experience some issues.'
        },
        'account.downgrade': {
            headline: 'Contact us to downgrade.',
            message: 'Looks like you\'re trying to downgrade your plan, ' +
                'which will essentially cancel your current plan.<br />' +
                'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ]
        },
        'account.refilled': {
            headline: 'Account refilled',
            message: 'Looks like while you\'ve been using Stencil, we ' +
                'refilled your account\'s monthly limits.<br /><br />So if ' +
                'some numbers jumped around, just so you know, that\'s what ' +
                'happened.'
        },
        'account.unlimited.limit.sms': {
            headline: 'You have reached your SMS limit',
            message: 'Please <a href="/contact" target="_blank" class="text">contact us</a> for details on ' +
                'raising your account limit.'
        },
        'account.upgrade': {
            headline: 'Contact us to upgrade.',
            message: 'Looks like you\'re trying to upgrade your plan.<br />' +
                'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ]
        },
        'canvas.text.rclick': {
            headline: 'Looking to paste text?',
            message: 'If you\'re on Windows, use <strong>CTRL+V</strong> on ' +
                'your keyboard to paste text.<br />' +
                'If you\'re on a Mac, use <strong>Command+V</strong> on your ' +
                'keyboard to paste text.'
        },
        'connection': {
            headline: 'Internet connection issue',
            message: 'It looks like your connection to the internet may have ' +
                'dropped. Please ensure you\'re properly connected and ' +
                'reload Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'dependency.failed': {
            headline: 'Could not load some code',
            message: 'Unfortunately, we could not load some required code.' +
                '<br />This could mean your internet connection is down, you ' +
                'have an ad blocker installed that is preventing the code ' +
                'from being loaded, or possibly something is wrong on our ' +
                'side. <br /><br />Please disable any ad blockers you may ' +
                'have turned on, and try again.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'devicePixelRatio.change': {
            headline: 'Heads up!',
            message: 'We just detected a change to your display settings and ' +
                'need you to reload Stencil. Don\'t worry: we\'ve saved ' +
                'your image and nothing will be lost.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'extension.conflicting.ezLinkPreview': {
            headline: 'ezLinkPreview Extension Issue',
            message: 'It looks like you have the ezLinkPreview extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.'
        },
        'extension.conflicting.ghostery': {
            headline: 'Ghostery Extension Issue',
            message: 'It looks like you have the Ghostery extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.'
        },
        'extension.install.chrome': {
            headline: 'Google Chrome Required',
            message: 'At the moment, you need Google Chrome to<br />use the ' +
                'Stencil extension.<br /><br />Download it ' +
                '<a href="https://www.google.com/chrome/" target="_blank" class="text">here</a> ' +
                'to move forward.'
        },
        'extension.install.window': {
            headline: 'Browser security requirement',
            message: 'To install the Stencil Extension for Chrome, please ' +
                'visit ' +
                '<a href="https://getstencil.com/app/extras" target="_blank" class="text">https://getstencil.com/app/extras</a>'
        },
        'facebook.auth.minimum': {
            headline: 'Could not connect to your Facebook account',
            message: 'In order to connect your Facebook account, Stencil ' +
                'requires you to accept all the permissions when prompted. ' +
                '<br /><br />Please know that we will ' +
                '<strong class="underline">never</strong> post to your ' +
                'profile or page without you clicking a button to do so.'
        },
        'facebook.logout': {
            headline: 'Could not find any new <br />profiles or pages',
            message: 'All the profiles &amp; pages linked to the Facebook ' +
                'account you\'re logged in with have ' +
                'already been added to Stencil. <br /><br />To connect a ' +
                'completely new profile, please log out on Facebook and try again.',
            buttons: [
                {
                    copy: 'Logout from Facebook',
                    path: function() {
                        return 'https://facebook.com';
                    },
                    target: '_blank'
                }
            ]
        },
        'frame.ratio.unchanged': {// Not currently being used
            headline: 'Heads up!',
            message: 'While you may not notice a different in your image ' +
                'above, we\'ve recorded the change in dimensions, and when ' +
                'you save or download this image, it will be your new size.'
        },
        'import.failed': {
            headline: 'Could not import that image',
            message: 'Unfortunately, we could not import the image you ' +
                'right-clicked. Please try uploading it right into Stencil.'
        },
        'import.failed.max.filesize': {
            headline: 'Right-clicked image is too large',
            message: 'Unfortunately, the image you attempted to use is ' +
                'larger than the maximum allowed. Please try another.'
        },
        'image.upload.error': {
            headline: 'Could not save your image',
            message: 'Something strange happened and we could not save your ' +
                'image. Please reload Stencil<br />to ' +
                'continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'image.upload.exception': {
            headline: 'Problem while saving',
            message: 'We are having trouble with your browser. Please try ' +
                'another browser until we can fix the issue in this version',
            closable: false,
            buttons: []
        },
        'image.uploaded': {
            headline: 'Image has been saved',
            message: 'Thanks for your patience. Go ahead and try again.'
        },
        'image.uploaded.already': {
            headline: 'This image has already been saved',
            message: 'It seems like this image was already saved in another ' +
                'tab, browser, or on another computer. Please reload Stencil ' +
                'to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'image.uploaded.deleted': {
            headline: 'Account being used in multiple locations',
            message: 'It appears this account is being used on more than one ' +
                'computer, tab or browser. At this time, Stencil accounts ' +
                'cannot be used simultaneously.<br /><br />' +
                'Please log out from your other device and then reload ' +
                'Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'image.uploading': {// Not currently being used
            headline: 'Image is still being saved',
            message: 'Please wait a moment and then try again.'
        },
        'password.reset': {// Not currently being used
            headline: 'Please check your email',
            message: 'We\'ve sent you instructions on how to change your ' +
                'password.'
        },
        'modal.paused': {// Not currently being used
            headline: 'Just a second..',
            message: 'Please wait until your submission has finished.'
        },
        'resource.filesize.excessive': {// Not currently being used
            headline: 'Could not load image',
            message: 'Sorry about the trouble, but we are not able to load ' +
                'that image. Please try a different one.'
        },
        'service.aws': {
            headline: 'Saving options temporarily off',
            message: 'Sorry about the trouble.<br /><br />We\'re working on ' +
                'the problem, and will have things up and running as soon as ' +
                'possible. Your image has been saved, so when you come back ' +
                'you will be able to get going quickly.'
        },
        'service.fonts.disabled': {
            headline: 'Font uploading temporarily off',
            message: 'Sorry about the trouble.<br /><br />We\'re working on ' +
                'the problem, and will have things up and running as soon as ' +
                'possible.'
        },
        'search.bug': {
            headline: 'Error with Stencil search results',
            message: 'Unfortunately, an error has occured with your search. ' +
                'Please reload Stencil to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'search.expired': {// Not currently being used
            headline: 'Please reload Stencil',
            message: 'For security purposes, please reload Stencil<br />to ' +
                'continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },
        'svg.load.fail': {
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading '+
                'that icon. Please try another, while we work on a fix.'
        },
        'svg.load.fail.2': {
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading '+
                'a specific icon. It may not appear in your image at for the ' +
                'moment.'
        },
        'timeout': {// Not currently being used
            headline: 'Request timed out',
            message: 'Apologies, but it seems like we\'re getting overloaded ' +
                'with traffic. Please reload Stencil to continue where you ' +
                'left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ]
        },

        /**
         * Font import max
         * 
         */
        'font.import.max': {
            headline: 'Max fonts reached',
            message: 'For performance reasons, you cannot have more than ' +
                '50 fonts in your My Fonts section at time. Sorry for the ' +
                'inconvenience.'
        },

        /**
         * Font uploads
         * 
         */
        'upload.font.failed': {
            headline: 'Could not process font',
            message: 'There was an issue processing your font. Please ensure ' +
                'the font is either an OTF, TTF, WOFF or WOFF2 font file.' +
                '<br /><br />If you are trying to upload a ZIP file, please ' +
                'unzip it first, and then try again.<br /><br />Otherwise, ' +
                'please try another font, or '+
                '<a href="https://getstencil.com/contact" class="text" target="_blank">contact support</a>.'
                //
                //
                //
        },
        'upload.font.max.count': {
            headline: 'Too many font uploads',
            message: 'Unfortunately you can only upload up to 20 fonts at once.'
        },
        'upload.font.max.filesize': {
            headline: 'One of your font uploads is too large',
            message: 'Unfortunately we can only process font uploads that ' +
                'are less than 2 megabytes.'
        },
        'upload.font.max.filesize.admin': {// Not currently being used
            headline: 'One of your font uploads is too large',
            message: 'Unfortunately we can only process font uploads that ' +
                'are less than 2 megabytes.'
        },
        'upload.font.type': {// Only used when a .zip file is detected
            headline: 'Only OTF, TTF, WOFF and WOFF2 fonts',
            message: 'Please ensure fonts are either OTF, TTF, WOFF<br />or ' +
                'WOFF2.<br /><br />If you are trying to upload a ZIP file, ' +
                'please unzip it first, and then upload the unzipped font ' +
                'files.'
        },

        /**
         * Image uploads
         * 
         */
        'upload.image.max.count': {
            headline: 'Too many image uploads',
            message: 'Unfortunately you can only upload up to 50 images at ' +
                'once.'
        },
        'upload.image.max.filesize': {
            headline: 'One of your image uploads is too large',
            message: 'Unfortunately we can only process image uploads that ' +
                'are less than 20 megabytes.'
        },
        'upload.image.max.filesize.admin': {// Not currently being used
            headline: 'One of your image uploads is too large',
            message: 'Unfortunately we can only process image uploads that ' +
                'are less than 20 megabytes.'
        },
        'upload.image.type': {
            headline: 'Only PNG, JPEG and GIF images',
            message: 'Currently, you can only upload PNG, JPEG<br />or GIF ' +
                'images.'
        },

        /**
         * Upload filesize issues
         * 
         */
        'upload.multiple.filesize.zero': {
            headline: 'One of your files cannot be uploaded',
            message: 'Unfortunately we won\'t be able to process your upload.\n' +
                'One of your files is empty, and cannot be uploaded. Please ' +
                'try another.'
        },
        'upload.singular.filesize.zero': {
            headline: 'Cannot upload that file',
            message: 'Unfortunately we won\'t be able to process that file.\n' +
                'It may not be the right format. Please try another.'
        },

        /**
         * AdBlocker
         * 
         */
        'window.blocked': {// Not currently being used
            headline: 'Window Blocked',
            message: 'We could not complete the action because your browser ' +
                'is blocking popups. Please turn this off to continue.' +
                '<br /><br /><a href="https://bit.ly/1SINEbr" class="text" target="_blank">Learn more</a>'
        }
    };

    // Public
    return {

        /**
         * show
         * 
         * @access public
         * @param  String code
         * @return AlertModalView
         */
        show: function(code) {
            return Modals.showAlert(code, _settings[code]);
        }
    };
})();

/**
 * (closure)
 * 
 * @see http://chriszarate.github.io/bookmarkleter/
 */
var Bookmarkleter = (function() {

    /**
     * _normalize
     * 
     * @access private
     * @param  String str
     * @return String
     */
    var _normalize = function(str) {
        var text = str;
        text = text.replace(/\r/g, '\n');
        text = _removeComments(text);
        text = text.replace(/[\t ]+/g, ' ');
        text = text.replace(/'/g, '"<$<$<$<$<$<');
        var NewlineArray = text.split('\n');
        var LineCount = NewlineArray.length;
        var QuoteArray = Array();
        var SplitCount = 0;

        for ( i = 0; i < LineCount; i++ ) {

            // Trim each line
            NewlineArray[i] = NewlineArray[i].replace(/^[\t ]+/g, '');
            NewlineArray[i] = NewlineArray[i].replace(/[\t ]+$/g, '');

            QuoteArray = NewlineArray[i].split('"');
            SplitCount = QuoteArray.length;

            for ( j = 0; j < SplitCount; j++ ) {
                if ( (j % 2) == 0 ) QuoteArray[j] = _makeReplacements(QuoteArray[j]);
            }

            NewlineArray[i] = QuoteArray.join('"');

        }

        text = NewlineArray.join('');

        // Restore single quotes
        text = text.replace(/"<\$<\$<\$<\$<\$</g, "'");

        // Percent-encode special characters
        text = text.replace(/%/g, '%25');
        text = text.replace(/"/g, '%22');
        text = text.replace(/</g, '%3C');
        text = text.replace(/>/g, '%3E');
        text = text.replace(/#/g, '%23');
        text = text.replace(/@/g, '%40');
        text = text.replace(/ /g, '%20');
        text = text.replace(/\&/g, '%26');
        text = text.replace(/\?/g, '%3F');

        if (text.substring(0, 11) === 'javascript:') {
            text = text.substring(11);
        }
        textLength = text.length;

        if ((text.substring(0, 12) + text.substring(textLength - 5)) != '(function(){})();') {
            text = '(function(){' + text + '})();';
        }
        text = 'javascript:' + text;
        return text;
    };

    /**
     * _makeReplacements
     * 
     * @access private
     * @param  String str
     * @return String
     */
    var _makeReplacements = function(str) {
        var text = str.replace(/ ?; ?/g, ';');
        text = text.replace(/ ?: ?/g, ':');
        text = text.replace(/ ?, ?/g, ',');
        text = text.replace(/ ?= ?/g, '=');
        text = text.replace(/ ?% ?/g, '%');
        text = text.replace(/ ?\+ ?/g, '+');
        text = text.replace(/ ?\* ?/g, '*');
        text = text.replace(/ ?\? ?/g, '?');
        text = text.replace(/ ?\{ ?/g, '{');
        text = text.replace(/ ?\} ?/g, '}');
        text = text.replace(/ ?\[ ?/g, '[');
        text = text.replace(/ ?\] ?/g, ']');
        text = text.replace(/ ?\( ?/g, '(');
        text = text.replace(/ ?\) ?/g, ')');
        return text;
    };

    /**
     * _removeComments
     * 
     * @see    http://james.padolsey.com/javascript/removing-comments-in-javascript/
     * @access private
     * @param  String str
     * @return String
     */
    function _removeComments(str) {
        str = ('__' + str + '__').split('');
        var mode = {
            singleQuote: false,
            doubleQuote: false,
            regex: false,
            blockComment: false,
            lineComment: false,
            condComp: false 
        };
        for (var i = 0, l = str.length; i < l; i++) {
     
            if (mode.regex) {
                if (str[i] === '/' && str[i-1] !== '\\') {
                    mode.regex = false;
                }
                continue;
            }
     
            if (mode.singleQuote) {
                if (str[i] === "'" && str[i-1] !== '\\') {
                    mode.singleQuote = false;
                }
                continue;
            }
     
            if (mode.doubleQuote) {
                if (str[i] === '"' && str[i-1] !== '\\') {
                    mode.doubleQuote = false;
                }
                continue;
            }
     
            if (mode.blockComment) {
                if (str[i] === '*' && str[i+1] === '/') {
                    str[i+1] = '';
                    mode.blockComment = false;
                }
                str[i] = '';
                continue;
            }
     
            if (mode.lineComment) {
                if (str[i+1] === '\n' || str[i+1] === '\r') {
                    mode.lineComment = false;
                }
                str[i] = '';
                continue;
            }
     
            if (mode.condComp) {
                if (str[i-2] === '@' && str[i-1] === '*' && str[i] === '/') {
                    mode.condComp = false;
                }
                continue;
            }
     
            mode.doubleQuote = str[i] === '"';
            mode.singleQuote = str[i] === "'";
     
            if (str[i] === '/') {
     
                if (str[i+1] === '*' && str[i+2] === '@') {
                    mode.condComp = true;
                    continue;
                }
                if (str[i+1] === '*') {
                    str[i] = '';
                    mode.blockComment = true;
                    continue;
                }
                if (str[i+1] === '/') {
                    str[i] = '';
                    mode.lineComment = true;
                    continue;
                }
                mode.regex = true;
     
            }
     
        }
        return str.join('').slice(2, -2);
    };

    // Public
    return {

        /**
         * convert
         * 
         * @access public
         * @param  String str
         * @return void
         */
        convert: function(str) {
            return _normalize(str);
        }
    };
})();

/**
 * Browser
 * 
 * @todo!    Modernize with Modernizr
 *           For detecting italic support in the canvas (used in text drawings):
 *           http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
 * @abstract
 */
var Browser = (function() {

    /**
     * _italic
     * 
     * @access private
     * @var    Boolean (default: undefined)
     */
    var _italic = undefined;

    // Public
    return {

        /**
         * bookmarklet
         * 
         * Returns whether or not the app is currently being accessed via a
         * browser bookmarklet.
         * 
         * @todo
         * @access public
         * @return Boolean
         */
        bookmarklet: function() {
            return false;
        },

        /**
         * chrome
         * 
         * @access public
         * @return Boolean
         */
        chrome: function() {
            return /chrom(e|ium)/.test(navigator.userAgent.toLowerCase());
        },

        /**
         * edge
         * 
         * @access public
         * @return Boolean
         */
        edge: function () {
            return / edge/.test(navigator.userAgent.toLowerCase()) === true;
        },

        /**
         * extension
         * 
         * Returns whether or not the app is currently being accessed via a
         * browser extension (currently, just Chrome).
         * 
         * @todo
         * @access public
         * @return Boolean
         */
        extension: function() {
            return App.getElement().hasClass('external')
                && App.getElement().hasClass('extension');
        },

        /**
         * firefox
         * 
         * @access public
         * @return Boolean
         */
        firefox: function() {
            return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        },

        /**
         * hasCSP
         * 
         * @access public
         * @return Boolean
         */
        hasCSP: function() {
            var blacklist = [
                    'mail.google.com'
                ],
                params = Stencil.get('messageParams'),
                hostname;
            if (params !== undefined) {
                if (params.parent !== undefined) {
                    if (params.parent.location !== undefined) {
                        if (params.parent.location.hostname !== undefined) {
                            hostname = params.parent.location.hostname;
                        }
                    }
                }
            }
            if (jQuery.inArray(hostname, blacklist) === -1) {
                return false;
            }
            return true;
        },

        /**
         * ie
         * 
         * @see    http://blogs.msdn.com/b/ieinternals/archive/2013/09/21/internet-explorer-11-user-agent-string-ua-string-sniffing-compatibility-with-gecko-webkit.aspx
         * @sample 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)'
         * @sample 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; .NET4.0E; .NET4.0C; rv:11.0) like Gecko'
         * @access public
         * @return Boolean
         */
        ie: function() {
            var userAgent = navigator.userAgent;
            return userAgent.match(/msie/i) !== null
                || userAgent.match(/trident\/7/i) !== null;
        },

        /**
         * ipad
         * 
         * @access public
         * @return Boolean
         */
        ipad: function() {
            return navigator.userAgent.match(/iPad/i) !== null;
        },

        /**
         * italic
         * 
         * Tests whether the browser supports faux-italic text in canvas when
         * the font itself does not have an italic version (or else the italic
         * version has not been loaded into memory).
         * 
         * I do this by using the native font Impact, which does not have a bold
         * or italic version, drawing it to a canvas, and checking whether
         * anything about the canvas bit-data is different.
         * 
         * @see    http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
         * @see    http://stackoverflow.com/questions/15128803/cannot-draw-italic-text-in-firefox-canvas
         * @access public
         * @return Boolean
         */
        italic: function () {
            if (_italic === undefined) {
                var canvas = document.createElement('canvas'),
                    context = canvas.getContext('2d'),
                    raw = {};
                canvas.width = 1000;
                canvas.height = 30;
                context.font = 'normal 16px impact';
                context.fillText('string', 10, 20);
                raw.normal = canvas.toDataURL('image/png');
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'italic 16px impact';
                context.fillText('string', 10, 20);
                raw.italic = canvas.toDataURL('image/png');
                _italic = raw.normal !== raw.italic;
            }
            return _italic;
        },

        /**
         * mac
         * 
         * @access public
         * @return Boolean
         */
        mac: function () {
            return navigator.appVersion.indexOf('Mac') !== -1;
        },

        /**
         * orientation
         * 
         * @access public
         * @return false|String
         */
        orientation: function() {
            if (Browser.ipad() === false) {
                return false;
            }
            var orientation = window.orientation;
            if (orientation === 0 || orientation === 180) {
                return 'portrait';
            }
            return 'landscape';
        },

        /**
         * safari
         * 
         * @see    http://stackoverflow.com/questions/7944460/detect-safari-browser
         * @access public
         * @return Boolean
         */
        safari: function() {
            return /^((?!chrome).)*safari/i.test(navigator.userAgent);
        },

        /**
         * safari5
         * 
         * @sample 'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2'
         * @access public
         * @return Boolean
         */
        safari5: function() {
            var userAgent = navigator.userAgent;
            return userAgent.match(/Safari\//i) !== null
                && userAgent.match(/Version\/5/i) !== null;
        },

        /**
         * tablet
         * 
         * Returns whether the visitor is experiencing the app on a tablet.
         * 
         * @access public
         * @return Boolean
         */
        tablet: function() {
            return Browser.ipad() === true;
        },

        /**
         * valid
         * 
         * @access public
         * @return Boolean
         */
        valid: function () {
            return Modernizr.cors === true
                && Modernizr.imgcrossorigin === true;
        },

        /**
         * woff2
         * 
         * @access public
         * @return Boolean
         */
        woff2: function () {
            return supportsWoff2 === true;
        }
    };
})();
// 0
// 0

/**
 * ChangeHistory
 * 
 * @abstract
 */
var ChangeHistory = (function() {

    /**
     * Private variables
     * 
     */

    /**
     * _groupableOperationTypes
     * 
     * This contains the array of types whereby a sequence of them would be
     * grouped together. This is important because some things should not be
     * tracked entirely independently of one another. (eg. nudging).
     * 
     * Note that these _are_ in fact tracked independently if they occur spaced
     * apart by a specific number of milliseconds (defined in config.inc.php).
     * 
     * @access private
     * @var    Array
     */
    var _groupableOperationTypes = [

        // Typing
        'layer // type: text // text:changed',

        // Nudging
        'layer // type: text // nudged',
        'layer // type: image, vector: true // nudged',
        'layer // type: image, background: false // nudged',
        'layer // type: image, watermark: true // nudged',

        // Color changing
        'layer // type: rectangle, background: true // backgroundColor:changed',
        'layer // type: text // backdrop:colorChanged',
        'layer // type: text // strokeColor:changed',
        'layer // type: text // textColorChanged',
        'layer // type: image, vector: true // fillColor:changed'
    ];

    /**
     * _operationType
     * 
     * @access private
     * @var    false|String
     */
    var _operationType = false;

    /**
     * _paused
     * 
     * Modified via the public ChangeHistory.pause and ChangeHistory.unpause
     * methods, in order to prevent history changes during certain
     * circumstances.
     * 
     * This includes:
     *  - If the canvas is still being drawn (eg. background image being as or
     *    vector being added)
     * 
     * @access private
     * @var    Boolean (default: false)
     */
    // var _paused = false;

    /**
     * Private methods
     * 
     */

    /**
     * _getChangeHistoryOperationsMap
     * 
     * @access private
     * @return Object
     */
    var _getChangeHistoryOperationsMap = function() {
        return Stencil.get('config').defaults.changeHistoryOperations;
    };

    /**
     * _getMaxOperations
     * 
     * Returns the maximum number of operations that can be tracked in the
     * undo or redo change history arrays. Each can have this number of
     * changes.
     * 
     * @access private
     * @return Number
     */
    var _getMaxOperations = function() {
        return Stencil.get('config').defaults.changeHistory.maxOperations.toInt();
    };

    /**
     * _getMinDelayUntilNewOperationRegistered
     * 
     * @access private
     * @return Number
     */
    var _getMinDelayUntilNewOperationRegistered = function() {
        return Stencil.get('config').defaults.changeHistory.minDelayUntilNewOperationRegistered.toInt();
    };

    /**
     * _getOperationDescription
     * 
     * @access private
     * @return String
     */
    var _getOperationDescription = function() {
        var operationType = _getOperationType(),
            map = _getChangeHistoryOperationsMap(),
            operationDescription = map[operationType];
        if (operationDescription === undefined) {
            StencilBooter.log(operationType);
            StencilBooter.log('Unknown operation type');
            return 'Change';
        }
        return operationDescription;
    };

    /**
     * _getOperationType
     * 
     * @access private
     * @return String
     */
    var _getOperationType = function() {
        return _operationType;
    };

    /**
     * _replacableOperation
     * 
     * This checks the _groupableOperationTypes array to determine if the
     * operation passed in (which is presumably the one that could be added
     * next), is within that array, and if it is, if it's witin the minimum
     * range to be considered as a replacement operation.
     * 
     * The best example is that when someone is nudging something, we don't want
     * nudges that happen within 1500ms (or whatever) of eachother to count as
     * a new operation. We just want the most recent one to be the last
     * operation.
     * 
     * This is primarily to prevent operations that would be redundant from
     * entering in the history.
     * 
     * Also note that currently this replacing/grouping is limited to changes
     * that originate from keyup events (as opposed to mouseup events).
     * 
     * @access private
     * @param  Object operation
     * @param  jQuery event
     * @return Boolean
     */
    var _replacableOperation = function(operation, event) {
        if (event.type !== 'keyup') {
            return false;
        }
        var operationType = operation.type;
        if (jQuery.inArray(operationType, _groupableOperationTypes) === -1) {
            return false;
        }
        var account = Stencil.account(),
            undoHistory = ChangeHistory.history.undo(),
            lastUndoChange = undoHistory.pop();
        if (lastUndoChange.type !== operationType) {
            return false;
        }
        var range = _getMinDelayUntilNewOperationRegistered(),
            withinRange = timestampWithin(
                lastUndoChange.timestamp.full * 1000,
                operation.timestamp.full * 1000,
                range
            );
        if (withinRange === false) {
            return false;
        }
        return true;
    };

    // Public
    return {

        /**
         * active
         * 
         * Simply returns whether or not change history is enabled.
         * 
         * @access public
         * @return Boolean
         */
        active: function() {
            return Stencil.get('config').defaults.changeHistory.active === true;
        },

        /**
         * clearOperationType
         * 
         * @access public
         * @return void
         */
        clearOperationType: function () {
            _operationType = false;
        },

        /**
         * history
         * 
         * Helper object to return the object of redo/undo change operations, or
         * individual change history arrays (eg. the undo changes or redo
         * changes).
         * 
         * @access public
         * @var    Object
         */
        history: {

            /**
             * all
             * 
             * @access public
             * @return Object
             */
            all: function() {
                var account = Stencil.account(),
                    all = account.setting('changeHistory');
                if (JSON.valid(all) === false) {
                    return {
                        redo: [],
                        undo: []
                    };
                }
                return JSON.parse(all);
            },

            /**
             * redo
             * 
             * @access public
             * @return Array
             */
            redo: function() {
                return ChangeHistory.history.all().redo;
            },

            /**
             * undo
             * 
             * @access public
             * @return Array
             */
            undo: function() {
                return ChangeHistory.history.all().undo;
            }
        },

        /**
         * initiate
         * 
         * Helper object to initiate a redo or undo operation.
         * 
         * @access public
         * @var    Object
         */
        initiate: {

            /**
             * redo
             * 
             * @access public
             * @param  Number stepsForward
             * @return void
             */
            redo: function(stepsForward) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    redoHistory = allHistory.redo;
                if (redoHistory.length > 0) {

                    // Update the history arrays (by splicing at the right spot)
                    var undoHistory = allHistory.undo,
                        slicedRedoHistory = redoHistory.splice(0, stepsForward);
                    undoHistory = undoHistory.concat(slicedRedoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var futureOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = futureOperation.configuration.sourceImageId,
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': futureOperation.configuration.frame,
                                'width': futureOperation.configuration.width,
                                'height': futureOperation.configuration.height,
                                'sourceImageId': sourceImageId,
                                'settings.json': futureOperation.configuration.settings.json,
                                'settings.watermarks': futureOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    draft.select('image', 'redo', false, {
                        operationType: undoHistory[(undoHistory.length - 1)].type
                    });

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            },

            /**
             * undo
             * 
             * @access public
             * @param  Number stepsBack
             * @return void
             */
            undo: function(stepsBack) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    undoHistory = allHistory.undo;
                if (undoHistory.length > 1) {

                    // Update the history arrays (by splicing at the right spot)
                    var redoHistory = allHistory.redo,
                        removedUndoOperations = undoHistory.splice(0 - stepsBack, stepsBack);
                    // removedUndoOperations.reverse();
                    redoHistory = removedUndoOperations.concat(redoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var lastOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = lastOperation.configuration.sourceImageId,
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': lastOperation.configuration.frame,
                                'width': lastOperation.configuration.width,
                                'height': lastOperation.configuration.height,
                                'sourceImageId': sourceImageId,
                                'settings.json': lastOperation.configuration.settings.json,
                                'settings.watermarks': lastOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    draft.select('image', 'undo', false, {
                        operationType: redoHistory[0].type
                    });

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            }
        },

        /**
         * keyboardShortcuts
         * 
         * Helper object used to determine if a keyboard combination shortcut
         * was used to initiate a redo or undo operation.
         * 
         * @access public
         * @var    Object
         */
        keyboardShortcuts: {

            /**
             * redo
             * 
             * @access public
             * @param  jQuery event
             * @return Boolean
             */
            redo: function(event) {
                return (
                        event.metaKey === true
                        && event.shiftKey === true
                        && event.key.toLowerCase() === 'z'
                        && $(event.target).tag() !== 'input'
                    )
                    || (
                        event.metaKey === true
                        && event.shiftKey === false
                        && event.key.toLowerCase() === 'y'
                        && $(event.target).tag() !== 'input'
                    );
            },

            /**
             * undo
             * 
             * @access public
             * @param  jQuery event
             * @return Boolean
             */
            undo: function(event) {
                return event.metaKey === true
                    && event.shiftKey === false
                    && event.key.toLowerCase() === 'z'
                    && $(event.target).tag() !== 'input';
            }
        },

        /**
         * persistWatermarksForFeaturedTemplates
         * 
         * Proxy for change history setting, which in this case, is used to
         * determine if a watermark should persist on templates the user does
         * not own (in practice this is only applicable to featured templates).
         * 
         * @access public
         * @return Boolean
         */
        persistWatermarksForFeaturedTemplates: function() {
            return Stencil.get('config').defaults.changeHistory.persistWatermarksForFeaturedTemplates === true;
        },

        /**
         * replaceAccountChangeHistory
         * 
         * This method receives raw data from the auth flow, representing the
         * account that is being logged in, and replaces the change history with
         * what's already stored in the ChangeHistory singleton. This is
         * important because without it, the change history for a session would
         * get lost, since the default setting for change history is just the
         * empty redo and undo arrays.
         * 
         * @access public
         * @param  Object accountData
         * @return Object
         */
        replaceAccountChangeHistory: function(accountData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory);
            accountData.settings.changeHistory = currentChangeHistoryJson;
            return accountData;
        },

        /**
         * replaceConsecutiveMirrors
         * 
         * Oh boy this one is fun. So...
         * When a watermark is deleted from an account, it's possible that there
         * are operations in either the redo or undo stack that solely relate to
         * that watermark. For example, when a watermark is moved, nudged,
         * rotated, resized, or a filter is applied to it.
         * 
         * When a watermark is deleted, however, those operations should no
         * longer be available in the change history, since that watermark can't
         * actually be reverted to. So I deal with this by iterating over all
         * the operations and removed any that are "consecutive mirrors" of
         * one another. This is possible because in a previous step (defined in
         * the syncWatermark method), the watermarks array in the configuration
         * object is actually removed. So there wouldn't be anything different
         * in the configuration objects as a whole.
         * 
         * I'm a bit worried that this could result in removing some valid
         * operations, but I _think_ it's okay..
         * 
         * @note   In most places in this class, I operate against the change
         *         history stacks in alphabetical order (namely, redo and then
         *         undo). I need to operate on them here in the undo -> redo
         *         order to prevent issues with splicing.
         * @access public
         * @return void
         */
        replaceConsecutiveMirrors: function() {
            var account = Stencil.account(),
                index,
                operations = {},
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            index = undoHistory.length;
            while (index--) {
                if (index === 0) {
                    continue;
                }
                operations.current = undoHistory[index];
                operations.previous = undoHistory[index - 1];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    undoHistory.splice(index, 1);
                }
            }
            index = redoHistory.length;
            while (index--) {
                if (index === 0) {
                    operations.previous = undoHistory[undoHistory.length - 1];
                } else {
                    operations.previous = redoHistory[index - 1];
                }
                operations.current = redoHistory[index];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    redoHistory.splice(index, 1);
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceLastUndoOperation
         * 
         * This exists only, at the moment, to support VectorImage drawings.
         * This is because when a VectorImage is drawn via a user action
         * (opposed to from the app initially loading, and having a VectorImage
         * part of the initial image document / json), we check if the ratio of
         * the drawing is less than 1 (meaning it's taller than it is wide).
         *
         * If it is, we resize the width so that it's proportional to a maximum
         * height of 25% of the canvas. The problem with doing this, is it
         * happens after the ChangeHistory.track call happens (which makes
         * sense, because a vector can take a little while to load).
         *
         * So if we don't replace the last undo operation, it would result in
         * another undo operation appearing in the history (since the json of
         * the configuration object would in fact be different).
         *
         * So: we provide this helper method to replace the last undo operation.
         * See the VectorImage.js drawing to see how this is used.
         * 
         * Update: Saturday, February 18th, 2017
         * This method is used in two other places:
         * 1) the syncBackgroundImageSet method
         * 2) The throttling of groupable operation types
         * 
         * @access public
         * @param  Object operation
         * @return void
         */
        replaceLastUndoOperation: function(operation) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                index = undoHistory.length - 1;
            undoHistory[index] = operation;
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': ChangeHistory.history.redo(),
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceUserChangeHistory
         * 
         * This does the same as replaceAccountChangeHistory, but simply for the
         * active account, and loops over the accounts being passed down, and
         * when matching the account the user is logging into, replaces the
         * change history for it.
         * 
         * @access public
         * @param  Object userData
         * @return Object
         */
        replaceUserChangeHistory: function(userData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory),
                index;
            userData.active.settings.changeHistory = currentChangeHistoryJson;
            for (index in userData.accounts) {
                if (userData.accounts[index].id.toInt() === userData.active.id.toInt()) {
                    userData.accounts[index].settings.changeHistory = currentChangeHistoryJson;
                }
            }
            return userData;
        },

        /**
         * pause
         * 
         * @access public
         * @return void
         */
        // pause: function() {
        //     _paused = true;
        // },

        /**
         * setOperationType
         * 
         * @access public
         * @param  String type
         * @return void
         */
        setOperationType: function (type) {
            if (_operationType === false) {
                _operationType = type;
            }
        },

        /**
         * syncBackgroundImageSet
         * 
         * When a background image is set, after it's been loaded, the
         * background is set to white. I believe the logic at the time of
         * implementation was that it should be white, because if the user
         * removes the background image, they would expect to see a white
         * background and not whatever the background rectangle's color was set
         * to last.
         * 
         * The issue with this is that when the user eventually clicks somewhere
         * else on the page, it will trigger a ChangeHistory.track call, which
         * will incorrectly believe the image JSON is different (since the
         * background color may have changed from a color before the background
         * image was set, to white).
         * 
         * So this method's purpose is to grab the last change operation, and
         * overwrite whatever color is there with white, to ensure a
         * false-positive doesn't occur.
         * 
         * @access public
         * @return void
         */
        syncBackgroundImageSet: function() {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                lastUndoOperation = undoHistory[undoHistory.length - 1],
                index,
                layer,
                white = 'rgba(255, 255, 255, 1)',
                backgroundColor,
                json = lastUndoOperation.configuration.settings.json,
                jsonObject = JSON.parse(json);
            for (index in jsonObject.layers) {
                layer = jsonObject.layers[index];
                if (layer.type === 'rectangle' && layer.background === true) {
                    backgroundColor = layer.styles.backgroundColor;
                    if (backgroundColor.addSpacesToRgba() !== white) {
                        layer.styles.backgroundColor = white;
                        json = JSON.stringify(jsonObject);
                        lastUndoOperation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(
                            lastUndoOperation
                        );
                        break;
                    }
                }
            }
        },

        /**
         * syncDeletedFont
         * 
         * This method is responsible for swapping out any fonts that have been
         * deleted, and replacing them with the defaultFontFamily for the
         * account (which is stored in the AccountAccessor's settings, since we
         * wanted it to be flexible enough for account's to be able to define
         * their own default font).
         * 
         * This is again importantt, since once a font is deleted, it can't be
         * gracefully restored to the app's flow. So we want to ensure
         * operations aren't referencing fonts that can't be properly used
         * through previous or future operations.
         * 
         * @access public
         * @param  FontAccessor font
         * @return void
         */
        syncDeletedFont: function(font) {
            var key = font.get('key'),
                account = Stencil.account(),
                appDefaultFontFamily = account.setting('defaultFontFamily'),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(key, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncResourceKeyInOperations
         * 
         * This method is responsible for looping over all operations in the
         * change history, and replacing any keys matching previousKey with
         * newKey. This is important because when a 3rd-party resource is
         * initially used, the resource is loaded directly, before a /save
         * call is made. Once that call comes back, it changes the
         * image-property for the JSON of the draft to that new key.
         * 
         * After this happens, if the user initiates a ChangeHistory.track call
         * (via the mouseup or keyup events), the app will think something is
         * different (even though that's not the case).
         * 
         * @access public
         * @param  String previousKey
         * @param  String newKey
         * @return void
         */
        syncResourceKeyInOperations: function(previousKey, newKey) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(previousKey, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncSourceImageId
         * 
         * This method is responsible for swapping out the sourceImageId value
         * for operations. The reason this is required is because when a save
         * happens, previous operations (before the save action) have a
         * sourceImageId that corresponds to the draft at that time. But when a
         * save happens, the draft imageId changes, and so the previous
         * operations would be seen to be different, and would result in
         * improper Footer button UI states.
         * 
         * So, this method should only really be called when a save action
         * happens, since at the moment, that's the only time the account's
         * draft image can have it's imageId changed.
         * 
         * @access public
         * @param  String previousSourceImageId
         * @param  String newSourceImageId
         * @return void
         */
        syncSourceImageId: function(previousSourceImageId, newSourceImageId) {
            var account = Stencil.account(),
                index,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            for (index in redoHistory) {
                operation = redoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId;
                }
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId;
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncWatermark
         * 
         * This method is responsible for removing any watermark layers from
         * change operations that match the passed in uploadKey argument. This
         * needs to exist because it's possible for a user to delete a watermark
         * that exists in the change history stacks. If this isn't taken into
         * consideration, iterating through the change history can cause a bug.
         * 
         * This method does not yet splice out the watermark operations for the
         * deleted watermark. Ideally, it would.
         * 
         * @access public
         * @param  String uploadKey
         * @return void
         */
        syncWatermark: function(uploadKey) {
            var account = Stencil.account(),
                index,
                index2,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo(),
                watermark,
                watermarks;
            for (index in redoHistory) {
                operation = redoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                redoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                undoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });

            // 
            ChangeHistory.replaceConsecutiveMirrors();
        },

        /**
         * track
         * 
         * This is the heavy-lifter. It tracks a change operation in the undo
         * history, and when an und operation happens, ensures the redo array
         * receives the previously undone operation.
         * 
         * @note   The redo and undo property checks are meant to determine
         *         if the source of a trackChangeHistory call is from undoing
         *         or redoing a previous change. We do not want to track those,
         *         since they're not actually changes the user is performing,
         *         but rather changes they're reverting, or reverting back to.
         * @access public
         * @param  Boolean clearRedoHistory
         * @param  false|jQuery event The event (if any) that triggered the
         *         track call, currently being used for grouping related
         *         operations
         * @return void
         */
        track: function(clearRedoHistory, event) {
// console.log('track called');
            var draft = Stencil.account().draft(),
                currentConfiguration = draft.getConfiguration(),
                account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo();

            // This should only happen when the app is initially loaded
            if (undoHistory.length === 0) {
                var currentUnixTimestamp = new Date().getTime() / 1000,
                    operation = {
                        configuration: currentConfiguration,
                        description: _getOperationDescription(),
                        timestamp: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        },
                        type: _getOperationType()
                    };
                undoHistory.push(operation);
                account.set({
                    'settings.changeHistory': JSON.stringify({
                        'redo': ChangeHistory.history.redo(),
                        'undo': undoHistory
                    })
                });
                _operationType = false;
            } else {
                var lastUndoChange = undoHistory[undoHistory.length - 1],
                    currentConfigurationString = JSON.stringify(currentConfiguration),
                    lastUndoChangeString = JSON.stringify(lastUndoChange.configuration);
                currentConfigurationString = currentConfigurationString.addSpacesToRgba();
                lastUndoChangeString = lastUndoChangeString.addSpacesToRgba();
                if (currentConfigurationString !== lastUndoChangeString) {

                    // Operation
                    var currentUnixTimestamp = new Date().getTime() / 1000,
                        operation = {
                            configuration: currentConfiguration,
                            description: _getOperationDescription(),
                            timestamp: {
                                full: currentUnixTimestamp,
                                simple: Math.floor(currentUnixTimestamp)
                            },
                            type: _getOperationType()
                        };

                    // If the operation should replace the last one
                    if (_replacableOperation(operation, event) === true) {
                        ChangeHistory.replaceLastUndoOperation(operation);
                        undoHistory = ChangeHistory.history.undo();
                    } else {
                        undoHistory.push(operation);
                    }

                    // 
                    var maxOperations = _getMaxOperations();
                    _operationType = false;
                    undoHistory = undoHistory.slice(0 - maxOperations - 1);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': ChangeHistory.history.redo(),
                            'undo': undoHistory
                        })
                    });

                    /**
                     * Clear redo history
                     * 
                     * This logic ensures the redo history is entirely cleared. This
                     * happens when a user actively makes any change to the image,
                     * since any previous changes in the redo history stack are no
                     * longer relevant.
                     * 
                     * It's also being triggered when the app initially loads, since
                     * the redo stack should be empty at that time anyway.
                     */
                    if (clearRedoHistory === true) {
                        account.set({
                            'settings.changeHistory': JSON.stringify({
                                'redo': [],
                                'undo': ChangeHistory.history.undo()
                            })
                        });
                    }
                } else {
                    _operationType = false;
                }
            }

            // Refresh shit
            App.getStage().getContent().refreshChangeHistoryElements();
            App.getStage().getContent().getChangeHistoryPopover().refresh();
        }

        /**
         * unpause
         * 
         * @access public
         * @return void
         */
        // unpause: function() {
        //     _paused = false;
        // }
    };
})();

/**
 * Frames
 * 
 * @abstract
 */
var Frames = (function() {

    /**
     * _all
     * 
     * @access private
     * @var    Array
     */
    var _all;

    // Public
    return {

        /**
         * all
         * 
         * @access public
         * @return Array
         */
        all: function () {
            return _all;
        },

        /**
         * store
         * 
         * @access public
         * @param  Array all
         * @return void
         */
        store: function (all) {
            _all = all;
        }
    };
})();

/**
 * Images
 * 
 * @abstract
 */
var Images = (function() {

    // Public
    return {

        /**
         * cloudFront
         * 
         * @access public
         * @param  String key
         * @return String
         */
        cloudFront: function(key) {
            var config = Stencil.get('config'),
                hosts = config.cloudFront.s3,
                bucket = config.amazon.s3.buckets.app.name,
                host = hosts[bucket];
            return 'https://' + (host) + '/' + (key);
        },

        /**
         * cloudinary
         * 
         * @note   Width set to 304 (double 152) for retina screens, and since
         *         biggest DOM container for images is 152px wide. Same goes for
         *         212 (106*2).
         * @access public
         * @param  String key
         * @param  Object options
         * @return String|false
         */
        cloudinary: function(key, options) {

            /**
             * Overhead that sets the Cloudinary bucket-name, and currently,
             * routes requests through CloudFront before Cloudinary (to save on
             * bandwidth costs).
             */
            var config = Stencil.get('config'),
                name = config.cloudinary.name,
                proxy = config.cloudinary.proxies[options.proxy || 's3'],
                hosts = {
                    cloudFront: config.cloudFront.cloudinary,
                    cloudinary: 'res.cloudinary.com'
                },
                base = 'https://' + (hosts.cloudFront) + '/' + (name) +
                    '/image/upload/',
                post = (proxy) + '/' + (key);

            // For product legacy testing
            post = post.replace(/sai\.images\.local/, 'sai.images');
            post = post.replace(/sai\.images\.dev/, 'sai.images');

            /**
             * Simply proxies the image through Cloudinary. Currently only being
             * used by vectors (since Cloudinary does not process vectors well),
             * and for legacy image uploads, when clicked, to determine their
             * width/height and save it to the db.
             */
            if (options.type === 'original') {
                return (base) + (post);
            }
            /**
             * 
             */
            else if (options.type === 'thumb') {

                /**
                 * I load a thumb half the size as below when the device pixel
                 * ratio is 1, since the retina version naturally isn't needed.
                 * This should speed the app up quite a bit (since less memory
                 * required for storing thumbs), but could result in an increase
                 * in transformations on Cloudinary.
                 */
                if (window.devicePixelRatio === 1) {
                    return Images.cloudinary(key, {
                        proxy: options.proxy || 's3',
                        type: 'minimum',
                        ratio: '1.0',
                        width: 152,
                        height: 106
                    });
                }
                return Images.cloudinary(key, {
                    proxy: options.proxy || 's3',
                    type: 'minimum',
                    ratio: '1.0',
                    width: 304,
                    height: 212
                });
                // return (base) + 'c_fill,h_212,w_304/' + (post);
                // return (base) + 'w_304/' + (post);
            }
            /**
             * Uses Cloudinary's new conditioning to return an image of minimum
             * width or height depending on the aspect ratio of the original
             * image, compared to the option which is passed in. Used very
             * conveniently to compare against the selected Frame's aspect
             * ratio.
             */
            else if (options.type === 'minimum') {
                var conditions = 'if_' +
                    'ar_gt_' + (options.ratio || '1.0') + ',' +
                    'h_' + (options.height) + ',' +
                    'c_scale' +
                    '/if_else,' +
                    'w_' + (options.width) + ',' +
                    'c_scale/';
                return (base) + (conditions) + (post);
            }
            /**
             * Scales the image to a specific width or height, depending on
             * which dimension type is passed in. Both can't be passed in.
             */
            else if (options.type === 'scale') {
                if (options.width !== undefined) {
                    return (base) + 'w_' + (options.width) + '/' + (post);
                } else if (options.height !== undefined) {
                    return (base) + 'h_' + (options.height) + '/' + (post);
                }
                return false;
            }
            return false;
        },

// https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/if_ar_gt_1.0,h_146,c_scale/if_else,w_100,c_scale/s3.local/asst2acf2efd

        // /**
        //  * loadData
        //  * 
        //  * @access public
        //  * @param  String url
        //  * @param  Function callback
        //  * @return void
        //  */
        // loadData: function(url, callback) {
        //     fabric.Image.fromURL(
        //         url,
        //         function(object) {
        //             Canvases.Proxy.getCotton().resizeTo(100, 100);
        //             Canvases.Proxy.getCotton().add(object);
        //             var content = Canvases.Proxy.getCotton().toDataURL({
        //                 format: 'jpeg',
        //                 quality: 1,
        //                 multiplier: 1
        //             });
        //             callback(content);
        //         },
        //         {
        //             crossOrigin: 'anonymous'
        //         }
        //     );
        // },

        /**
         * getFrameUrl
         * 
         * This function is currently only used in media-accessor preloading (
         * which at the moment is limited further to UploadAccessor preloading),
         * and in BackgroundBitmapDrawing url preloading. The logic is as
         * follows:
         * 
         * I first check if an accessor is defined. If it is, then I check to
         * see whether a width/height are defined. If that's the case, I can
         * safely determine it's ratio, and compare it with that of the Frame.
         * At that point, I return the appropriate image url for the Frame to
         * prevent multiple image url loading. "Appropriate" in this context
         * refers to the image url that that ensures it can be slid along the
         * appropriate axis, depending on whether it's taller than the Frame, or
         * wider that the Frame (but not both).
         * 
         * When an accessor could not be found (eg. an older upload that is not
         * available memory), or else the width/height aren't defined (eg.
         * legacy uploads, or the image hasn't yet has it's dimensions
         * "synced"), I simply return the best guess: that the image is going to
         * be slideable along it's horizontal / x axis, rather than vertically.
         * If this is not the case, it's not a big deal: it'll be determined
         * elsewhere.
         * 
         * @todo   Look into the case where the accessor is not found, or else
         *         the width/height isn't defined. In that case, might it be
         *         possible to check the thumb that's already loaded in the
         *         browser (if any), to determine the ratio? Might save an
         *         additional HTTP request.
         * @access public
         * @param  String key
         * @return String
         */
        // getFrameUrl: function(key) {
        //     var accessor = Stencil.getAccessor(key),
        //         dimensions = Canvases.Preview.getRenderedDimensions();
        //     if (accessor !== false) {
        //         if (
        //             accessor.get('width').toInt() !== 0
        //             && accessor.get('height').toInt() !== 0
        //         ) {
        //             var ratio = accessor.getRatio();
        //             if (ratio > Frame.getRatio()) {
        //                 return Images.cloudinary(key, {
        //                     type: 'scale',
        //                     height: dimensions.height.ceil()
        //                 });
        //             } else if (ratio === Frame.getRatio()) {
        //                 return Images.cloudinary(key, {
        //                     type: 'scale',
        //                     height: dimensions.height.ceil()
        //                 });
        //             }
        //             return Images.cloudinary(key, {
        //                 type: 'scale',
        //                 width: dimensions.width.ceil()
        //             });
        //         }
        //     }
        //     return Images.cloudinary(key, {
        //         type: 'scale',
        //         height: dimensions.height.ceil()
        //     });
        // },

        /**
         * getFrameUrl
         * 
         * Returns an image (referenced by passed in parameter) that perfectly
         * fits the canvas by using Cloudinary's new API feature to dynamically
         * resize image to a minimum width or height depending on the aspect
         * ratio of the original image compared to the aspect ratio of the
         * selected Frame).
         * 
         * If you need to revert, see the following commit:
         * dacd90d55129ea8017bfe76abb58fbb6631ebc31
         *
         * @access public
         * @param  String key
         * @param  CanvasView canvas
         * @return String
         */
        getFrameUrl: function(key, canvas) {
            var ratio = window.devicePixelRatio || 1,
                dimensions = canvas.getRenderedDimensions(),
                width = dimensions.width.ceil(),
                height = dimensions.height.ceil();
            width *= ratio;
            height *= ratio;
            return Images.cloudinary(key, {
                type: 'minimum',
                ratio: Frame.getRatio().round(1),
                width: width.round(0),
                height: height.round(0)
            });
        },

        /**
         * preload
         * 
         * @access public
         * @param  Array urls
         * @param  Function success
         * @param  Function error
         * @return void
         */
        preload: function(urls, success, error) {
            if (urls.length === 0) {
                success && success();
            } else {
                var img = new Image(),
                    url = urls.shift();
                img.onload = function() {
                    Images.preload(urls, success, error);
                };
                img.onerror = function() {
                    error && error();
                };
                img.src = url;
            }
        },

        /**
         * s3
         * 
         * Returns the path to original S3 media file.
         * 
         * @access public
         * @param  String key
         * @return String
         */
        s3: function(key) {
            var config = Stencil.get('config'),
                region = config.amazon.s3.buckets.app.region,
                bucket = config.amazon.s3.buckets.app.name,
                host = 'https://s3-' + (region) + '.amazonaws.com';
            return (host) + '/' + (bucket) + '/' + (key);
        }
    };
})();

/**
 * Modals
 * 
 * Handles modal interaction (opening, closing)
 * 
 * @abstract
 */
var Modals = (function() {

    /**
     * _open
     * 
     * @access private
     * @var    Array
     */
    var _open = [];

    // Public
    return {

        /**
         * close
         * 
         * Initiates a close, and keeps track of which modal is open (if any)
         * 
         * @access public
         * @return void
         */
        close: function() {
            $(_open).each(
                function(index, modal) {
                    // _open.splice(index, 1);
                    modal.triggerHandler('close');
                    // modal.remove();
                }
            );
        },

        /**
         * closeExcept
         * 
         * Initiates a close, but excludes closing certain types of modals (for
         * dependency reasons)
         * 
         * @example Modals.closeExcept(['Share'])
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   Array types
         * @return  void
         */
        closeExcept: function(types) {
            var constructors = [];
            $(types).each(
                function(index, type) {
                    type += 'ModalView';
                    constructors.push(window[type]);
                }
            );
            $(_open).each(
                function(index, modal) {
                    if (constructors.indexOf(modal.constructor) === -1) {
                        modal.triggerHandler('close');
                    }
                }
            );
        },

        /**
         * get
         * 
         * @example Modals.get('Share')
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   String type
         * @return  ModalView|false
         */
        get: function(type) {
            type += 'ModalView';
            var modal = false;
            $(_open).each(
                function(index, modalView) {
                    if (modalView.constructor === window[type]) {
                        modal = modalView;
                    }
                }
            );
            return modal;
        },

        /**
         * open
         * 
         * Returns a reference to the array containing all the open modals
         * 
         * @access public
         * @return Array
         */
        open: function() {
            return _open;
        },

        /**
         * show
         * 
         * All-purpose modal booting
         * 
         * @access public
         * @param  String type
         * @param  undefined|Object obj
         * @return ModalView
         */
        show: function(type, obj) {
            var $modal = Stencil.render((type) + 'Modal', obj || {});
                modal = new window[(type + 'ModalView')]($modal);
            _open.push(modal);
            App.find('> div.content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showAddCategory
         * 
         * @access public
         * @return AddCategoryModalView
         */
        showAddCategory: function() {
            var $modal = Stencil.render('AddCategoryModal'),
                admin = this.get('Admin'),
                modal = new AddCategoryModalView($modal, admin);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showAddCoupon
         * 
         * @access public
         * @return AddCouponModalView
         */
        showAddCoupon: function() {
            var $modal = Stencil.render('AddCouponModal'),
                admin = this.get('Admin'),
                modal = new AddCouponModalView($modal, admin);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showAddPromoSet
         * 
         * @access public
         * @return AddPromoSetModalView
         */
        showAddPromoSet: function() {
            var $modal = Stencil.render('AddPromoSetModal'),
                admin = this.get('Admin'),
                modal = new AddPromoSetModalView($modal, admin);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showAdmin
         * 
         * @access public
         * @return AdminModalView
         */
        showAdmin: function() {
            var $admin = Stencil.render('AdminModal'),
                modal = new AdminModalView($admin);
            _open.push(modal);
            App.find('> div.content').append($admin);
            return modal;
        },

        /**
         * showAlert
         * 
         * @access public
         * @param  String code
         * @param  Object settings
         * @return AlertModalView
         */
        showAlert: function(code, settings) {
            var $alert = Stencil.render('AlertModal', {
                    settings: settings,
                    code: code
                }),
                modal = new AlertModalView($alert, settings);
            _open.push(modal);
            App.find('> div.content').append($alert);
            return modal;
        },

        /**
         * showApplyCategories
         * 
         * @access public
         * @param  String type
         * @param  Accessor accessor
         * @return ApplyCategoriesModalView
         */
        showApplyCategories: function(type, accessor) {
            var $modal = Stencil.render('ApplyCategoriesModal', {
                    type: type,
                    accessor: accessor
                }),
                modal = new ApplyCategoriesModalView($modal, type, accessor);
            _open.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showApplyCoupon
         * 
         * @access public
         * @param  CheckoutModalView checkoutModal
         * @param  String code
         * @return ApplyCouponModalView
         */
        showApplyCoupon: function(checkoutModal, code) {
            var $applyCoupon = Stencil.render('ApplyCouponModal', {
                    plan: checkoutModal.getPlan(),
                    code: code || false
                }),
                modal = new ApplyCouponModalView($applyCoupon, checkoutModal);
            _open.push(modal);
            App.find('.modal.checkout .outer > .inner > .content').append(
                $applyCoupon
            );
            $applyCoupon.focusable().focus().select();
            // App.find('> div.content').append($couponCode);
            return modal;
        },

        /**
         * showCacheRefresh
         * 
         * @access public
         * @return ConnectionsModalView
         */
        showCacheRefresh: function() {
            var $cacheRefresh = Stencil.render('CacheRefreshModal'),
                modal = new CacheRefreshModalView($cacheRefresh);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append(
                $cacheRefresh
            );
            Browser.tablet() === false && $cacheRefresh.focusable().focus();
            return modal;
        },

        /**
         * showCancelAccount
         * 
         * @access public
         * @param  AccountAccessor account
         * @return CancelAccountModalView
         */
        showCancelAccount: function(account) {
            var $cancel = Stencil.render('CancelAccountModal', {
                    account: account
                }),
                modal = new CancelAccountModalView($cancel, account);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($cancel);
            return modal;
        },

        /**
         * showCheckout
         * 
         * @access public
         * @param  String plan
         * @param  String type
         * @return CheckoutModalView
         */
        showCheckout: function(plan, type) {
            var $checkout = Stencil.render('CheckoutModal', {
                    plan: plan,
                    type: type
                }),
                modal = new CheckoutModalView($checkout, plan, type);
            _open.push(modal);
            App.find('> div.content').append($checkout);
            Browser.tablet() === false && $checkout.focusable().focus();
            return modal;
        },

        /**
         * showChromeExtensionInstalled
         * 
         * @access public
         * @return ChromeExtensionInstalledModalView
         */
        showChromeExtensionInstalled: function() {
            var $installed = Stencil.render('ChromeExtensionInstalledModal'),
                modal = new ChromeExtensionInstalledModalView($installed);
            _open.push(modal);
            App.find('> div.content').append($installed);
            return modal;
        },

        /**
         * showClearCanvasConfirm
         * 
         * @note   href attribute is needed in order to focus
         * @access public
         * @param  Object data
         * @return ClearCanvasConfirmModalView
         */
        showClearCanvasConfirm: function(data) {
            var $confirm = Stencil.render('ClearCanvasConfirmModal', data),
                modal = new ClearCanvasConfirmModalView($confirm);
            _open.push(modal);
            App.find('> div.content').append($confirm);
            if (User.admin() === true) {
                var $first = $confirm.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            return modal;
        },

        /**
         * showConfirm
         * 
         * @note   href attribute is needed in order to focus
         * @access public
         * @param  Object data
         * @return ConfirmModalView
         */
        showConfirm: function(data) {
            var $confirm = Stencil.render('ConfirmModal', data),
                modal = new ConfirmModalView($confirm);
            _open.push(modal);
            App.find('> div.content').append($confirm);
            if (User.admin() === true) {
                var $first = $confirm.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            return modal;
        },

        /**
         * showConfirmDelete
         * 
         * @access public
         * @param  String h1
         * @param  undefined|String h2
         * @return ConfirmModalView
         */
        showConfirmDelete: function(h1, h2) {
            if (h2 === undefined) {
                h2 = 'This cannot be undone';
            }
            return this.showConfirm({
                h1: h1,
                h2: h2
            });
        },

        /**
         * showConnections
         * 
         * @access public
         * @access String network
         * @return ConnectionsModalView
         */
        showConnections: function(network) {
            var $connections = Stencil.render('ConnectionsModal', {
                    network: network
                }),
                settings = this.get('Settings'),
                modal = new ConnectionsModalView($connections, network);
            _open.push(modal);
            App.find('.modal.settings .outer > .inner > .content').append(
                $connections
            );
            modal.refresh();
            return modal;
        },

        /**
         * showCountdown
         * 
         * @access public
         * @param  Boolean onboard
         * @return CountdownModalView
         */
        showCountdown: function(onboard) {
            var $relative = App.getStage().find('header .quota.bar:visible'),
                $countdown = Stencil.render('CountdownModal', {
                    account: Stencil.account(),
                    onboard: onboard
                }),
                modal = new CountdownModalView(
                    $countdown,
                    'up',
                    $relative
                );
            _open.push(modal);
            App.find('> div.content').append($countdown);
            modal.position();
            return modal;
        },

        /**
         * showDownload
         * 
         * @access public
         * @param  String key
         * @return DownloadModalView
         */
        showDownload: function(key) {
            var image = Stencil.getAccessor(key),
                $markup = Stencil.render('DownloadModal', {
                    image: image
                }),
                modal = new DownloadModalView($markup, image);
            _open.push(modal);
            App.find('> div.content').append($markup);
            modal.show();
            return modal;
        },

        /**
         * showExtras
         * 
         * @access public
         * @return ExtrasModalView
         */
        showExtras: function() {
            var code = Stencil.get('config').bookmarklet,
                converted = Bookmarkleter.convert(code),
                $extras = Stencil.render('ExtrasModal', {
                    // code: converted
                }),
                modal = new ExtrasModalView($extras);
            _open.push(modal);
            App.find('> div.content').append($extras);
            return modal;
        },

        /**
         * showGoogleFonts
         * 
         * @access public
         * @return GoogleFontsModalView
         */
        showGoogleFonts: function() {
            var $modal = Stencil.render('GoogleFontsModal', {
                    total: Stencil.get('config').google.fonts.total
                }),
                modal = new GoogleFontsModalView($modal);
            _open.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showLegacyImageNormalize
         * 
         * @access public
         * @param  String key
         * @return LegacyImageNormalizeModalView
         */
        showLegacyImageNormalize: function(key) {
            var image = Stencil.getAccessor(key),
                $legacyImageNormalize = Stencil.render(
                    'LegacyImageNormalizeModal', {
                        image: image
                    }
                ),
                modal = new LegacyImageNormalizeModalView(
                    $legacyImageNormalize,
                    image
                );
            _open.push(modal);
            App.find('> div.content').append($legacyImageNormalize);
            return modal;
        },

        /**
         * showLogin
         * 
         * @access public
         * @param  String type
         * @param  false|String redirect
         * @return LoginModalView
         */
        showLogin: function(type, redirect) {
            var $login = Stencil.render('LoginModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new LoginModalView($login, type, redirect);
            _open.push(modal);
            App.find('> div.content').append($login);
            if ($login.find('[name="data[email]"]').val() !== '') {
                Browser.tablet() === false
                    && $login.find('[type="password"]').focus();
            } else {
                Browser.tablet() === false
                    && $login.find('[name="data[email]"]').focus();
            }
            return modal;
        },

        /**
         * showOnboard
         * 
         * @access public
         * @return OnboardModalView
         */
        showOnboard: function() {
            var $relative = App.getStage().find('footer span.focus'),
                $highlight = $relative.find('a'),
                $onboard = Stencil.render('OnboardModal'),
                modal = new OnboardModalView(
                    $onboard,
                    'down',
                    $relative,
                    $highlight
                );
            _open.push(modal);
            App.find('> div.content').append($onboard);
            modal.position();
            return modal;
        },

        /**
         * showPassword
         * 
         * @access public
         * @param  String type
         * @param  false|String redirect
         * @return PasswordModalView
         */
        showPassword: function(type, redirect) {
            var $password = Stencil.render('PasswordModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new PasswordModalView($password, type, redirect);
            _open.push(modal);
            App.find('> div.content').append($password);
            Browser.tablet() === false && $password.focusable().focus();
            return modal;
        },

        /**
         * showPlanSwitch
         * 
         * @access public
         * @param  String plan
         * @return PlanSwitchModalView
         */
        showPlanSwitch: function(plan) {
            var $planSwitch = Stencil.render('PlanSwitchModal', {
                    plan: plan
                }),
                modal = new PlanSwitchModalView($planSwitch);
            _open.push(modal);
            App.find('> div.content').append($planSwitch);
            return modal;
        },

        /**
         * showPlanSwitched
         * 
         * @access public
         * @param  String plan
         * @return PlanSwitchedModalView
         */
        showPlanSwitched: function(plan) {
            var $planSwitched = Stencil.render('PlanSwitchedModal', {
                    plan: plan
                }),
                modal = new PlanSwitchedModalView($planSwitched);
            _open.push(modal);
            App.find('> div.content').append($planSwitched);
            return modal;
        },

        /**
         * showPlans
         * 
         * @access public
         * @return PlansModalView
         */
        showPlans: function(settings) {
            var $plans = Stencil.render('PlansModal', {
                    type: settings.curtain === true ? 'curtain' : 'default'
                }),
                modal = new PlansModalView($plans);
            _open.push(modal);
            App.find('> div.content').append($plans);
            return modal;
        },

        /**
         * showPromo
         * 
         * @access public
         * @param  String|false partner
         * @param  String type
         * @param  false|String redirect
         * @return PromoModalView
         */
        showPromo: function(partner, type, redirect) {
            var $promo = Stencil.render('PromoModal', {
                    partner: partner,
                    redirect: redirect,
                    type: type
                }),
                modal = new PromoModalView($promo, type, redirect);
            _open.push(modal);
            App.find('> div.content').append($promo);
            if ($promo.find('[name="data[name]"]').val() !== '') {
                Browser.tablet() === false
                    && $promo.find('[name="data[code]"]').focus();
            } else {
                Browser.tablet() === false
                    && $promo.find('[name="data[name]"]').focus();
            }
            return modal;
        },

        /**
         * showRename
         * 
         * @access public
         * @param  Accessor accessor
         * @return RenameModalView
         */
        showRename: function(accessor) {
            var $modal = Stencil.render('RenameModal', {
                    accessor: accessor
                }),
                modal = new RenameModalView($modal);
            _open.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showRightClick
         * 
         * @access public
         * @return RightClickModalView
         */
        showRightClick: function() {
            var $relative = App.getStage().find('.canvas-container.preview-canvas-container'),
                // $highlight = App.getStage().find(
                $highlight = App.find(
                    '.canvas-container.preview-canvas-container, ' +
                    '.toolbar.text'
                ),
                $onboard = Stencil.render('RightClickModal'),
                modal = new RightClickModalView(
                    $onboard,
                    'down',
                    $relative,
                    $highlight
                );
// StencilBooter.log($highlight.length);
            _open.push(modal);
            App.find('> div.content').append($onboard);
            modal.position();
            return modal;
        },

        /**
         * showSearchUsers
         * 
         * @access public
         * @param  AdminUsersView section
         * @return SearchUsersModalView
         */
        showSearchUsers: function(section) {
            var $modal = Stencil.render('SearchUsersModal'),
                modal = new SearchUsersModalView($modal, section);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showSent
         * 
         * @access public
         * @param  ShareModalView shareModal
         * @param  ImageAccessor image
         * @return ImageSentModalView
         */
        showSent: function(shareModal, image) {
            var $modal = Stencil.render('ImageSentModal'),
                modal = new ImageSentModalView($modal, shareModal, image);
            _open.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showSettings
         * 
         * @access public
         * @return SettingsModalView
         */
        showSettings: function() {
            var $settings = Stencil.render('SettingsModal', {
                    refereeSavings: Stencil.get('config').defaults.refereeSavings,
                    refererCredit: Stencil.get('config').defaults.refererCredit
                }),
                modal = new SettingsModalView($settings);
            _open.push(modal);
            App.find('> div.content').append($settings);
            return modal;
        },

        /**
         * showShare
         * 
         * @access public
         * @param  ImageAccessor image
         * @return ShareModalView
         */
        showShare: function(image) {
            var $share = Stencil.render('ShareModal', {
                    image: image
                }),
                modal = new ShareModalView($share, image);
            _open.push(modal);
            App.find('> div.content').append($share);
            return modal;
        },

        /**
         * showShareError
         * 
         * @access public
         * @param  ShareModalView shareModal
         * @param  ImageAccessor image
         * @param  ConnectionAccessor connection
         * @return ShareErrorModalView
         */
        showShareError: function(shareModal, image, connection) {
            var $modal = Stencil.render('ShareErrorModal', {
                    connection: connection
                }),
                modal = new ShareErrorModalView(
                    $modal,
                    shareModal,
                    image,
                    connection
                );
            _open.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showShareSuccess
         * 
         * @access public
         * @param  ShareModalView shareModal
         * @param  ShareAccessor share
         * @return ShareSuccessModalView
         */
        showShareSuccess: function(shareModal, share) {
            var $modal = Stencil.render('ShareSuccessModal', {
                    share: share
                }),
                modal = new ShareSuccessModalView($modal, shareModal, share);
            _open.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showSignup
         * 
         * @access public
         * @param  String type
         * @param  false|String redirect
         * @return SignupModalView
         */
        showSignup: function(type, redirect) {
            var $signup = Stencil.render('SignupModal', {
                    image: {
                        data: type === 'save' ? Stencil.account().draft().getSrc() : false
                    },
                    redirect: redirect,
                    type: type
                }),
                modal = new SignupModalView($signup, type, redirect);
            _open.push(modal);
            App.find('> div.content').append($signup);
            Browser.tablet() === false && $signup.focusable().focus();
            return modal;
        },

        /**
         * showTemplate
         * 
         * @access public
         * @param  String templateKey
         * @return ModalView
         */
        showTemplate: function(templateKey) {
            var hash = {
                    'backgroundUploadedOnboarding': 'BackgroundUploadedOnboardingModal',
                    'graphicUploadedOnboarding': 'GraphicUploadedOnboardingModal'
                },
                $modal = Stencil.render(hash[templateKey]),
                modal = new ModalView($modal);
            _open.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showTutorials
         * 
         * @access public
         * @param  String section
         * @return TutorialsModalView
         */
        showTutorials: function(section) {
            var tutorials = Stencil.get('config').defaults.tutorials,
                $tutorials = Stencil.render('TutorialsModal', {
                    tutorials: tutorials
                }),
                modal = new TutorialsModalView($tutorials, tutorials);
            _open.push(modal);
            App.find('> div.content').append($tutorials);
            return modal;
        },

        /**
         * showUpdateUser
         * 
         * @access public
         * @param  String key
         * @param  AdminUsersView section
         * @return UpdateUserModalView
         */
        showUpdateUser: function(key, section) {
            var $modal = Stencil.render('UpdateUserModal', {
                    user: Stencil.getAccessor(key)
                }),
                modal = new UpdateUserModalView($modal, key, section);
            _open.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            Browser.tablet() === false && $modal.focusable().focus();
            return modal;
        },

        /**
         * showUpgrade
         * 
         * @access public
         * @param  String plan
         * @param  String reason
         * @return UpgradeModalView
         */
        showUpgrade: function(plan, reason) {
            var $upgrade = Stencil.render('UpgradeModal', {
                    plan: plan,
                    reason: reason
                }),
                modal = new UpgradeModalView($upgrade);
            _open.push(modal);
            App.find('> div.content').append($upgrade);
            return modal;
        },

        /**
         * showUpgraded
         * 
         * @access public
         * @param  String plan
         * @return UpgradedModalView
         */
        showUpgraded: function(plan) {
            var $upgraded = Stencil.render('UpgradedModal', {
                    plan: plan
                }),
                modal = new UpgradedModalView($upgraded, plan);
            _open.push(modal);
            App.find('> div.content').append($upgraded);
            return modal;
        },

        /**
         * showWelcomeTour
         * 
         * @access public
         * @return WelcomeModalView
         */
        showWelcomeTour: function() {
            var $welcome = Stencil.render('WelcomeTourModal'),
                modal = new WelcomeTourModalView($welcome);
            _open.push(modal);
            App.find('> div.content').append($welcome);
            return modal;
        },

        /**
         * showYouTubeVideo
         * 
         * @access public
         * @param  String youTubeSlug
         * @param  Object options
         * @return YouTubeVideoModalView
         */
        showYouTubeVideo: function(youTubeSlug, options) {
            var $youTubeVideo = Stencil.render('YouTubeVideoModal', {
                    youTubeSlug: youTubeSlug,
                    options: options
                }),
                modal = new YouTubeVideoModalView(
                    $youTubeVideo,
                    youTubeSlug,
                    options
                );
            _open.push(modal);
            App.find('> div.content').append($youTubeVideo);
            return modal;
        }
    };
})();

/**
 * Normalizer
 * 
 * @abstract
 */
var Normalizer = (function() {

    /**
     * _documents
     * 
     * @var    Object
     * @access private
     */
    var _documents = {
        legacy: {},
        normalized: {
            layers: []
        }
    };

    /**
     * _order
     * 
     * @var    Number (default: 0)
     * @access private
     */
    var _order = 0;

    /**
     * _backgroundImageLayer
     * 
     * @access private
     * @return void
     */
    var _backgroundImageLayer = function() {
        var layer = {
            background: true,
            filters: [],
            image: false,
            styles: {
                left: 50,
                top: 50
            },
            type: 'image'
        };
        jQuery.each(_documents.legacy.layers, function() {
            if (this.type === 'image') {
                layer.image = this.sourceSrc;
                layer.filters = _getAppliedFilters(this);
            }
        });
        _documents.normalized.layers.push(layer);
    };

    /**
     * _backgroundRectangleLayer
     * 
     * @access private
     * @return void
     */
    var _backgroundRectangleLayer = function() {
        var layer = {
            background: true,
            styles: {
                backgroundColor: pusher.color('#ffffff').html(),
                height: 100,
                left: 50,
                top: 50,
                width: 100
            },
            type: 'rectangle'
        };
        jQuery.each(_documents.legacy.layers, function() {
            if (this.type === 'rectangle') {
                layer.styles.backgroundColor = pusher.color(
                    this.styles.fillStyle
                ).html();
            }
        });
        _documents.normalized.layers.push(layer);
    };

    /**
     * _getAppliedFilters
     * 
     * @access private
     * @param  Object sourceLayer
     * @return Array
     */
    var _getAppliedFilters = function(sourceLayer) {
        var encoded = JSON.stringify(sourceLayer),
            matching = [],
            possible = {
                'blur': 'blur',
                'darken': 'darken',
                'greyscale': 'bw',
                'sepia': 'sepia',
                'grungy': 'grungy',
                'glowingSun': 'glowingSun',
                'inverse': 'inverse',
                'lomo': 'lomo',
                'vintage': 'vintage',
                'posterize': 'posterize',
                'clarity': 'clarity',
                'sinCity': 'sinCity',
                'orangePeel': 'orangePeel',
                'hazyDays': 'hazyDays',
                'hemingway': 'hemingway',
                'concentrate': 'concentrate',
                'sunrise': 'sunrise',
                'love': 'love'
            },
            check;
        for (var index in possible) {
            check = new RegExp('type\"\:[ ]?\"' + (index), 'i');
            if (encoded.match(check) !== null) {
                matching.push(possible[index]);
            }
        }
        return matching;
    };

    /**
     * _getCanvasHeight
     * 
     * @access private
     * @return Number
     */
    var _getCanvasHeight = function() {
        var json = JSON.stringify(_documents.legacy),
            matches = json.match(/\"height\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 385;
        }
        return matches.pop().toInt();
    };

    /**
     * _getCanvasWidth
     * 
     * @access private
     * @return Number
     */
    var _getCanvasWidth = function() {
        var json = JSON.stringify(_documents.legacy),
            matches = json.match(/\"width\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 495;
        }
        return matches.pop().toInt();
    };

    /**
     * _getDefaultBackdropPaddingFactor
     * 
     * @access private
     * @return Number
     */
    var _getDefaultBackdropPaddingFactor = function() {
        return Stencil.get('config').defaults.backdropPaddingFactor;
    };

    /**
     * _getDefaultStrokeWidthDividingFactor
     * 
     * @access private
     * @return Number
     */
    var _getDefaultStrokeWidthDividingFactor = function() {
        return Stencil.get('config').defaults.strokeWidthDividingFactor;
    };

    /**
     * _getTranslatedPosition
     * 
     * @access private
     * @param  Object sourceLayer
     * @return Object
     */
    var _getTranslatedPosition = function(sourceLayer) {
        var position = {
            repositionLeft: true,
            repositionTop: true,
            left: sourceLayer.styles.x,
            top: sourceLayer.styles.y
        };
        if (position.left === 'center') {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (position.top === 'center') {
            position.repositionTop = false;
            position.top = 50;
        }
        position.left = position.left.round(4);
        position.top = position.top.round(4);
        if (isNaN(position.left) === true) {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (isNaN(position.top) === true) {
            position.repositionTop = false;
            position.top = 50;
        }
        return position;
    };

    /**
     * _textLayer
     * 
     * @access private
     * @param  Object sourceLayer
     * @return void
     */
    var _textLayer = function(sourceLayer) {
        var layer = {
            styles: {
                angle: 0,
                backdropColor: false,
                backdropPaddingFactor: _getDefaultBackdropPaddingFactor(),
                backdropStretch: 'slim',
                bold: false,
                italic: false,
                // lineHeight: 1.2,
                lineHeight: 1.1,
                // lineHeight: 1,
                order: _order,
                strokeColor: false,
                strokeWidthDividingFactor: _getDefaultStrokeWidthDividingFactor(),
                underline: false
            },
            text: sourceLayer.styles.text,
            type: 'text'
        };

        // Positioning
        var position = _getTranslatedPosition(sourceLayer);
        layer.styles.repositionLeft = position.repositionLeft;
        layer.styles.repositionTop = position.repositionTop;
        layer.styles.left = position.left;
        layer.styles.top = position.top;

        // Font size (reverse of relative font sizing in TextDrawing class)
        var fontSize = sourceLayer.styles.fontSize.toFloat();
        layer.styles.fontSize = (fontSize / _getCanvasWidth() * 1000 * 0.95).round(4);

        // 95% width
        layer.styles.width = 95;

        // The rest..
        layer.styles.align = sourceLayer.styles.align;
        layer.styles.fontFamily = sourceLayer.styles.fontFamily;
        layer.styles.textColor = pusher.color(
            sourceLayer.styles.fillStyle
        ).html();
        if (sourceLayer.plane !== undefined) {
            layer.styles.backdropColor = pusher.color(sourceLayer.plane).html();
            layer.styles.backdropStretch = 'full';
        }
        if (
            sourceLayer.styles.strokeStyle !== undefined
            && (
                sourceLayer.styles.strokeWidth !== undefined
                && sourceLayer.styles.strokeWidth.toInt() !== 0
            )
        ) {
            layer.styles.strokeColor = pusher.color(
                sourceLayer.styles.strokeStyle
            ).html();
        }
        else {
            // layer.styles.shadow = 'rgba(0,0,0,0.25)';
        }
        if (sourceLayer.styles.fontStyle === 'italic') {
            layer.styles.italic = true;
        }
        if (sourceLayer.styles.fontStyle === 'bold') {
            layer.styles.bold = true;
        }
        _documents.normalized.layers.push(layer);
    };

    /**
     * _textLayers
     * 
     * @access private
     * @return void
     */
    var _textLayers = function() {
        jQuery.each(_documents.legacy.layers, function() {
            if (this.type === 'text') {
                _textLayer(this);
                ++_order;
            }
        });
    };

    // Public
    return {

        /**
         * image
         * 
         * @access public
         * @param  String json
         * @return void
         */
        image: function(json) {
            _documents.legacy = JSON.parse(json);
            _documents.normalized.layers = [];
            _order = 0;
            _backgroundRectangleLayer();
            _backgroundImageLayer();
            _textLayers();
            return JSON.stringify(_documents.normalized);
        }
    };
})();

/**
 * Scripts
 * 
 * @abstract
 */
var Scripts = (function() {

    /**
     * _load
     * 
     * @note   It's important that the error callback for this call does not
     *         trigger a Stencil.alive / Stencil.error call. This is because I'm 
     *         managing Scripts failing to load within AppView.waitFor where I
     *         show a Stencil.alert instead communicating to the user that the
     *         dependency failed to load.
     * @access private
     * @param  String name
     * @param  Function|undefined callback
     * @return void
     */
    var _load = function(name, callback) {
        var listener = 'script/' + (name) + '/loaded';
        if (_loaded[name]) {
            callback && callback();
        } else {
            callback && Stencil.on(listener, callback);
            if (!_loading[name]) {
                _loading[name] = true;
                var signature = {file: 'Scripts', line: 31};
                Stencil.ajax({
                    cache: true,
                    signature: signature,
                    sign: false,
                    timeout: 60 * 1000,
                    url: _urls[name],
                    type: 'GET',
                    dataType: 'script',
                    error: function(jqXHR, textStatus, errorThrown) {
                        App.log('jQuery AJAX error', true);
                        App.log(signature, true);
                        App.log(arguments, true);
                        // Leave this commented, and see @note above
                        // Stencil.alive(function() {
                        //     var code = 's35-' + (name),
                        //         reference = 'scripts';
                        //     Stencil.error(code, reference);
                        // });
                    },
                    success: function() {
                        _loaded[name] = true;
                        _loading[name] = false;
                        Stencil.triggerHandler('script/loaded', [name]);
                        Stencil.triggerHandler(listener);
                    }
                });
            }
        }
    };

    /**
     * _loaded
     * 
     * @access private
     * @var    Object
     */
    var _loaded = {};

    /**
     * _loading
     * 
     * @access private
     * @var    Object
     */
    var _loading = {};

    /**
     * _urls
     * 
     * @access private
     * @var    Object
     */
    var _urls = {
        accountDock: 'https://static.accountdock.com/app.min.js',
        aws: '/app/static/vendors/external/aws-sdk-2.1.39.min.js',
        facebook: 'https://connect.facebook.net/en_US/sdk.js',
        headway: 'https://cdn.headwayapp.co/widget.js',
        segment: 'https://cdn.segment.com/analytics.js/v1/key/analytics.min.js',
        stripe: 'https://js.stripe.com/v2/',
        tapfiliate: 'https://static.tapfiliate.com/tapfiliate.js',
        twitter: 'https://platform.twitter.com/widgets.js'
    };

    // Public
    return {

        /**
         * get
         * 
         * @access public
         * @param  String key
         * @return String
         */
        get: function(key) {
            return _urls[key];
        },

        /**
         * load
         * 
         * @access public
         * @param  String name
         * @param  Function|undefined callback
         * @return void
         */
        load: function(name, callback) {
            _load(name, callback);
        },

        /**
         * loaded
         * 
         * @access public
         * @param  String name
         * @return void
         */
        loaded: function(name) {
            return _loaded[name] === true;
        },

        /**
         * set
         * 
         * @access public
         * @param  String key
         * @param  String url
         * @return void
         */
        set: function(key, url) {
            _urls[key] = url;
        }
    };
})();

/**
 * Services
 * 
 * @abstract
 */
var Services = (function() {

    // Public
    return {

        /**
         * check
         * 
         * @access public
         * @param  String service
         * @return Boolean
         */
        check: function(service) {
            var services = Stencil.get('config').services;
            return services[service] === true;
        }
    };
})();
StencilBooter.queue.push(StencilBooter.requires('Class', function() {

    /**
     * Simple
     * 
     * @fires   set
     *          set/<x>
     * @extends Class
     */
    window.Simple = Class.extend({

        /**
         * _data
         * 
         * Simple storage hash that can be used quite widely, since so many
         * classes extend Simple.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _data: {},

        /**
         * _handlerType
         * 
         * Variable to track what type of class the instance is, which is then
         * used in logging to show a different color for the message.
         * 
         * I chose the variable name <_handlerType> because <_type> might be too
         * generally, and conflict with other instance-properties. 
         * 
         * @access protected
         * @var    String (default: 'simple')
         */
        _handlerType: 'simple',

        /**
         * _logEvents
         * 
         * Marks whether or not events that are triggered against this object
         * are logged to the console.
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Simple')
         */
        _string: 'Simple',

        /**
         * _timers
         * 
         * Object to keep track of timers, instance-wide.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _timers: {},

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._data = {};
            this._timers = {};
        },

        /**
         * get
         * 
         * @access public
         * @param  String key
         * @return mixed
         */
        get: function(key) {
            return this._data[key];
        },

        /**
         * log
         * 
         * Logging method, which with the exception of the alwaysLog parameter,
         * abides by the logic within Stencil.log as to whether or not anything
         * is actually logged to the console. The toString method is used here
         * to pass along the name of the instance.
         * 
         * @access public
         * @param  String msg
         * @param  undefined|true alwaysLog
         * @return void
         */
        log: function(msg, alwaysLog) {
            Stencil.log(
                this._handlerType,
                String(this),
                msg,
                $(arguments).toArray(),
                alwaysLog === true
            );
        },

        /**
         * on
         * 
         * Proxy for jQuery on method.
         * 
         * @access public
         * @return void
         */
        on: function() {
            $(this).on.apply($(this), $(arguments).toArray());
        },

        /**
         * once
         * 
         * Proxy for jQuery one method.
         * 
         * @access public
         * @return void
         */
        once: function() {
            $(this).one.apply($(this), $(arguments).toArray());
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   Object|String key
         * @param   undefined|Number|String value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Run set the set for all the properties in the object
            this._data = jQuery.extend(true, {}, this._data, data);

            // Events
            var index, value;
            for (index in data) {
                value = data[index];
                this.triggerHandler('set', [index, value]);
                this.triggerHandler('set/' + (index), [value]);
            }
        },

        /**
         * time
         * 
         * Helper method to track the execution duration of code, using the
         * passed in key to differentiate between different timers.
         * 
         * @access public
         * @param  mixed key
         * @return void
         */
        time: function(key) {
            var now = new Date().getTime();
            if (this._timers[key] === undefined) {
                this._timers[key] = now;
            } else {
                var message = 'Timer [' + (key) + '] ' +
                    (now - this._timers[key]);
                this.log(message);
                delete this._timers[key];
            }
        },

        /**
         * toString
         * 
         * Native method implementation, which at the moment, is used
         * extensively by logging.
         * 
         * @access public
         * @return String
         */
        toString: function() {
            return this._string;
        },

        /**
         * triggerHandler
         * 
         * Proxies a call to jQuery's triggerHandler function. triggerHandler is
         * is used in place of trigger, since trigger can conflict with native
         * events. For example, a call to trigger('click') would initiate native
         * event dispatching, along with events that were bound to the click
         * listener on the object.
         * 
         * It's worth noting that even if the object is set up to have it's
         * events logged, it will depend on other factors. See Stencil.log for
         * more information.
         * 
         * @access public
         * @return void
         */
        triggerHandler: function() {
            if (this._logEvents === true) {
                this.log(arguments[0]);
            }
            $(this).triggerHandler.apply($(this), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * Proxy for jQuery unbind method.
         * 
         * @access public
         * @return void
         */
        unbind: function() {
            $(this).unbind.apply($(this), $(arguments).toArray());
        }
    });
}));

/**
 * Track
 * 
 * @todo!    Move declarations of which events should be sent to which providers
 *           to the server side. Better to have that all sync'd up, since calls
 *           are also made on the server side.
 * @abstract
 */
var Track = (function() {

    /**
     * _tracked
     * 
     * @access private
     * @var    Object
     */
    var _tracked = {
        events: [],
        pages: []
    };

    // Public
    return {

        /**
         * alias
         * 
         * @note   The userAccount data is accessed directly, instead of through
         *         the UserAccountAccessor reference (eg.
         *         .active().userAccount()) since the reference won't have been
         *         created yet. The reason for this, is that creating that
         *         reference happens when the login/signup event is triggered.
         * @access public
         * @return void
         */
        alias: function() {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    var user = Stencil.get('user'),
                        id = user.active().get('userAccount').id;
                        // id = user.active().userAccount().get('id');
// StencilBooter.log(id);
                    analytics.alias(id);
                });
            }
        },

        /**
         * disable
         * 
         * @access public
         * @return void
         */
        disable: function() {
            Stencil.get('config').segment.enabled = false;
        },

        /**
         * enabled
         * 
         * Returns whether or not analytics should be tracked based on the role
         * of the environment.
         * 
         * @note   The hardcoded check against the account key below was due to
         *         a bug whereby events were spamming Segment. I believe this
         *         was related to a race-condition bug related to downloading
         *         an asset, specifically with Safari. I haven't confirmed if
         *         it's still ongoing, but it's likely safe to remove this
         *         check.
         * @access public
         * @return Boolean
         */
        enabled: function() {
            if (
                User.admin() === true
                || Stencil.account().get('key') === 'accnd0bcfeb0'
            ) {
                return false;
            }
            return Stencil.get('config').segment.enabled === true;
        },

        /**
         * event
         * 
         * @access public
         * @param  String action
         * @param  Object|undefined properties
         * @return void
         */
        event: function(action, properties) {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    properties = properties || {};
                    properties.category = 'App';
                    if (false) {
                        properties.category = 'Publisher';
                    }
                    // _tracked.events.push({
                    //     event: action,
                    //     properties: properties
                    // });
                    var integrations = {
                        'All': false,
                        'AdRoll': true,
                        'Facebook Pixel': true,
                        'Google Analytics': true,
                        // 'MailChimp': false,
                        'Mixpanel': true,
                        'Intercom': false
                    };
                    analytics.track(action, properties, integrations);
                });
            }
        },

        /**
         * page
         * 
         * @note   Greater-than check is performed to prevent initial call,
         *         since Segment automatically makes call upon load anyway.
         * @access public
         * @return void
         */
        page: function(path) {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    _tracked.pages.push(path);
                    if (_tracked.pages.length > 1) {
                        analytics.page({
                            path: path,
                            integrations: {
                                'All': false,
                                'AdRoll': true,
                                'Facebook Pixel': true,
                                'Google Analytics': true,
                                // 'MailChimp': false,
                                'Mixpanel': false,
                                'Intercom': false
                            }
                        });
                    }
                });
            }
        },

        /**
         * user
         * 
         * @note   The userAccount data is accessed directly, instead of through
         *         the UserAccountAccessor reference (eg.
         *         .active().userAccount()) since the reference won't have been
         *         created yet. The reason for this, is that creating that
         *         reference happens when the login/signup event is triggered.
         * @access public
         * @return void
         */
        user: function() {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    var user = Stencil.get('user'),
                        id = user.active().get('userAccount').id;
                        // id = user.active().userAccount().get('id');
                    analytics.identify(
                        id,
                        user.getTraits(),
                        {
                            integrations: {
                                'All': false,
                                'Google Analytics': false,
                                // 'MailChimp': false,
                                'Mixpanel': true,
                                'Intercom': false
                            }
                        }
                    );
                });
            }
        }
    };
})();

/**
 * User
 * 
 * @fires    login
 *           signup
 * @abstract
 */
var User = (function() {

    // Public
    return {

        /**
         * admin
         * 
         * Returns whether or not the logged in user (if any) is an admin.
         * 
         * @access public
         * @return Boolean
         */
        admin: function() {
            var user = Stencil.get('user');
            return User.exists() === true
                && user.setting('admin').toInt() === 1;
        },

        /**
         * customer
         * 
         * @note   proxy
         * @access public
         * @return Boolean
         */
        // customer: function() {
        //     return Stencil.get('user').customer();
        // },

        /**
         * editor
         * 
         * @access public
         * @return Boolean
         */
        editor: function() {
            var user = Stencil.get('user');
            return User.exists() === true
                && user.setting('editor').toInt() === 1;
        },

        /**
         * exists
         * 
         * Returns whether a user exists (aka. not a guest account). Initially
         * only had a false check, but there was an edge-case whereby this
         * method was being called before <Stencil.set> was called. When that
         * happened, the stored valued was <undefined>. I ran into this
         * edge-case when preparing logic for syncing image JSON data in the
         * ImageAccessor.
         * 
         * @access public
         * @return Boolean
         */
        exists: function() {
            var user = Stencil.get('user');
            return user !== false && user !== undefined;
        },

        /**
         * login
         * 
         * Performs the neccessary logic to log the user in, including
         * analytics, account reloading and firing events.
         * 
         * @note   Logic is very sensitive to ordering. Be careful :/
         * @access public
         * @return void
         */
        login: function() {
            var user = Stencil.get('user');
            Stencil.account().reload();
            Track.user();
            Track.event('Logged in');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('login', [user]);
            // Stencil.account().reload();
            Stencil.account().syncStars();

            // Get watermarks and turn on the ones that ought to be turned on
            var watermarks = Stencil.account().collection('watermarks'),
                // styles,
                active;
            watermarks.each(
                function(index, watermark) {
                    // styles = JSON.parse(watermark.setting('styles'));
                    active = watermark.setting('active').toInt() === 1;
                    if (active === true) {
                        watermark.addToCanvas(false);
                    }
                }
            );

            // // Delete all layers, excluding watermarks
            // var iD = Canvases.Preview.getImageDocument();
            // jQuery.each(iD.getLayers(false), function(index, layer) {
            //     layer.triggerHandler('delete');
            // });

            // // 
            // var draft = Stencil.account().draft();
            // draft.setToImage(image);
            // var document = draft.json();

            // // Set image document
            // Canvases.Preview.prepareAndDraw(document);
        },

        /**
         * logout
         * 
         * @see    https://segment.com/docs/libraries/analytics.js/
         * @see    http://stackoverflow.com/questions/21137286/what-should-i-do-when-users-log-out
         * @todo   Implement the same flow/logic that you do below for logging
         *         out when the app is open via an external chrome extension for
         *         the Alert and Error modal flows. At the moment, it simply
         *         changes the path of the parent page. Works for users that are
         *         at getstencil.com/app, but for those using the app through
         *         the extension, it's taking them to a new, unintented, page.
         *         Have the app slide down, and back up? Also, do this for the
         *         admin area when cancelling a user:
         *         https://i.imgur.com/lwStqly.png
         *         Will get annoying pretty fast :/
         * @access public
         * @param  Function callback
         * @return void
         */
        logout: function(callback) {

            // Messaging
            var msg = Stencil.getMessage('user.logout');
            App.getBusy().show(msg);

            // 
            var path = '/users/logout';
            Stencil.ajax({
                signature: {file: 'User', line: 139},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Stencil.kill();

                        // Callback delay
                        callback = callback || function() {
                            // var path = '/app',
                            var path = '/?bye',
                                options = Stencil.getOptions();
                            if (options.source.external === true) {
                                if (options.source.extension === true) {
                                    if (options.source.chrome === true) {
                                        var slide = Stencil.get('config').defaults.slide;
                                        path = '/app?external&extension&' +
                                            'chrome';
                                        App.hide();
                                        (function() {
                                            Stencil.postMessage(
                                                'message.app.logout'
                                            );
                                            window.location.assign(path);
                                        }).delay(slide);
                                    }
                                }
                            } else {
                                window.location.assign(path);
                            }
                        };

                        // Tracking condition
                        if (Track.enabled() === true) {
                            Scripts.load('segment', function() {
                                analytics.reset();
                                mixpanel.cookie.clear();
                                callback.delay(1000);
                            });
                        } else {
                            callback.delay(1000);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'u63-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * on
         * 
         * @access public
         * @return void
         */
        on: function() {
            $(User).on.apply($(User), $(arguments).toArray());
        },

        /**
         * once
         * 
         * @access public
         * @return void
         */
        once: function() {
            $(User).one.apply($(User), $(arguments).toArray());
        },

        /**
         * signup
         * 
         * Performs the neccessary logic to sign a user up within the app,
         * including analytics, property updating and firing events.
         * 
         * @note   Logic is very sensitive to ordering. Be careful :/
         * @note   Delay below is to ensure alias call is made before
         *         user/identify call
         * @access public
         * @return void
         */
        signup: function() {
            var user = Stencil.get('user');
            Stencil.account().set({
                'guest': 0
            });
            Track.alias();
            Track.user.delay(5 * 1000);
            Track.event('Signed up');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('signup', [user]);
        },

        /**
         * trackTapfiliateConversion
         * 
         * Ensures that Tapfiliate conversion operations to not happen if:
         * - Tracking is enabled in general (eg. locally or on dev)
         * - Tapfiliate service is turned off (eg. they're down)
         * - the window.tap property is undefined (likely aggressive AdBlocker)
         * - The user has more than one upgrade record (conversion tracking is
         *   not available if a user upgrades, downgrades, and then upgrades
         *   again)
         * 
         * @access public
         * @return Boolean
         */
        trackTapfiliateConversion: function() {
            if (Track.enabled() === false) {
                return false;
            }
            if (Services.check('tapfiliate') === false) {
                return false;
            }
            if (window.tap === undefined) {
                return false;
            }
            if (Stencil.account().get('upgrades').length > 1) {
                return false;
            }
            return true;
        },

        /**
         * triggerHandler
         * 
         * @access public
         * @return void
         */
        triggerHandler: function() {
            var msg = arguments[0];
            Stencil.log('user', 'User Event', msg);
            $(User).triggerHandler.apply($(User), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * @access public
         * @return void
         */
        unbind: function() {
            $(User).unbind.apply($(User), $(arguments).toArray());
        },

        /**
         * upgrade
         * 
         * @note   The properties here aren't prepended with an underscore since
         *         the naming convention here is important for conversion
         *         tracking with Facebook and AdRoll
         * @note   Revenue and value are both tracked, since different ad
         *         networks expect different key names
         * @note   The triggerHandler call needs to happen first to ensure the
         *         UpgradeAccessor is available. See here:
         *         https://i.imgur.com/iBEqG4F.png
         * @note   window.tap !== undefined check is to prevent error with ad
         *         blockers
         * @access public
         * @parma  false|Object stripeResponse
         * @return void
         */
        upgrade: function(stripeResponse) {
            Account.triggerHandler('upgrade', [Stencil.account()]);
            Track.user();
            if (stripeResponse !== false) {
                var upgrade = Stencil.account().upgrade(),
                    centsPaid = false;

                // Charge went through
                if (stripeResponse.charge !== false) {
                    centsPaid = stripeResponse.charge.data[0].amount.toInt();
                }
                // Likely no charge, but will be one when trial converts
                else if (stripeResponse.upcomingInvoice !== false) {
                    centsPaid = stripeResponse.upcomingInvoice.amount_due.toInt();
                }

                // Helper to determine if Tapfiliate tracking should be running
                if (User.trackTapfiliateConversion() === true) {
                    var identifier = upgrade.getTapfiliateCommissionTypeIdentifier(),
                        metaData = {
                            email: Stencil.get('user').get('email'),
                            id: Stencil.get('user').get('id'),
                            key: Stencil.get('user').get('key')
                        };
                    tap(
                        'conversion',
                        upgrade.get('key'),
                        centsPaid / 100,
                        {
                            meta_data: metaData
                        },
                        identifier,
                        function(conversion) {
                            upgrade.push(
                                'settings.tapfiliateConversionId',
                                conversion.id
                            );
                        }
                    );
                }
                Track.event('Upgraded', {
                    currency: 'USD',
                    revenue: centsPaid / 100,
                    value: centsPaid
                });
            }
        }
    };
})();
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * Drawing
     * 
     * @events  change/angle
     *          change/position
     *          change/scale
     * @extends Simple
     */
    window.Drawing = Simple.extend({

        /**
         * _boxInRatio
         * 
         * @access protected
         * @var    Number (default: 0.25)
         */
        _boxInRatio: 0.25,

        /**
         * _cotton
         * 
         * @access protected
         * @var    null|fabric.Object (default: null)
         */
        _cotton: null,

        /**
         * _drawn
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _drawn: false,

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'drawing')
         */
        _handlerType: 'drawing',

        /**
         * _layer
         * 
         * @access protected
         * @var    Layer (default: null)
         */
        _layer: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return {
                'change/position': function() {
                    this._layer.on({
                        'change/position': function(event, position) {
                            var objects = this.getCanvas().getCotton().getObjects();
                            jQuery.each(objects, function(index, object) {
                                object.setCoords();
                            });
                        }
                    });
                },
                'delete': function() {
                    this._layer.on({
                        'delete': function(event) {
                            if (this._drawing.drawn() === true) {
                                var cotton = this.getCotton(),
                                    drawing = this._drawing;
                                drawing.magnets.demagnetize.apply(drawing);
                                    // backdrop = cotton.backdrop;
                                // if (backdrop !== undefined) {
                                    // cotton.clearBackdrop();
                                // }
                                cotton.remove();
                                Toolbars.hide();
                            }
                        }
                    });
                },
                'flip': function() {
                    this._layer.on({
                        'flip/x': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipX(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'flip/y': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipY(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                },

                /**
                 * Nudging
                 * 
                 */
                'move': function() {
                    this._layer.on({
                        'move/up': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/right': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/down': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/left': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                },
                'order': function() {
                    this._layer.on({
                        'change/order': function(event, forward) {
                            this.getCanvas().render();
                        }
                    });
                },
                'position': function() {
                    this._layer.on({
                        'position/restored': function(event) {

                            // Top
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();

                            // Left
                            cotton = this.getCotton();
                            drawing = this._drawing;
                            left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                }
            };
        },

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _outline
         * 
         * @access protected
         * @var    fabric.Rect (default: null)
         */
        _outline: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Drawing')
         */
        _string: 'Drawing',

        /**
         * init
         * 
         * @access public
         * @param  Layer layer
         * @return void
         */
        init: function(layer) {
            this._super();
            this._layer = layer;
            this._setupListeners();
            this.magnets = this.magnets();
            this.relative = this.relative();
        },

        /**
         * _addBoxInListeners
         * 
         * Ensures that when an object is boxed in, it's left / top coordinates
         * are properly set.
         * 
         * @access protected
         * @return void
         */
        _addBoxInListeners: function() {
            this._cotton.on({
                'boxedIn': function(options) {
                    this.trigger('moving/manual');
                }
            });
        },

        /**
         * _addMoveListeners
         * 
         * Returns a 2-decimal-place position coordinate (left/top).
         * 
         * @access protected
         * @return void
         */
        _addMoveListeners: function() {
            var _this = this,
                closure = function(options) {
                    var position = {
                        left: (this.getRelativeLeft() * 100).round(4),
                        top: (this.getRelativeTop() * 100).round(4)
                    };
                    _this._layer.triggerHandler('change/position', [position]);
                };
            this._cotton.on({
                'moving': closure.proxy(this._cotton),
                'moving/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addRotateListeners
         * 
         * @access protected
         * @return void
         */
        _addRotateListeners: function() {
            var _this = this,
                closure = function(event) {
                    var angle = this.getAngle().round(4);
                    _this._layer.triggerHandler('change/angle', [angle]);
                };
            this._cotton.on({
                'rotating': closure.proxy(this._cotton),
                'rotating/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSnapListeners
         * 
         * Listens for snap events on the fabric object to ensure that the saved
         * top / left value is exactly the magnet-value. Without this listener,
         * the drawing would appear to snap, but once saved, the value would be
         * off. It'd also affect keyboard-shortcut nudging, since the
         * layer-stored left/top value wouldn't be the actual value that is seen
         * in the canvas/UI.
         * 
         * The same applies to snap / angle
         * 
         * @access protected
         * @return void
         */
        _addSnapListeners: function() {
            this._cotton.on({
                'snap/angle': function(options) {
                    this.trigger('rotating/manual');
                },
                'snap/position': function(options) {
                    this.trigger('moving/manual');
                },
                'snap/scale': function(options) {
                    this.trigger('scaling/manual');
                }
            });
        },

        /**
         * _getContrastingColor
         * 
         * @access protected
         * @param  String color
         * @return String rgba
         */
        _getContrastingColor: function(color) {
            var html = pusher.color(color).contrastWhiteBlack().html();
            html = html.replace(/\,[0-9\.]+\)$/, ')');
            html = html.replace('rgba', 'rgb');
            return html;
        },

        /**
         * _getDefaults
         * 
         * Worth noting is that the only time the originX or originY values will
         * not be set to center is in the case of a TextLayer in a legacy image.
         * This is because positioning was determined by the top + left
         * coordinate rather than center-point. If this is ever the case, right
         * after drawing the text will be converted to be use the center +
         * center origin.
         * 
         * @access protected
         * @return Object
         */
        _getDefaults: function() {
            return {
                stencilCornerFillColor: 'rgba(255, 255, 255, 1)',
                stencilCornerStrokeColor: 'rgba(0, 0, 0, 1)',
                stencilBorderColor1: 'rgba(0, 0, 0, 1)',
                stencilBorderColor2: 'rgba(255, 255, 255, 1)',
                stencilRotatingPointColor1: 'rgba(0, 0, 0, 1)',
                stencilRotatingPointColor2: 'rgba(255, 255, 255, 1)',
                // perPixelTargetFind: true,
                borderColor: 'rgba(0, 0, 0, 1)',
                cornerSize: Browser.tablet() === true ? 30 : 12,
                hasRotatingPoint: false,
                padding: Browser.tablet() === true ? 10 : 0,
                // padding: 10,
                originX: 'center',
                originY: 'center',
                rotatingPointOffset: 20,
                transparentCorners: false,
                lockSkewingX: true,
                lockSkewingY: true
            };
        },

        /**
         * _setupListeners
         * 
         * @access protected
         * @return void
         */
        _setupListeners: function() {
            var _this = this;
            this._listeners = this._listeners();
            jQuery.each(
                this._listeners,
                function(type, listener) {
                    listener.apply(_this);
                }
            );
        },

        /**
         * _setupOutline
         * 
         * @access protected
         * @return void
         */
        _setupOutline: function() {
            if (
                this.magnets.highlight === true
                && Account.highlightDrawingsOnSnap() === true
                && this.getCanvas() !== Canvases.Ghost
            ) {
                var cottons = {
                    centers: {
                        top: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        right: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        bottom: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        left: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        })
                    },
                    red: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: 'rgba(255, 0, 0, 1)',
                        strokeDashArray: [5, 5],
                        strokeWidth: 1,
                        fill: 'rgba(0, 0, 0, 0)',
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    }),
                    white: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: 'rgba(255, 255, 255, 1)',
                        strokeDashArray: [0, 5, 5, 0],
                        strokeWidth: 1,
                        fill: 'rgba(0, 0, 0, 0)',
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    })
                };
                this.getCanvas().getCotton().add(cottons.centers.top);
                this.getCanvas().getCotton().add(cottons.centers.right);
                this.getCanvas().getCotton().add(cottons.centers.bottom);
                this.getCanvas().getCotton().add(cottons.centers.left);
                this.getCanvas().getCotton().add(cottons.red);
                this.getCanvas().getCotton().add(cottons.white);
                this._outline = cottons;

                /** 
                 * resize
                 * 
                 * Moves the outline and center points to the relevant positions
                 * for a drawing.
                 * 
                 * @access private
                 * @return void
                 */
                var resize = function() {

                    // Reposition centers
                    this.setCoords();
                    var bounding = this.getBoundingRect();
                    cottons.centers.top.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top - 2
                    });
                    cottons.centers.right.set({
                        left: bounding.left + bounding.width - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });
                    cottons.centers.bottom.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top + bounding.height - 2
                    });
                    cottons.centers.left.set({
                        left: bounding.left - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });

                    // Reposition borders
                    cottons.red.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                    cottons.white.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                };
                this.on({
                    'refresh': function(event) {
                        resize.apply(this._cotton);
                    }
                });
                this._cotton.on({
                    'changed': resize.proxy(this._cotton),
                    'moving': resize.proxy(this._cotton),
                    'resize/outline': resize.proxy(this._cotton),
                    'rotating': resize.proxy(this._cotton),
                    'scaling': resize.proxy(this._cotton)
                });
                this._layer.on({
                    'refresh/dimensions': resize.proxy(this._cotton)
                });
                this._cotton.canvas.on({
                    'mouse:move': function() {
                        cottons.centers.top.set('visible', false);
                        cottons.centers.right.set('visible', false);
                        cottons.centers.bottom.set('visible', false);
                        cottons.centers.left.set('visible', false);
                        cottons.red.set('visible', false);
                        cottons.white.set('visible', false);
                    }
                });
                resize.apply(this._cotton);
            }
        },

        /**
         * autoAlign
         * 
         * Centers the drawing both vertically and horizontally in the canvas.
         * Then triggers the appropriate style changes in the Layer to ensure
         * it's properly saved.
         * 
         * @access public
         * @return void
         */
        autoAlign: function() {
            var backgroundRectangleLayer = Canvases.Preview.getBackgroundRectangleLayer(),
                boundingRect = backgroundRectangleLayer.getCotton().getBoundingRect(),
                middlePoint = {
                    x: boundingRect.width / 2,
                    y: boundingRect.height / 2
                };
            this._cotton.set({
                left: middlePoint.x,
                top: middlePoint.y
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    left: ((middlePoint.x * 100) / dimensions.width).round(4),
                    top: ((middlePoint.y * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
            Canvases.Preview.render();
        },

        /**
         * bb
         * 
         * Bounding box controls.
         * 
         * @todo!  Look into whether this is needed
         * @access public
         * @var    Object
         */
        bb: {

            /**
             * hide
             * 
             * @access public
             * @return void
             */
            hide: function() {
                this._cotton.hasBorders = false;
                this._cotton.hasControls = false;
                this._cotton.hasRotatingPoint = false;
                this._cotton.canvas.renderAll();
            },

            /**
             * show
             * 
             * @todo   Add custom rotate control
             * @see    http://stackoverflow.com/questions/23210961/how-can-i-change-the-rotation-icon-in-fabricjs/24533063#24533063
             * @access public
             * @return void
             */
            show: function() {
                this._cotton.hasBorders = true;
                this._cotton.hasControls = true;
                this._cotton.hasRotatingPoint = true;
                this._cotton.canvas.renderAll();
            }
        },

        /**
         * drawn
         * 
         * @access public
         * @return Boolean
         */
        drawn: function() {
            return this._drawn === true;
        },

        /**
         * getCanvas
         * 
         * @access public
         * @return CanvasView
         */
        getCanvas: function() {
            return this._layer.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access public
         * @return fabric.Object
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getLayer
         * 
         * @access public
         * @return Layer
         */
        getLayer: function() {
            return this._layer;
        },

        /**
         * getOutline
         * 
         * @access public
         * @return null|Object
         */
        getOutline: function() {
            return this._outline;
        },

        /**
         * highlight
         * 
         * @access public
         * @param  Object options
         * @return void
         */
        highlight: function(options) {
            if (this.magnets.highlight === true) {
                if (Account.highlightDrawingsOnSnap() === true) {
                    this._outline.red.setVisible(true);
                    this._outline.white.setVisible(true);
                    if (Account.highlightCenterGuidesOnSnap() === true) {
                        if (options.showHorizontalLineCenters === true) {
                            this._outline.centers.top.setVisible(true);
                            this._outline.centers.bottom.setVisible(true);
                        } else if (options.showVerticalLineCenters === true) {
                            this._outline.centers.right.setVisible(true);
                            this._outline.centers.left.setVisible(true);
                        }
                    }
                }
            }
        },

        /**
         * magnets
         * 
         * Wrapper object for magnet-related functions. Ensure that the proper
         * context is defined against functions called within this object.
         * 
         * @access public
         * @var    Function
         */
        magnets: function() {
            return {

                /**
                 * angles
                 * 
                 * Magnetizes a drawing to 45-degree angles so long as the
                 * canvas is not a Ghost (useless there).
                 * 
                 * @access protected
                 * @return void
                 */
                angles: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var threshold = this.magnets.thresholds.rotating;
                        this._cotton.snapToAngleOnRotate(
                            threshold.angle,
                            threshold.pixels
                        );
                    }
                },

                /**
                 * demagnetize
                 * 
                 * Demagnetizes a drawing by removing it from the array of
                 * drawings stored within the canvas fabric object.
                 * Demagnetizing prevents other drawings from snapping to it.
                 * 
                 * @access protected
                 * @return void
                 */
                demagnetize: function() {
                    var _this = this,
                        drawings = this._cotton.canvas.magnets.drawings;
                    jQuery.each(drawings, function(index, drawing) {
                        if (drawing === _this) {
                            drawings.splice(index, 1);
                        }
                    });
                },

                /**
                 * highlight
                 * 
                 * @access protected
                 * @var    Boolean (default: true)
                 */
                highlight: true,

                /**
                 * inbound
                 * 
                 * Ensures other drawings can be snapped to this one by adding
                 * the drawing to the array of drawings stored within the canvas
                 * fabric object. A check between the current and ghost canvas
                 * is made to ensure drawings that are temporary (eg. created
                 * during the ghost rendering process) are not added, since
                 * there's no point for those to be magnetized (and doing so
                 * causes issues since those drawings are never formally
                 * deleted, which results in drawings not available in the
                 * preview canvas being snapped to).
                 * 
                 * @access protected
                 * @return void
                 */
                inbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        this._setupOutline();
                        this._cotton.canvas.magnets.drawings.push(this);
                    }
                },

                /**
                 * outbound
                 * 
                 * Ensures the drawing can be snapped to other drawings by
                 * adding listeners on the fabric object. A check is made
                 * between the current ghost canvas to prevent adding the events
                 * when it's the ghost canvas being rendered. Not useful there.
                 * 
                 * @access protected
                 * @return void
                 */
                outbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var config = Stencil.get('config').defaults;
                        this._cotton.snapToDrawingsOnMove();
                        if (config.snapToDrawingsOnScale === true) {
                            this._cotton.snapToDrawingsOnScale();
                        }
                    }
                },

                /**
                 * thresholds
                 * 
                 * @note   Order here reflects how I visualize them in my head,
                 *         rather than alphabetically.
                 * @access protected
                 * @var    Object
                 */
                thresholds: {
                    moving: {
                        pixels: {
                            horizontal: {
                                centerToCenter: 6,
                                // centerToRight: 6,
                                // leftToCenter: 6,
                                leftToLeft: 6,
                                leftToRight: 6,
                                // rightToCenter: 6,
                                rightToLeft: 6,
                                rightToRight: 6
                            },
                            vertical: {
                                centerToCenter: 6,
                                // centerToTop: 6,
                                // centerToBottom: 6,
                                // topToCenter: 6,
                                topToTop: 6,
                                topToBottom: 6,
                                // bottomToCenter: 6,
                                bottomToTop: 6,
                                bottomToBottom: 6
                            }
                        }
                    },
                    rotating: {
                        angle: 45,
                        pixels: 5
                    },
                    scaling: {
                        pixels: 6
                    }
                }
            };
        },

        /**
         * relative
         * 
         * @access protected
         * @var    Function
         */
        relative: function() {
            return {

                /**
                 * left
                 * 
                 * @access public
                 * @return Number
                 */
                left: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('left').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                },

                /**
                 * top
                 * 
                 * @access public
                 * @return Number
                 */
                top: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('top').toFloat() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                },

                /**
                 * width
                 * 
                 * @access public
                 * @return Number
                 */
                width: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('width').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                }
            };
        },

        /**
         * select
         * 
         * @access public
         * @return void
         */
        select: function() {
            this.getCanvas().getCotton().setActiveObject(this._cotton);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * BackgroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.BackgroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundBitmapImageDrawing')
         */
        _string: 'BackgroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  BackgroundBitmapImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access protected
         * @return void
         */
        _addListeners: function() {
            this._addFiltersListeners();
            this._addMoveListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundBitmapImage');
                }
            });
        },

        /**
         * _getDefaults
         * 
         * @access protected
         * @return Object
         */
        _getDefaults: function() {
            var defaults = {
                hasBorders: false,
                hasControls: false,
                padding: 0
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getInvisibleImage
         * 
         * @access protected
         * @return String
         */
        _getInvisibleImage: function() {
            return (window.STATIC) + '/app/static/images/invisible.png';
        },

        /**
         * _getOptions
         * 
         * @access protected
         * @return Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    flipX: layer.getStyle('flipX') === true,
                    flipY: layer.getStyle('flipY') === true,
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getUrl
         * 
         * Attempts to load the image url for this layer, based on the image
         * property. If no image property defined (aka. false), or else it
         * points to a resource accessor that isn't in memory (can happen if
         * they switch to a resource, the image configuration gets saved, and
         * then they reload the page before the resource has been converted to
         * an asset), false is returned.
         * 
         * @access protected
         * @return false|String
         */
        _getUrl: function() {

            /**
             * No image defined in the layer, so send back false (which will
             * result in the empty image being drawn, and hidden).
             */
            var key = this._layer.getProperty('image');
            if (key === false) {
                return false;
            }

            /**
             * See Images.js for detailed documentation on the <getFrameUrl>
             * method. In short, it attempts to determine the ideal URL to use,
             * given the canvas' width / height.
             */
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                return Images.getFrameUrl(key, this.getCanvas());
            }

            /**
             * Not an asset or upload record; this ought to mean it's a
             * resource. Check if it's in memory. If it's not, then it's likely
             * an invalid pointer to a 3rd-party resource that for some reason
             * did not get converted to an asset.
             * 
             * Otherwise, send back the small version of the 3rd-party resource.
             */
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                return false;
            }
            return accessor.url('small');
        },

        /**
         * _loadInvisibleImage
         * 
         * Loads the backup invisible (1px by 1px) image, to be used when either
         * no image is set in the layer, or else one of the urls failed when
         * loading.
         * 
         * @access protected
         * @param  Function callback
         * @return void
         */
        _loadInvisibleImage: function(callback) {
            var preload = new Image();
            preload.crossOrigin = 'anonymous';
            preload.onload = function() {
                callback(this);
            };
            preload.onerror = function() {
                var code = 'bbi262',
                    reference = 'backgroundBitmapImage';
                Stencil.error(code, reference);
            };
            preload.src = this._getInvisibleImage();
        },

        /**
         * _loadImage
         * 
         * Attempts to load the image for this layer. If no image is explicitly
         * defined, callback is passed an image object, but with visible set to
         * false to ensure it's hidden.
         * 
         * @note   Cloudinary bails when half-pixel width / height values are
         *         passed in, so I always round up (<ceil> call). Not sure
         *         eactly how this affects scrubbing.
         * @access protected
         * @param  Function callback
         * @return void
         */
        _loadImage: function(callback) {

            /** 
             * Grab the url for the image to load. If no valid image found (can
             * happen when no image was selected, or else referencing an invalid
             * 3rd-party resource), then substitute the invisible image, and 
             * mark the image as not-visible.
             */
            var _this = this,
                key = this._layer.getProperty('image'),
                url = this._getUrl();

            // An image was found
            if (url !== false) {

                // Preload the image
                var preload = new Image();
                preload.crossOrigin = 'anonymous';
                preload.onload = function() {
                    var dimensions = _this.getCanvas().getRenderedDimensions(),
                        secondary;

                    /**
                     * If the layer's image is an asset or upload, attempts to
                     * load the proper dimensioned-version of it, at the exact
                     * desired width / height scale.
                     */
                    if (
                        key.match(/^asst/) !== null
                        || key.match(/^upld/) !== null
                    ) {
                        /**
                         * This is making use of Cloudinary's new API feature to
                         * dynamically resize to a minimum width or height
                         * depending on the aspect ratio of the original image
                         * (and by comparing that aspect ratio to the selected
                         * Frame).
                         * 
                         * If you need to revert, see the following commit:
                         * dacd90d55129ea8017bfe76abb58fbb6631ebc31
                         */
                        secondary = Images.getFrameUrl(key, _this.getCanvas());

                        // Load image, and pass it to the callback
                        preload = new Image();
                        preload.crossOrigin = 'anonymous';
                        preload.onload = function() {
                            callback({
                                image: this,
                                visible: true
                            });
                        };
                        preload.onerror = function() {
                            _this._loadInvisibleImage(function(image) {
                                callback({
                                    image: image,
                                    visible: false
                                });
                            });
                        };
                        preload.src = secondary;
                    }
                    /**
                     * Otherwise, the image must be a 3rd-party resource (eg.
                     * Pixabay). In that case, we load the small version of the
                     * resource (regardless of which dimension).
                     */
                    else {
                        var accessor = Stencil.getAccessor(key);
                        secondary = accessor.url('small');
                        preload = new Image();
                        preload.crossOrigin = 'anonymous';
                        preload.onload = function() {
                            callback({
                                image: this,
                                visible: true
                            });
                        };
                        preload.onerror = function() {
                            _this._loadInvisibleImage(function(image) {
                                callback({
                                    image: image,
                                    visible: false
                                });
                            });
                        };
                        preload.src = secondary;
                    }
                };
                preload.onerror = function() {
                    _this._loadInvisibleImage(function(image) {
                        callback({
                            image: image,
                            visible: false
                        });
                    });
                };
                preload.src = url;
            }
            // No image found
            else {
                this._loadInvisibleImage(function(image) {
                    callback({
                        image: image,
                        visible: false
                    });
                });
            }
        },

        /**
         * _resize
         * 
         * Notice that the resize event (and the property value) isn't triggered
         * until after the canvas itself has been rendered. This is to ensure
         * that any filters set against the image have been processed.
         * 
         * @see    https://i.imgur.com/eOpBX73.png
         * @access protected
         * @return void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            var _this = this;
            this._resizing = true;
            this._loadImage(function(response) {
                _this._cotton.setElement(
                    response.image,
                    function() {
                        _this._cotton.setCoords();
                        _this._scaleToFrame();
                        _this.getCanvas().once({
                            'render': function(event) {
                                _this._resizing = false;
                                _this.triggerHandler('resize/complete');
                            }
                        });
                        _this.getCanvas().render();
                    }
                );
            });
        },

        /**
         * _scaleToFrame
         * 
         * @access protected
         * @return void
         */
        _scaleToFrame: function() {
            var dimensions = this.getCanvas().getRenderedDimensions(),
                ratio = this._cotton.width / this._cotton.height;
            if (ratio > Frame.getRatio()) {
                this._cotton.scaleToHeight(dimensions.height);
            } else {
                this._cotton.scaleToWidth(dimensions.width);
            }
        },

        /**
         * draw
         * 
         * @access public
         * @return void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions();
            this._loadImage(function(response) {

                // Fabric basics
                var cotton = new fabric.Image(response.image);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;

                // Options (including visibility incase image removed)
                options.visible = response.visible;
                cotton.set(options);
                _this._scaleToFrame();

                // Filters
                _this._drawFilters();

                /**
                 * Note that while I add handlers like in other drawings, I do
                 * not call this.magnets.inbound, since the background rectangle
                 * view does the job of presenting an object that can have other
                 * layers snapped to it.
                 */
                _this._addListeners();
                cotton.makeSlidable();

                // Event dispatching
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * filters
         * 
         * Applies the filters registered against the fabric object to the image.
         * 
         * @access public
         * @return void
         */
        // filters: function() {
        //     var canvas = this.getCanvas(),
        //         callback = canvas.render.proxy(canvas);
        //     this._cotton.applyFilters(callback);
        // },

        /**
         * refresh
         * 
         * @see    Resizing: http://jsfiddle.net/7gvJG/70/
         * @access public
         * @return void
         */
        refresh: function() {
            this._scaleToFrame();
            this._getUrl() !== false && this._cotton.set({
                'visible': true
            });
            this._cotton.set({
                left: this.relative.left.apply(this),
                top: this.relative.top.apply(this)
            });
            this._scale();
            this._scaleToFrame();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * reload
         * 
         * This method has only one responsibility: to reload the image that is
         * set in the layer. To do so, it calls the helper _loadImage method,
         * and once the image has been loaded into memory, calls the
         * fabric-native setElement method.
         * 
         * It then calls refresh in order to have the image's width or height
         * scaled to the proper canvas-dimension, before scaling the image
         * itself (which itself calls the _resize method).
         * 
         * The issue with this flow is that it seems multiple calls to
         * _loadImage and setElement are made, since it's done below, and then
         * in the refresh method (via the _scale / _resize methods). Not sure
         * what's ideal here :/
         * 
         * @access public
         * @return void
         */
        reload: function() {
            var _this = this;
            this._loadImage(function(response) {
                _this._cotton.setElement(
                    response.image,
                    function() {
                        _this.refresh();
                    }
                );
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('RectangleDrawing', function() {

    /**
     * BackgroundRectangleDrawing
     * 
     * @extends RectangleDrawing
     */
    window.BackgroundRectangleDrawing = RectangleDrawing.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundRectangleDrawing')
         */
        _string: 'BackgroundRectangleDrawing',

        /**
         * init
         * 
         * @access public
         * @param  RectangleLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * toolbar.
         * 
         * @access protected
         * @return void
         */
        _addListeners: function() {
            this._addSelectListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundRectangle');
                }
            });
        },

        /**
         * _getDefaults
         * 
         * Note that although the Rectangle fabric drawing's bounding box cannot
         * be seen (because it's set to the exact dimensions of the canvas), it
         * is important for it's padding to be set to 0, otherwise layers snap
         * incorrectly when moving.
         * 
         * @access protected
         * @return Object
         */
        _getDefaults: function() {
            var defaults = {
                hasBorders: false,
                hasControls: false,
                hasRotatingPoint: false,
                hoverCursor: 'default',
                lockMovementX: true,
                lockMovementY: true,
                moveCursor: 'default',
                padding: 0,
                selectable: true
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getOptions
         * 
         * @access protected
         * @return Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    fill: layer.getStyle('backgroundColor'),
                    height: this.relative.height.apply(this),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * draw
         * 
         * @access public
         * @return void
         */
        draw: function() {
            var options = this._getOptions(),
                cotton = new fabric.Rect(options);
            this.getCanvas().getCotton().add(cotton);
            this._cotton = cotton;
            this.magnets.inbound.apply(this);
            this._addListeners();
            this._drawn = true;
            this.triggerHandler('draw', [this]);
            // this._cotton.on({
            //     'moving': function() {
            //         this.set({
            //             hoverCursor: 'default'
            //         });
            //     }
            // });
        },

        /**
         * highlight
         * 
         * Overwrites the Drawing::highlight method in order to use the Html
         * guides as the target for highlighting.
         * 
         * @access public
         * @param  Object options
         * @return void
         */
        highlight: function(options) {
            var $guides = App.getElement().find('div.guides'),
                $verticalGuide = $guides.find('div.vertical'),
                $horizontalGuide = $guides.find('div.horizontal')
            if (this.magnets.highlight === true) {
                if (Account.highlightDrawingsOnSnap() === true) {
                    if (Account.highlightCenterGuidesOnSnap() === true) {
                        if (options.showHorizontalLineCenters === true) {
                            $verticalGuide.removeClass('hidden');
                        } else if (options.showVerticalLineCenters === true) {
                            $horizontalGuide.removeClass('hidden');
                        }
                    }
                }
            }
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            var options = this._getOptions();
            this._cotton.set(options);
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * relative
         * 
         * @access public
         * @var    Object
         */
        relative: function() {
            return jQuery.extend(true, {}, this._super(), {
                /**
                 * height
                 * 
                 * @access public
                 * @return Number
                 */
                height: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('height').toInt() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                }
            })
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageDrawing', function() {

    /**
     * BitmapImageDrawing
     * 
     * @events  resize/start
     *          resize/complete
     *          applyFilters/complete
     *          applyFilters/start
     * @see     http://jsperf.com/lanczos-resampling
     * @see     https://www.viget.com/articles/instagram-style-filters-in-html5-canvas
     * @see     http://stackoverflow.com/questions/2303690/resizing-an-image-in-an-html5-canvas?lq=1
     * @extends ImageDrawing
     */
    window.BitmapImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @see    http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access protected
         * @var    Object
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'filters': function() {
                    this._layer.on({
                        'filter/add': function(event, obj) {
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                type = obj.type,
                                properties = obj.properties || {},
                                filter;
                            filter = drawing._filter[type].apply(this, [properties]);
                            filter.set('_stencilType', type);
                            cotton.filters.push(filter);
                            this.getCanvas().render();
                        },
                        'filter/remove': function(event, obj) {
                            var cotton = this.getCotton(),
                                filters = cotton.filters || [];
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].get('_stencilType') === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.getCanvas().render();
                        },
                        'filter/update': function(event, obj) {
                            var cotton = this.getCotton(),
                                rawFilters = cotton.get('filters'),
                                index, rawFilter;
                            for (index in rawFilters) {
                                rawFilter = rawFilters[index];
                                if (rawFilter.get('_stencilType') === obj.type) {
                                    if (obj.type === 'blur') {
                                        var radius = obj.properties.strength / 3,
                                            dimensions = this.getCanvas().getRenderedDimensions();
                                        radius *= dimensions.width;
                                        radius /= 365;
                                        radius = radius.round(0);
                                        rawFilter.options.args = [radius];
                                    } else if (obj.type === 'colorOverlay') {
                                        // StencilBooter.log(JSON.stringify(obj));
                                        rawFilter.color = obj.properties.color;
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'darken') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'lighten') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'opacity') {
                                        rawFilter.opacity = (100 - obj.properties.strength) / 100;
                                    }
                                }
                            }
                            this.getCanvas().render();
                        },
                    });
                }//,
                // 'colorOverlay': function() {
                //     this._layer.on({
                //         'change/colorOverlay': function(event, colorOverlay) {
                //             // var drawing = this._drawing,
                //             //     cotton = drawing.getCotton();
                //             // drawing.refreshStroke();
                //             // drawing.refreshShadow();
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         },
                //         'clear/colorOverlay': function(event) {
                //             // var drawing = this._drawing,
                //             //     cotton = this.getCotton();
                //             // drawing.refreshShadow();
                //             // cotton.setStroke(null);
                //             // cotton.setStrokeWidth(0);
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         }
                //     });
                // }
            });
        },

        /**
         * _resizing
         * 
         * @access protected
         * @var    false|Boolean (default: false)
         */
        _resizing: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BitmapImageDrawing')
         */
        _string: 'BitmapImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  BitmapImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addFiltersListeners
         * 
         * @access protected
         * @return void
         */
        _addFiltersListeners: function() {
            var _this = this;
            this.on({
                'resize/start': function() {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key) || 0;
                    Stencil.set(key, bitmapImageResizings);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings++;
                        Stencil.set(key, bitmapImageResizings);
                        var content = App.getStage().getContent();
                        content.interaction.block.apply(content);
                    }
                },
                'resize/complete': function() {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings--;
                        Stencil.set(key, bitmapImageResizings);
                        if (bitmapImageResizings === 0) {
                            var content = App.getStage().getContent();
                            content.interaction.unblock.apply(content);
                        }
                    }
                }
            });
            this._cotton.on({
                'applyFilters/complete': function() {
                    _this.triggerHandler('applyFilters/complete');
                },
                'applyFilters/start': function() {
                    _this.triggerHandler('applyFilters/start');
                }
            });
        },

        /**
         * _addListeners
         * 
         * @access protected
         * @return void
         */
        _addListeners: function() {
            this._super();
            this._addFiltersListeners();
        },

        /**
         * _drawFilters
         * 
         * @note   A check is made against the _filter object to ensure the
         *         filter-by-type is actually defined as a method, to prevent
         *         legacy images that used filters that are not supported (eg.
         *         colorsize) from breaking things.
         * @access protected
         * @return void
         */
        _drawFilters: function() {
            var _this = this,
                filters = this._layer.getProperty('filters'),
                filter,
                cotton = this._cotton,
                properties;
            jQuery.each(filters, function(index, obj) {
                if (_this._filter[obj.type] !== undefined) {
                    properties = obj.properties || {};
                    filter = _this._filter[obj.type].apply(_this, [properties]);
                    filter.set('_stencilType', obj.type);
                    cotton.filters.push(filter);
                    _this._layer.set({'renderFilters': true});
                }
            });
        },

        /**
         * _filter
         * 
         * @access protected
         * @var    Object
         */
        _filter: {
            _1977: function(properties) {
                return new fabric.Image.filters.Caman('1977');
            },
            blur: function(properties) {
                var radius = 5;
                if (typeof properties.strength !== 'undefined') {
                    radius = properties.strength / 3;
                }
                var dimensions = this.getCanvas().getRenderedDimensions();
                radius *= dimensions.width;
                radius /= 365;
                return new fabric.Image.filters.Caman(
                    'stackBlur',
                    {
                        args: [
                            radius.round(0)
                        ]
                    }
                );
            },
            brannan: function(properties) {
                return new fabric.Image.filters.Caman('brannan');
            },
            bw: function() {
                return new fabric.Image.filters.Grayscale();
            },
            clarity: function(properties) {
                return new fabric.Image.filters.Caman('clarity');
            },
            colorOverlay: function(properties) {
                var color = 'rgba(0, 0, 0, 1)',
                    strength = 0.5;
                if (typeof properties.color !== 'undefined') {
                    color = properties.color;
                }
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: color,
                    opacity: strength
                });
            },
            // concentrate: function(properties) {
            //     return new fabric.Image.filters.Caman('concentrate');
            // },
            // crossProcess: function(properties) {
            //     return new fabric.Image.filters.Caman('crossProcess');
            // },
            darken: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#000000',
                    opacity: strength
                });
            },
            // glowingSun: function(properties) {
            //     return new fabric.Image.filters.Caman('glowingSun');
            // },
            gotham: function(properties) {
                return new fabric.Image.filters.Caman('gotham');
            },
            // grungy: function(properties) {
            //     return new fabric.Image.filters.Caman('grungy');
            // },
            // hazyDays: function(properties) {
            //     return new fabric.Image.filters.Caman('hazyDays');
            // },
            hefe: function(properties) {
                return new fabric.Image.filters.Caman('hefe');
            },
            // hemingway: function(properties) {
            //     return new fabric.Image.filters.Caman('hemingway');
            // },
            // herMajesty: function(properties) {
            //     return new fabric.Image.filters.Caman('herMajesty');
            // },
            // jarques: function(properties) {
            //     return new fabric.Image.filters.Caman('jarques');
            // },
            lighten: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#ffffff',
                    opacity: strength
                });
            },
            lomo: function(properties) {
                return new fabric.Image.filters.Caman('lomo');
            },
            lordKelvin: function(properties) {
                return new fabric.Image.filters.Caman('lordKelvin');
            },
            // love: function(properties) {
            //     return new fabric.Image.filters.Caman('love');
            // },
            // oldBoot: function(properties) {
            //     return new fabric.Image.filters.Caman('oldBoot');
            // },
            opacity: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = (100 - properties.strength) / 100;
                }
                return new fabric.Image.filters.Fade({
                    // drawing: this,
                    opacity: strength
                });
            },
            // orangePeel: function(properties) {
            //     return new fabric.Image.filters.Caman('orangePeel');
            // },
            // pinhole: function(properties) {
            //     return new fabric.Image.filters.Caman('pinhole');
            // },
            nashville: function(properties) {
                return new fabric.Image.filters.Caman('nashville');
            },
            // nostalgia: function(properties) {
            //     return new fabric.Image.filters.Caman('nostalgia');
            // },
            sepia: function() {
                // return new fabric.Image.filters.Sepia();
                // return new fabric.Image.filters.Sepia2();
                return new fabric.Image.filters.Caman('sepia');
            },
            sinCity: function(properties) {
                return new fabric.Image.filters.Caman('sinCity');
            },
            sunrise: function(properties) {
                return new fabric.Image.filters.Caman('sunrise');
            },
            vintage: function(properties) {
                return new fabric.Image.filters.Caman('vintage');
            },
            xPro: function(properties) {
                return new fabric.Image.filters.Caman('xPro');
            }
        },

        /**
         * _getOptions
         * 
         * @access protected
         * @return Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _resize
         * 
         * Loads in a resized version of the image, relative to the width value
         * for the layer. Note that since this is the parent-class for various
         * ImageLayer types, not all require a width-parameter to be sent to the
         * _getUrl method. Those that do not need it (at the moment,
         * VectorImageLayer since a width is not needed for resample there, and
         * BackgroundBitmapImageLayer, as the width is automatically determined
         * based on the Frame and preview-canvas sizing), simply ignore it.
         * 
         * @access protected
         * @return void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            this._resizing = true;
            var _this = this,
                cotton = this._cotton,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            this._cotton.setSrc(
                url,
                function() {
                    cotton.setCoords();
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();
                    layer.getCanvas().render();
                    _this._resizing = false;
                    _this.triggerHandler('resize/complete');
                },
                {
                    crossOrigin: 'anonymous'
                }
            );
        },

        /**
         * _scale
         * 
         * This is a helper method to facilitate some race-conditions that were
         * going on. This logic is also employed in BackgroundBitmapImageLayer
         * layers. The race-condition was that when the user resized the browser
         * too fast, it was possible for multiple resize-flows to happen. When
         * that was the case, sometimes the first resize-flow would be slow in
         * loading the new-sized image asset (done via the setSrc method below).
         * This would sometimes result in the wrong image being rendered after
         * the user let go of their mouse, simply because the second-resize-flow
         * would return faster than the first. This would be common if the
         * second-resize dimensions pointed to an image that was already in
         * cache.
         * 
         * So the logic here is intended to force the application to wait until
         * a resize has happened before initiating a new one. It's essentially
         * chaining them. While this isn't ideal for memory, it's suitable for
         * now.
         * 
         * Hypothetically, a more performative flow would be to cancel the
         * initial resize (if one is going on), and start with this new one.
         * 
         * It's also worth noting that with this logic, it's possible to
         * reproduce a janky experience whereby if the user resizes their window
         * fast-enough, images can shift between the wrong and right dimensions.
         * This is again because of race-conditions. The above
         * hypothetical-approach would address this.
         * 
         * @access protected
         * @return void
         */
        _scale: function() {
            this._resizing !== true ? this._resize() : this.once({
                'resize/complete': this._resize.proxy(this)
            });
        },

        /**
         * refresh
         * 
         * Resizes position properties of the layer relative to the new canvas
         * size (which comes into play via the _getOptions method).
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaledWidth = this._getScaledWidth();
            cotton.scaleToWidth(scaledWidth);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this._scale();
            cotton.scaleToWidth(scaledWidth);
            this.triggerHandler('refresh', [this]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * ForegroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.ForegroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ForegroundBitmapImageDrawing')
         */
        _string: 'ForegroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  ForegroundBitmapImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addScaleListeners
         * 
         * @access protected
         * @return void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Stencil.getResizeDelay('foregroundBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('foregroundBitmapImage');
                }
            });
        },

        /**
         * _getUrl
         * 
         * @access protected
         * @param  Number width
         * @return String
         */
        _getUrl: function(width) {
            var ratio = window.devicePixelRatio || 1,
                key = this._layer.getProperty('image');
            width *= ratio;
            if (
                Stencil.get('config').defaults.roundCloudinaryRequests === true
                && this.getCanvas() !== Canvases.Ghost
            ) {
                return Images.cloudinary(key, {
                    type: 'scale',
                    width: width.round(0).roundToNext10()
                });
            }
            return Images.cloudinary(key, {
                type: 'scale',
                width: width.round(0)
            });
        },

        /**
         * draw
         * 
         * @access public
         * @return void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    /**
                     * Options
                     * 
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * ImageDrawing
     * 
     * @extends Drawing
     */
    window.ImageDrawing = Drawing.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageDrawing')
         */
        _string: 'ImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  ImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access protected
         * @return void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addScaleListeners
         * 
         * This is a complicated beast. Scaling a VectorImageDrawing affects the
         * positioning (left/right), flip properties (since it can be stretched
         * beyond/above/below an axis/fold) and scale properties. The below
         * logic interprets scaling, and finds the lowest scale value for the
         * x/y axis. I do this to ensure I get _some_ width value stored in the
         * layer. I then normalize the stretch and width values relative to that
         * scaling value. The width and left/top styles are then normalized
         * relative to the canvas dimensions.
         * 
         * @access protected
         * @return void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {

                    // Dimensions
                    var scaleX = this.scaleX,
                        scaleY = this.scaleY,
                        flipX = this.flipX,
                        flipY = this.flipY,
                        factor = Math.min(scaleX, scaleY),
                        width = (this.width * factor).round(4),
                        stretchX = (scaleX / factor).round(4),
                        stretchY = (scaleY / factor).round(4);

                    // Adjust width to be relative
                    var current = _this.getCanvas().getRenderedDimensions();
                    width = ((width / current.width) * 100).round(4);

                    // Adjust left/right to be relative
                    var left = ((this.left / current.width) * 100).round(4),
                        top = ((this.top / current.height) * 100).round(4);
                    // width = (current.width * percentage).round(4);

                    // Done
                    var dimensions = {
                        left: left,
                        top: top,
                        width: width,
                        stretchX: stretchX,
                        stretchY: stretchY,
                        flipX: flipX,
                        flipY: flipY
                    };
                    _this._layer.triggerHandler('change/dimensions', [dimensions]);
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _getScaledWidth
         * 
         * This function returns the adjusted width for the cotton object,
         * taking into consideration the size of the bounding rectangle. Most of
         * the time, nothing is actually changed, since the bounding rectangle
         * and the cotton object width are the same. But on tablets, for
         * example, it is different, since padding is added to layers. Because
         * of this, the bounding rectangle dimensions are increased.
         * 
         * A funny gotcha is that when the cotton object is initially drawn (in
         * the draw method), regardless of whether there is padding defined,
         * the bounding rectangle dimensions match that of the cotton object
         * itself. I believe this is because the canvas hasn't been rendered
         * (via the renderAll method against the canvas cotton object). So while
         * I'm calling this helper-method from within the draw logic, it is
         * irrelevant (at least right now). This may change later depending on
         * the flow I do for rendering cotton objects, or else for some other
         * unforeseen reason.
         * 
         * @access protected
         * @return Number
         */
        _getScaledWidth: function() {
            var options = this._getOptions(),
                width = options.width,
                cotton = this._cotton,
                boundingRectFactor = cotton.getBoundingRect().width / cotton.getWidth();
            return (width * boundingRectFactor).round(4);
        },

        /**
         * animate
         * 
         * @note   There's a bug here with some icons (VectorImage drawings),
         *         whereby if it's made up of many paths, some of them might not
         *         animate. This can be seen with this icon:
         *         https://i.imgur.com/sOPbC4d.png
         *         It's really subtle, but it's there.
         * @access public
         * @return void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', 1, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * RectangleDrawing
     * 
     * @extends Drawing
     */
    window.RectangleDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Object
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'backgroundColor': function() {
                    this._layer.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            var cotton = this.getCotton();
                            cotton.setColor(backgroundColor);
                            this.getCanvas().render();
                        },
                        'clear/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                white = 'rgba(0, 0, 0, 0)';
                            cotton.setColor(white);
                            this.getCanvas().render();
                        },
                        'reset/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                white = 'rgba(255, 255, 255, 1)';
                            cotton.setColor(white);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'RectangleDrawing')
         */
        _string: 'RectangleDrawing',

        /**
         * init
         * 
         * @access public
         * @param  RectangleLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * TextDrawing
     * 
     * @fires   draw
     *          refresh
     *          preview/fontFamily
     * @extends Drawing
     */
    window.TextDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'align': function() {
                    this._layer.on({
                        'change/align': function(event, position) {
                            var cotton = this.getCotton();
                            cotton.setTextAlign(position);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'backdropColor': function() {
                    this._layer.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var cotton = this.getCotton(),
                                backdropStretch = this.getStyle('backdropStretch');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            var cotton = this.getCotton(),
                                backdropColor = this.getStyle('backdropColor');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/backdropColor': function(event) {
                            var cotton = this.getCotton();
                            cotton.clearBackdrop();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                    });
                },
                'bold': function() {
                    this._layer.on({
                        'change/bold': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var weight = 'normal';
                                if (on === true) {
                                    weight = 'bold';
                                }
                                cotton.setFontWeight(weight);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/bold': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontWeight('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'shadowStrength': function() {
                    this._layer.on({
                        'change/shadowStrength': function(event, shadowStrength) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontFamily': function() {
                    this._layer.on({

                        /**
                         * (anonymous)
                         * 
                         * @access private
                         * @param  Object event
                         * @param  FontAccessor font
                         * @return void
                         */
                        'change/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName'),
                                cotton = this.getCotton();
                            cotton.setFontFamily(fontFamily);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access private
                         * @param  Object event
                         * @param  FontAccessor font
                         * @return void
                         */
                        'preview/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName');
                            this._cotton.setFontFamily(fontFamily);
                            // this._cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontSize': function() {
                    this._layer.on({
                        'change/fontSize': function(event, fontSize) {
                            var drawing = this._drawing,
                                size = drawing.relative.fontSize.apply(drawing),
                                cotton = drawing.getCotton();
                            cotton.setFontSize(size);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'italic': function() {
                    this._layer.on({
                        'change/italic': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var style = 'normal';
                                if (on === true) {
                                    style = 'italic';
                                }
                                cotton.setFontStyle(style);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/italic': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontStyle('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'lineHeight': function() {
                    this._layer.on({
                        'change/lineHeight': function(event, lineHeight) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setLineHeight(lineHeight);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'strokeColor': function() {
                    this._layer.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/strokeColor': function(event) {
                            var drawing = this._drawing,
                                cotton = this.getCotton();
                            drawing.refreshShadow();
                            cotton.setStroke(null);
                            cotton.setStrokeWidth(0);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'textColor': function() {
                    this._layer.on({
                        'change/textColor': function(event, textColor) {
                            var cotton = this.getCotton();
                            cotton.setColor(textColor);
                            this._drawing.refreshShadow();
                            this.getCanvas().render();
                        }
                    });
                },
                'underline': function() {
                    this._layer.on({
                        'change/underline': function(event, on) {
                            var decoration = '',
                                drawing = this._drawing,
                                cotton = drawing.getCotton();
                            if (on === true) {
                                decoration = 'underline';
                            }
                            cotton.setTextDecoration(decoration);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TextDrawing')
         */
        _string: 'TextDrawing',

        /**
         * init
         * 
         * @access public
         * @param  TextLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * text toolbar.
         * 
         * @access protected
         * @return void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
            this._addTextChangeListeners();
        },

        /**
         * _addScaleListeners
         * 
         * @access protected
         * @return void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {
                    _this._layer.triggerHandler(
                        'change/dimensions',
                        [_this.getDimensions()]
                    );
                    _this._layer.setChangeOperationType('scaled');
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('text');
                }
            });
        },

//         /**
//          * _addSelectListeners
//          * 
//          * So this was something I was playing with on January 5th, 2016, to
//          * make selecting a layer smarter. It was attempting to do the
//          * following:
//          * When an object was selected, check if there are any other layers
//          * that have an exact pixel of the object clicked (hence the usage of
//          * the <isTargetTransparent> method). The <containsPoint> might not
//          * be required? Hmm. Not sure. When a pixel was found, I waited 0
//          * milliseconds, and switched to that one. Noticed the bounding box
//          * appeared for a moment, so this may not be the most elegant
//          * solution. Don't delete this code, since I'll probably want to come
//          * back to it post-launch.
//          * 
//          * @see https://github.com/kangax/fabric.js/issues/601
//          * @see https://github.com/kangax/fabric.js/issues/28
//          * @see http://stackoverflow.com/questions/19033989/fabric-js-containspoint-function-to-find-if-the-point-is-inside-the-actual-conte
//          * @see https://groups.google.com/forum/#!topic/fabricjs/OhMkv6Mmpgo
//          * @access protected
//          * @return void
//          */
//         _addSelectListeners: function() {
//             var _this = this;
//             this._cotton.on({
//                 'selected': function(options) {
//                     var layers = [];
//                     if (options.e !== undefined) {
// StencilBooter.log(_this._layer);
//                         var point = new fabric.Point(
//                             options.e.layerX,
//                             options.e.layerY
//                         );
//                         layers = Canvases.Preview.getImageDocument().filter(
//                             function(index, layer) {
//                                 var cotton = layer.getCotton();
//                                 return layer.getStyle('order').toInt() !== 0
//                                     && layer !== _this._layer
//                                     && cotton.containsPoint(point) === true
//                                     && Canvases.Preview.getCotton().isTargetTransparent(
//                                         cotton,
//                                         options.e.layerX,
//                                         options.e.layerY
//                                     ) === false;
//                             }
//                         );
//                     }
// StencilBooter.log(layers);
//                     if (layers.length === 0) {
//                         Canvases.Preview.setSelectedLayer(_this._layer);
//                         _this.bb.show.apply(_this);
//                         Toolbars.text.show();
//                         Toolbars.vectorImage.hide();
//                         Toolbars.watermarkBitmapImage.hide();
//                     } else {
//                         var layer = layers[0],
//                             _fabric = layer.getCotton();
// // StencilBooter.log(layer, _fabric);
//                         setTimeout(function() {
//                             Canvases.Preview.setSelectedLayer(layer);
//                             Canvases.Preview.getCotton().setActiveObject(_fabric);
//                         }, 0);
//                     }
//                 }
//             });
//         },

        /**
         * _addTextChangeListeners
         * 
         * @access protected
         * @return void
         */
        _addTextChangeListeners: function() {
            var _this = this;
            this._cotton.on({
                'changed': function(event) {
                    var text = this.getText();
                    _this._layer.triggerHandler('change/text', [text]);
                }
            });
        },

        /**
         * _getBackdropPaddingFactor
         * 
         * @access protected
         * @return Number
         */
        _getBackdropPaddingFactor: function() {
            var backdropPaddingFactor = this._layer.getStyle(
                'backdropPaddingFactor'
            );
            if (backdropPaddingFactor === undefined) {
                return Stencil.get('config').defaults.backdropPaddingFactor.toFloat();
            }
            return backdropPaddingFactor.toFloat();
        },

        /**
         * _getDefaults
         * 
         * @access protected
         * @return Object
         */
        _getDefaults: function() {
            var defaults = {
                // stencilCursorColorLeft: 'rgba(255, 255, 255, 1)',
                // stencilCursorColorRight: 'rgba(255, 255, 255, 1)',
                cursorColor: 'rgba(0, 0, 0, 1)',
                cursorDelay: 1000,
                cursorDuration: 200,
                cursorWidth: 1,
                editingBorderColor: 'rgba(0, 0, 0, 0.25)',
                strokeLineCap: 'round',
                strokeLineJoin: 'round'
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getOptions
         * 
         * @access protected
         * @return Object
         */
        _getOptions: function() {

            // Formatting
            var layer = this._layer,
                fontWeight = 'normal',
                fontStyle = 'normal',
                textDecoration = '';
            if (layer.getStyle('bold') === true) {
                fontWeight = 'bold';
            }
            if (layer.getStyle('italic') === true) {
                fontStyle = 'italic';
            }
            if (layer.getStyle('underline') === true) {
                textDecoration = 'underline';
            }

            // Options
            var custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    backdropPaddingFactor: this._getBackdropPaddingFactor(),
                    fill: layer.getStyle('textColor'),
                    fontFamily: layer.getStyle('fontFamily'),
                    fontSize: this.relative.fontSize.apply(this),
                    fontStyle: fontStyle,
                    fontWeight: fontWeight,
                    left: this.relative.left.apply(this),
                    lineHeight: layer.getStyle('lineHeight').toFloat(),
                    shadow: this.relative.shadow.apply(this),
                    textAlign: layer.getStyle('align'),
                    top: this.relative.top.apply(this),
                    textDecoration: textDecoration,
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getStrokeWidth
         * 
         * Since the fontSize style is relative to the canvas width, I only need
         * to multiply the number by an arbitrary constant to get a good looking
         * stroke across the board.
         * 
         * @access protected
         * @return Number
         */
        _getStrokeWidth: function() {
            var size = this.relative.fontSize.apply(this),
            // var size = this._cotton.get('fontSize'),
                strokeWidthDividingFactor = this._getStrokeWidthDividingFactor();
            return (size * strokeWidthDividingFactor).round(4);
        },

        /**
         * _getStrokeWidthDividingFactor
         * 
         * @access protected
         * @return Number
         */
        _getStrokeWidthDividingFactor: function() {
            var strokeWidthDividingFactor = this._layer.getStyle(
                'strokeWidthDividingFactor'
            );
            if (strokeWidthDividingFactor === undefined) {
                return Stencil.get('config').defaults.strokeWidthDividingFactor.toFloat();
            }
            return strokeWidthDividingFactor.toFloat();
        },

        /**
         * _reposition
         * 
         * Changes the left and top style values for the text layer, as well as
         * the drawn cotton-position styles, to be in sync with how positioning
         * worked with Share As Image.
         * 
         * @access protected
         * @return void
         */
        _reposition: function() {

            // Left
            if (this._layer.getStyle('repositionLeft') === true) {
                this._layer.setStyle('repositionLeft', false);

                // UI
                var width = Math.min(this._cotton.width, this._cotton._getTextWidth() * 1.05),
                    left = this._cotton.left + width / 2;
                this._cotton.set({
                    width: width,
                    left: left
                });
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = {
                        width: ((width * 100) / dimensions.width).round(4),
                        left: ((left * 100) / dimensions.width).round(4)
                    };
                this._layer.setStyles(relative);
            }
            // Top
            if (this._layer.getStyle('repositionTop') === true) {
                this._layer.setStyle('repositionTop', false);

                // UI
                var height = this._cotton._getTextHeight(),
                    top = this._cotton.top + height / 2;
                this._cotton.set({top: top});
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = (top * 100) / dimensions.height;
                this._layer.setStyle('top', relative.round(4));
            }
        },

        /**
         * _setStroke
         * 
         * @access protected
         * @param  String strokeColor
         * @return void
         */
        _setStroke: function(strokeColor) {
            var strokeWidth = this._getStrokeWidth();
            this._cotton.setStrokeWidth(strokeWidth);
            this._cotton.setStroke(strokeColor);
        },

        /**
         * animate
         * 
         * @access public
         * @return void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', 1, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
            if (this._layer.getStyle('backdropColor') !== false) {
                var backdrop = this._cotton.get('backdrop');
                top = backdrop.get('top');
                backdrop.animate('top', top, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: top - 50,
                    onChange: cotton.renderAll.bind(cotton)
                });
                backdrop.animate('opacity', 1, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: 0.3,
                    onChange: cotton.renderAll.bind(cotton)
                });
            }
        },

        /**
         * draw
         * 
         * Controls visibility is explicitly set here to restrict manipulation
         * to width and rotation.
         * 
         * @access public
         * @return void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                text = layer.getProperty('text'),
                fontFamily = layer.getStyle('fontFamily');

            // Fallback to default if font is no longer available
            var fontsCollection = Stencil.account().collection('fonts'),
                font = fontsCollection.findByFamilyName(fontFamily),
                // appDefaultFontFamily = Stencil.get('config').defaults.font;
                appDefaultFontFamily = Stencil.account().setting('defaultFontFamily');
            if (font === false) {
                font = fontsCollection.findByFamilyName(appDefaultFontFamily);
                layer.setStyle('fontFamily', appDefaultFontFamily);
            }

            // Let's do this!
            var options = this._getOptions();
            font.loadFull(function() {

                // Fabric basics
                var cotton = new fabric.Textbox(text, options);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;
                _this._cotton.originalPadding = options.padding;

                // Controls
                cotton.setControlsVisibility({
                    ml: true,
                    mr: true,
                    mtr: true
                });

                // Events
                _this._addListeners();
                _this.magnets.angles.apply(_this);
                _this.magnets.outbound.apply(_this);
                cotton.boxIn(_this._boxInRatio);
                _this.magnets.inbound.apply(_this);

                /**
                 * Reposition the image if it's from Share As Image and was
                 * normalized.
                 */
                if (
                    layer.getStyle('repositionLeft') === true
                    || layer.getStyle('repositionTop') === true
                ) {
                    _this._reposition();
                }

                /**
                 * Stroke
                 * 
                 * This should be before the backdrop addition, since the stroke
                 * often affects the dimensions of the bounding box. Ran into
                 * this issue in Firefox when the order was reversed. Notice the
                 * spacing around the backdrop:
                 * https://i.imgur.com/KzHpKxe.png
                 * 
                 */
                _this.refreshStroke();
                _this.refreshShadow();

                // Backdrop
                var backdropColor = layer.getStyle('backdropColor');
                if (backdropColor !== false) {
                    var backdropStretch = layer.getStyle('backdropStretch');
                    cotton.addBackdrop(backdropColor, backdropStretch);
                }

                // Done drawing; trigger event
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * getDimensions
         * 
         * @access public
         * @return Object
         */
        getDimensions: function() {
            var current = this.getCanvas().getRenderedDimensions(),
                left = ((this._cotton.left / current.width) * 100).round(4),
                top = ((this._cotton.top / current.height) * 100).round(4);
            return {
                left: left,
                top: top,
                width: (this._cotton.getRelativeWidth() * 100).round(4)
            };
        },

        /**
         * refresh
         * 
         * At the moment, refresh is only used on window resizing. When this
         * happens, the canvas dimensions may change. To accommodate for this,
         * only styles that are defined relative to the canvas size need to be
         * refreshed. These include:
         * - fontSize
         * - left
         * - top
         * - width
         * 
         * Additionally, the backdrop needs to be updated, so if one is defined
         * I manually call the position method.
         * 
         * Finally, I refresh the stroke since it's affected by the font size
         * applied to the layer, which may have been affected in the canvas
         * refresh.
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            var layer = this._layer,
                options = this._getOptions();
            this._cotton.set({
                fontSize: options.fontSize,
                left: options.left,
                top: options.top,
                shadow: options.shadow,
                width: options.width
            });

            // Refresh stroke (since font size may have changed)
            this.refreshStroke();
            this.refreshShadow();

            // Backdrop
            var backdropColor = layer.getStyle('backdropColor');
            if (backdropColor !== false) {
                this._cotton.positionBackdrop();
            }

            // Done
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * refreshShadow
         * 
         * @access public
         * @return void
         */
        refreshShadow: function() {
            var shadow = this.relative.shadow.apply(this);
            this._cotton.setShadow(shadow);
        },

        /**
         * refreshStroke
         * 
         * Helper method that sets the stroke on the cotton-object. Note that
         * although this method is only called from within this file, it is
         * public because some places where it's called, it's being done so
         * where the context is a different object (specifically, a TextLayer
         * instance).
         * 
         * @access public
         * @return void
         */
        refreshStroke: function() {
            var strokeColor = this._layer.getStyle('strokeColor');
            if (strokeColor !== false) {
                this._setStroke(strokeColor);
            }
        },

        /**
         * relative
         * 
         * @access public
         * @var    Object
         */
        relative: function() {
            return jQuery.extend(true, {}, this._super(), {

                /**
                 * fontSize
                 * 
                 * This calculation method works differently than others, since the
                 * fontSize is on a scale of 20 to 400, rather than a percentage or
                 * decimal value. So I determine the ratio of the canvas width to
                 * the frame, and determine the appropriate font size.
                 * 
                 * @access public
                 * @return Number
                 */
                fontSize: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        fontSize = this._layer.getStyle('fontSize').toFloat();
                    return (fontSize / 100 / 10) * dimensions.width;
                },

                /**
                 * shadow
                 * 
                 * @access public
                 * @return String
                 */
                shadow: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        textColor = this._layer.getStyle('textColor'),
                        strokeColor = this._layer.getStyle('strokeColor'),
                        shadow = {
                            offsetX: this._layer.getStyle('shadowOffsetX') || 4,
                            offsetY: this._layer.getStyle('shadowOffsetY') || 4,
                            blur: this._layer.getStyle('shadowBlur') || 10,
                            color: this._layer.getStyle('shadowColor') || this._getContrastingColor(textColor),
                            strength: this._layer.getStyle('shadowStrength') === undefined ? 0 : this._layer.getStyle('shadowStrength')
                        };
                    if (strokeColor !== false) {
                        shadow.color = this._getContrastingColor(strokeColor);
                    }
                    shadow.strength /= 100
                    shadow.color = shadow.color.replace('rgb', 'rgba');
                    shadow.color = shadow.color.replace(')', ', ' + (shadow.strength) + ')');
                    var factor = (1 / 100 / 2) * this.relative.fontSize.apply(this);// * window.devicePixelRatio,
                        strokePadding = 0;
                    if (strokeColor !== false) {
                        strokePadding = this._getStrokeWidth() * 0.5;
                    }
                    shadow.offsetX = (shadow.offsetX * factor);
                    shadow.offsetY = (shadow.offsetY * factor);
                    shadow.blur = (shadow.blur * factor).round(0);
                    var offsetX = ((shadow.offsetX + strokePadding) * (window.devicePixelRatio)).round(0),
                        offsetY = ((shadow.offsetY + strokePadding) * (window.devicePixelRatio)).round(0),
                        blur = (shadow.blur),
                        color = shadow.color,
                        properties = [
                            (offsetX) + 'px',
                            (offsetY) + 'px',
                            (blur) + 'px',
                            color
                        ];
                    return properties.join(' ');
                }
            });
        },

        /**
         * repositionRelativeTo
         * 
         * Used with quotes to position a drawing directly below another
         * drawing.
         * 
         * @access public
         * @param  Drawing drawing
         * @return void
         */
        repositionRelativeTo: function(drawing) {
            var rect = drawing.getCotton().getBoundingRect(),
                buffer = 4,
                adjusted = (rect.top + rect.height + this._cotton.getBoundingRect().height / 2) * ((100 + buffer) / 100);
            this._cotton.set({
                top: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    top: ((adjusted * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
        },

        /**
         * trim
         * 
         * @access public
         * @return void
         */
        trim: function() {
            var width = this._cotton._getTextWidth(),
                buffer = 30,
                adjusted = width * ((100 + buffer) / 100);
            this._cotton.set({
                width: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    width: ((adjusted * 100) / dimensions.width).round(4)
                };
            this._layer.setStyles(relative);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageDrawing', function() {

    /**
     * VectorImageDrawing
     * 
     * @extends ImageDrawing
     */
    window.VectorImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'fillColor': function() {
                    this._layer.on({
                        'change/fillColor': function(event, fillColor) {
                            var cotton = this.getCotton();
                            cotton.setFillColor(fillColor);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'VectorImageDrawing')
         */
        _string: 'VectorImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  VectorImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('vectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access protected
         * @return Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    fill: layer.getStyle('fillColor'),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getUrl
         * 
         * Returns the path to the vector's stored asset, or else assumes that
         * the accessor for this vector (eg. The Noun Project) is on the page.
         * In the latter case, it's likely to be a ResourceAccessor.
         *
         * In the case where the image is an asset, I go directly to S3 instead
         * of through Cloudinary, as it seems Cloudinary doesn't serve SVGs
         * properly.
         * 
         * If the image isn't an asset, then, at the moment, it's likely a
         * resource (eg. The Noun Project), in which case I just grab the svg
         * url directly.
         * 
         * @access protected
         * @return String|false
         */
        _getUrl: function() {
            var image = this._layer.getProperty('image'),
                accessor;
            if (image.match(/^asst/) !== null) {
                var key = (image) + '.svg';
                // return Images.s3(key);
                return Images.cloudFront(key);
            }
            accessor = Stencil.getAccessor(image);
            if (accessor !== false) {
                return accessor.url('svg');
            }
            return false;
        },

        /**
         * _prepare
         * 
         * @access protected
         * @var    Object
         */
        _prepare: {

            /**
             * _prepare.clip
             * 
             * @see    https://i.imgur.com/KvUG12A.png
             * @access protected
             * @param  Number width
             * @param  Number height
             * @return void
             */
            clip: function(width, height) {

                /**
                 * clip
                 * 
                 * Some icons were coming in as sprites. As a result, drawing an
                 * icon could result in a bunch of other icons being written. I
                 * tried to get around this by using the isContainedWithinObject
                 * and  isContainedWithinRect methods against the PathGroup
                 * object, but it didn't work well, possibly because paths
                 * pivotel to the desired icon started/ended outside of the
                 * object / rectangle. To get around this, I simply clip the
                 * vector according to it's width/height. The reason I have to
                 * set x / y as negative values is because the origin is set as
                 * center / center.
                 * 
                 * @access private
                 * @param  CanvasRenderingContext2D ctx
                 * @return void
                 */
                var clip =  function (ctx) {
                    var x = -width / 2,
                        y = -height / 2;
                    ctx.rect(x, y, width, height);
                };
                this._cotton.setClipTo(clip);
            },

            /**
             * _prepare.draw
             * 
             * @access protected
             * @param  Boolean fresh
             * @return void
             */
            draw: function(fresh) {

                // Options
                var layer = this._layer,
                    cotton = this._cotton,
                    options = this._getOptions(),
                    width = options.width,
                    fill = options.fill;

                /**
                 * Checks whether this is a "fresh" addition to the canvas
                 * (an addition via the Preview.addVectorImagelayer method). If
                 * it is, it checks the ratio, and if it's a really tall image,
                 * it maxes out the height to 25% of the height of the canvas.
                 */
                if (fresh === true) {
                    if (cotton.getRatio() < 1) {
                        var height = 25,
                            dimensions = layer.getCanvas().getRenderedDimensions(),
                            percentage = height / 100,
                            pixels = (dimensions.height * percentage).round(4),
                            adjustedWidth;
                        width = pixels * cotton.getRatio();
                        adjustedWidth = ((width / dimensions.width) * 100).round(4);
                        layer.setStyles({
                            'width': adjustedWidth
                        });

                        // Update change history with new value
                        var undoHistory = ChangeHistory.history.undo(),
                            index = undoHistory.length - 1,
                            operation = undoHistory[index],
                            imageKey = this._layer.getProperty('image'),
                            json = operation.configuration.settings.json,
                            regExp,
                            pattern = '(' + (imageKey) + '".+?"width":)15';
                            replacement = '$1' + (adjustedWidth);
                        regExp = new RegExp(pattern);
                        json = json.replace(regExp, replacement);
                        operation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(operation);
                    }
                }

                // Set options
                var angle = options.angle;
                delete options.angle;
                delete options.fill;
                delete options.width;
                cotton.set(options);
                var scaled = this._getScaledWidth();
                cotton.scaleToWidth(scaled);
                cotton.setAngle(angle);

                // Scaling
                var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                    scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                cotton.setScaleX(scaleX);
                cotton.setScaleY(scaleY);
                cotton.setCoords();

                // Color
                cotton.setFillColor(fill);

                // Controls
                this._addListeners();

                // Cashmere
                this.magnets.angles.apply(this);
                this.magnets.outbound.apply(this);
                cotton.boxIn(this._boxInRatio);
                this.magnets.inbound.apply(this);

                // Event dispatching
                this._drawn = true;
                this.triggerHandler('draw', [this]);
            },

            /**
             * _prepare.shapes
             * 
             * @access protected
             * @param  Array shapes
             * @return Array
             */
            shapes: function(shapes) {

                /**
                 * Stripping out any shapes that are text to deal with
                 * issues like the following:
                 * https://i.imgur.com/JHXI3Vi.png
                 * https://i.imgur.com/HHnupvi.png
                 * 
                 * @note Not sure if there are any icons that are using text
                 *       paths as part of their image. Hope not :/
                 * @note May not be needed, since I'm using a clipping
                 *       function now (which out to hide any text that might
                 *       be contained in a sprite).
                 */
                shapes = jQuery.grep(shapes, function(shape, index) {
                    return shape.type !== 'text';
                });

                /**
                 * Adjust for stroke
                 * 
                 * Some icons (for example, the ice cream below), are 100%
                 * composed of strokes. So when I set the strokeWidth for all
                 * fabric objects to 0, it messed these ones up. So here, I
                 * check to see whether a stroke is defined on any of the
                 * shapes, and if so, set the stroke for that shape (not
                 * PathGroup) to 1.
                 * 
                 * @see https://i.imgur.com/oVD08Pn.png
                 *      https://s3-us-west-2.amazonaws.com/app.local.getstencil.com/asst5afa89ce.svg
                 */
                jQuery.each(shapes, function(index, shape) {
                    if (shape.stroke && shape.stroke !== '') {
                        if (
                            shape.strokeWidth === undefined
                            || shape.strokeWidth === null
                            || shape.strokeWidth === 0
                        ) {
                            shape.strokeWidth = 1;
                        }
                    }
                });

                // 
                return shapes;
            },

            /**
             * _prepare.trim
             * 
             * Oh, trim-method. This one was gnarly, and took a long time to get
             * right. It scales a vector to 400px wide, and then sets up a
             * temporary canvas. The canvas has it's width and height set to
             * match the vector, and then a fabric-canvas is made from it. I
             * then add the vector to the canvas and proceed to run the trim
             * helper function to determine the exact fit.
             * 
             * The tricky thing is that fabric now automatically scales things
             * according to whether the client is using a retina monitor. So
             * after the trim comes back, I need to devide the number by the
             * pixel ratio, otherwise it's too high when i transform the vector
             * paths.
             * 
             * Note that the 400px-wide vector setting is to try and get the
             * best possible fidelity in terms of the truest fit. The higher
             * that width, the more specific the trim function is, but it's also
             * a heavy computation, thus the note below to look into web
             * workers.
             * 
             * When the value is too high, it causes a lag in the animation of
             * the icon dropping into the canvas, likely because the browser's
             * memory is full (hmm, look into this). It was especially noticable
             * with retina devices (Adam's monitor), because when the temporary
             * canvas is drawn, retina has 4-times more pixels (which requires
             * 4-times more computations).
             * 
             * @todo   Look into using web workers here since it can cause lag
             *         https://blog.idrsolutions.com/2012/09/how-to-draw-svg-on-html-5-canvas-and-why-you-might-want-to/
             * @access protected
             * @param  Function callback
             * @return void
             */
            trim: function(callback) {
                // this._cotton.scaleToWidth(200);
                this._cotton.scaleToWidth(400);
                // this._cotton.scaleToWidth(600);
                var factor = this._cotton.getScaleX(),
                    width = this._cotton.getWidth(),
                    height = this._cotton.getHeight(),
                    element = document.createElement('canvas'),
                    ratio = window.devicePixelRatio || 1,
                    ctx = element.getContext('2d');
                element.setAttribute('width', width);
                element.setAttribute('height', height);
                var canvas = new fabric.Canvas(element);
                canvas.add(this._cotton);
                var details = element.trim();
                details.width /= ratio;
                details.height /= ratio;
                details.bounds.left /= ratio;
                details.bounds.top /= ratio;
                canvas.remove(this._cotton);
                callback({
                    ratio: details.width / details.height,
                    width: details.width / factor,
                    height: details.height / factor,
                    bounds: {
                        left: details.bounds.left / factor,
                        top: details.bounds.top / factor
                    }
                });
            },

            /**
             * _prepare.xml
             * 
             * @access protected
             * @param  String xml
             * @return String
             */
            xml: function(xml) {

                /**
                 * Strips out any <clipPath> tags to prevent issues with
                 * some icons. This one specifically had an issue:
                 * https://i.imgur.com/MbMAx9w.png
                 */
                xml = xml.replace(/\<clipPath.*\<\/clipPath>/gi, '');

                /**
                 * Strips out any <switch> tags, which was causing some issues.
                 * Noticed with this icon:
                 * https://i.imgur.com/lIFE8wO.png
                 * 
                 * @see https://jsfiddle.net/bsnsd6ku/
                 */
                xml = xml.replace(/\<switch\>(.*)\<\/switch\>/gi, '$1');

                /**
                 * Fix any translate calls that were not set up
                 * properly. Specifically, some TNP icons were coming
                 * through with:
                 * transform="translate(-273.07-554.7)
                 *
                 * This is an invalid translate / transform value, since
                 * there needs to be a space between the two values. To
                 * get around this, check when two negative translate /
                 * transform values are defined, and insert a space when
                 * there isn't one.
                 * 
                 * @see http://stackoverflow.com/questions/34683134/svg-on-canvas-using-fabricjs-cant-be-seen-because-of-transform-translate-rul
                 * @see https://i.imgur.com/nDtRJ62.png
                 */
                // if (transform.match(/translate\(\-[0-9\.]+,?\-[0-9\.]+/) === null) {
                xml = xml.replace(
                    /translate\((\-?[0-9\.]+)(\-{1}[0-9\.]+)\)/gi,
                    'translate($1 $2)'
                );

                // Done for now
                return xml;
            }
        },

        /**
         * draw
         * 
         * @note   Filtering out text nodes to prevent the following:
         *         vector, but rather part of a sprite. Sometimes these sprites
         *         would include the following shapes:
         *         rect
         *         text
         *         line
         *         path
         *         polygon
         *         circle
         *         See: https://i.imgur.com/jldKsgt.png
         * @see    https://m.alphasights.com/killing-cors-preflight-requests-on-a-react-spa-1f9b04aa5730#.h1516nbjv
         * @see    http://www.w3schools.com/tags/canvas_rect.asp
         * @see    http://fabricjs.com/clipping/
         * @see    https://github.com/kangax/fabric.js/issues/2555
         * @see    http://fabricjs.com/clipping/
         * @todo   Implement some sort of caching so that if multiple versions
         *         of the same vector on the canvas, it doesn't fire multiple
         *         ajax requests. Simplest would be to create a helper method
         *         that checks for a layer with the same src, and if found,
         *         grabs the pathing info from it and uses that instead. This
         *         will also speed up the Ghost canvas, which would make
         *         Google+Firefox downloading even faster (when I get around to
         *         it). See <svgCache> in fabric.js. At the moment, it's not so
         *         bad, since the browser is caching them, resulting in a 4ms
         *         local lookup: https://i.imgur.com/aTggRQX.png
         *         This 4ms delay may not seem like much, but if there are a
         *         bunch of icons in the canvas, it's multipled, along with the
         *         delay in the http request itself.
         * @param  Boolean fresh
         * @access public
         * @return void
         */
        draw: function(fresh) {

            // Overhead
            var _this = this,
                layer = this._layer,
                url = this._getUrl();

            // Something went wrong
            if (url === false) {
                Stencil.alert('svg.load.fail.2');
                layer.triggerHandler('delete');
            }
            // Preload (to check CORS, since TNP sometimes flakes)
            else {
                var signature = {file: 'VectorImage', line: 458};
                Stencil.ajax({
                    signature: signature,
                    sign: false,
                    cache: true,
                    crossDomain: true,
                    url: url,
                    type: 'GET',

                    /**
                     * error
                     * 
                     * Shows the alert, and if there is an active XHR call,
                     * decrements the count to ensure the user can reload the page
                     * if they'd like to. I need to do this because there are two
                     * ways in which this request can fail:
                     * 1) The preflight request fails because of a CORS issue. When
                     *    outbound preflight calls are made, I do not believe jQuery
                     *    increments the <active> count. Because of this, I don't
                     *    decrement the count here.
                     * 2) The preflight goes through successfully, but the actual
                     *    request for data (GET) fails. When this is the case, I
                     *    need to decrement the count since the <active> property
                     *    would have been incremented.
                     * @todo   The logic below simply communicates to the user that
                     *         the icon isn't available, instead of failing
                     *         silently. The real issue is that if it does fail,
                     *         it's likely because of a hiccup on The Noun Project's
                     *         side, in that it's not passing the proper CORS
                     *         headers. I've seen this with AWS before. Once that
                     *         happens, the user caches the request. So there may
                     *         not be a way for them to eventually get that icon
                     *         unless they clear their cache. One possible way would
                     *         be to change the layer src value by appending a cache
                     *         busting value (eg. random=123), and trying again with
                     *         that before erroring out. Then, each time they click
                     *         on the icon, it'll try another random one. For this
                     *         to work, thought, this new src value will need to be
                     *         set in the layer and saved. Hard to test this.
                     * @access private
                     * @param  Object jqXHR
                     * @param  String textStatus
                     * @param  String errorThrown
                     * @return void
                     */
                    error: function(jqXHR, textStatus, errorThrown) {
                        App.log('jQuery AJAX error', true);
                        App.log(signature, true);
                        App.log(arguments, true);
                        Stencil.alert('svg.load.fail');
                        layer.triggerHandler('delete');
                    },
                    success: function(xml) {
                        xml = _this._prepare.xml.apply(_this, [xml]);
                        fabric.loadSVGFromString(
                            xml,
                            function(shapes, passed) {
                                shapes = _this._prepare.shapes.apply(_this, [shapes]);
                                var cotton = fabric.util.groupSVGElements(
                                    shapes,
                                    passed
                                );
                                _this._cotton = cotton;
                                _this._prepare.trim.apply(_this, [function(details) {
                                    _this._cotton.set({
                                        width: details.width,
                                        height: details.height
                                    });
                                    var transformMatrix;
                                    jQuery.each(_this._cotton.paths, function(index, path) {
                                        transformMatrix = path.transformMatrix || [1, 0, 0, 1, 0, 0];
                                        path.setTransformMatrix([
                                            transformMatrix[0],
                                            transformMatrix[1],
                                            transformMatrix[2],
                                            transformMatrix[3],
                                            transformMatrix[4] - details.bounds.left,
                                            transformMatrix[5] - details.bounds.top
                                        ]);
                                    });

                                    // 
                                    layer.getCanvas().getCotton().add(_this._cotton);
                                    // if (_this._cotton.paths.length > 1) {
                                        _this._prepare.clip.apply(
                                            _this,
                                            [
                                                details.width,
                                                details.height
                                            ]
                                        );
                                    // }
                                    _this._prepare.draw.apply(_this, [fresh]);
                                }]);
                            }
                        );
                    },
                    dataType: 'text'
                });
            }
        },

        /**
         * refresh
         * 
         * This method is essentially the same as the one in the ImageLayer
         * class. The exception is that there isn't a call to _scale (which is
         * a proxy for a call to _resize), since the VectorImageLayer layers are
         * references to vectors, which for scaling, only require to have their
         * width set (which is done via the _getScaleWidth method).
         * 
         * The _getScaleWidth method takes care of cases where padding is
         * defined (eg. on tablets).
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaled = this._getScaledWidth();
            cotton.scaleToWidth(scaled);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * WatermarkBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.WatermarkBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkBitmapImageDrawing')
         */
        _string: 'WatermarkBitmapImageDrawing',

        /**
         * init
         * 
         * @access public
         * @param  WatermarkBitmapImageLayer layer
         * @return void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addScaleListeners
         * 
         * @access protected
         * @return void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Stencil.getResizeDelay('watermarkBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access protected
         * @return void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('watermarkBitmapImage');
                }
            });
        },

        /**
         * _getUrl
         * 
         * @access protected
         * @param  Number width
         * @return String
         */
        _getUrl: function(width) {
            var ratio = window.devicePixelRatio || 1,
                key = this._layer.getProperty('image');
            width *= ratio;
            if (
                Stencil.get('config').defaults.roundCloudinaryRequests === true
                && this.getCanvas() !== Canvases.Ghost
            ) {
                return Images.cloudinary(key, {
                    type: 'scale',
                    width: width.round(0).roundToNext10()
                });
            }
            return Images.cloudinary(key, {
                type: 'scale',
                width: width.round(0)
            });
        },

        /**
         * animate
         * 
         * Fades the watermark in, using an easeOutBack transition. I'm noting
         * this because the transition is different than other drawings, which
         * use easeOutBounce. The issue with that is when it's just an opacity
         * change / fade, the opacity fades but bounces for a second at the end
         * when I use the easeOutBounce transition. The easeOutBack transition
         * has the same initial momentum, but doesn't have the opacity bounce at
         * the end. That being said, I am using that transition in other
         * drawings for opacity, but only when the bounce is applied with a
         * movement transition (eg. top). In that case, it makes sense that the
         * opacity bounces at the same bounce the position does.
         * 
         * @access public
         * @return void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton();
            this._cotton.animate('opacity', 1, {
                duration: 750,
                easing: fabric.util.ease.easeOutBack,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        },

        /**
         * draw
         * 
         * @access public
         * @return void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    // Set controls visibility to prevent stretching knobs
                    cotton.setControlsVisibility({
                        tl: true,
                        tr: true,
                        br: true,
                        bl: true,
                        ml: false,
                        mt: false,
                        mr: false,
                        mb: false,
                        mtr: true
                    });

                    /**
                     * Options
                     *
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * ImageDocument
     * 
     * @extends Simple
     */
    window.ImageDocument = Simple.extend({

        /**
         * _canvas
         * 
         * @access protected
         * @var    false|CanvasView (default: false)
         */
        _canvas: false,

        /**
         * _document
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _document: {},

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'imageDocument')
         */
        _handlerType: 'imageDocument',

        /**
         * _image
         * 
         * @access protected
         * @var    ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _layers
         * 
         * Keeps track of all layers, including those that contain order-style
         * values (eg. any kind of TextLayer, VectorImage or
         * ForegroundBitmapImage).
         * 
         * @access protected
         * @var    Array (default: [])
         */
        _layers: [],

        /**
         * init
         * 
         * @access public
         * @param  Object document
         * @param  ImageAccessor image
         * @param  CanvasView canvas
         * @return void
         */
        init: function(document, image, canvas) {
            this._super();
            this._layers = [];
            this._document = document;
            this._image = image;
            this._canvas = canvas;
            // this._setupBackground();
            // this.setupLayers();
            // this.sortLayers();
        },

        // /**
        //  * _setupBackground
        //  * 
        //  * @access protected
        //  * @return void
        //  */
        // _setupBackground: function() {
        //     this._background = this._document._background;
        // },

        /**
         * addLayer
         * 
         * Simply pushes a Layer object into the ImageDocument's layers array.
         * 
         * @access public
         * @param  Layer layer
         * @return void
         */
        addLayer: function(layer) {
            this._layers.push(layer);
            this._image.setConfiguration();
        },

        /**
         * deleteAllLayers
         * 
         * @access public
         * @return void
         */
        deleteAllLayers: function() {
            for (var x = this._layers.length - 1; x >= 0; x--) {
                this._layers[x].triggerHandler('delete');
            }
            this._image.triggerHandler('delete/all/finish');
        },

        /**
         * each
         * 
         * Runs an interator function against all the layers, with the
         * ImageDocument set as the context.
         * 
         * @access public
         * @param  Function iterator
         * @return void
         */
        each: function(iterator) {
            jQuery.each(this._layers, (function(index, layer) {
                iterator.apply(this, [index, layer]);
            }).proxy(this));
        },

        /**
         * filter
         * 
         * Applies a filter function to the layers, returning whichever ones
         * pass the test. Filter function has the ImageDocument set as the
         * context.
         * 
         * @access public
         * @param  Function filter
         * @return Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._layers, (function(index, layer) {
                if (filter.apply(this, [index, layer]) === true) {
                    matching.push(layer);
                }
            }).proxy(this));
            return matching;
        },

        /**
         * find
         * 
         * Searches through layers for a specific Layer object. Currently
         * supports searching properties and styles on layers. Returns false if
         * no match could be found.
         * 
         * @access public
         * @param  String type
         * @param  String key
         * @param  mixed value
         * @return false|Layer
         */
        find: function(type, key, value) {
            var filtered = this.filter(function(index, layer) {
                if (type === 'property') {
                    return layer.getProperty(key) === value;
                } else if (type === 'style') {
                    return layer.getStyle(key) === value;
                }
                return false;
            });
            if (filtered.length === 0) {
                return false;
            }
            return filtered[0];
        },

        /**
         * getBottomOrderedLayer
         * 
         * Returns the layer that has the lowest order-style value. At the
         * moment, I don't allow specification on whether watermark layers
         * could be returned, since there isn't a way to move watermarks that
         * far back anyhow.
         * 
         * @access public
         * @return Layer|false
         */
        getBottomOrderedLayer: function() {
            var layers = this.filter(function(index, layer) {
                return layer.getProperty('background') !== true
                    && layer.getStyle('order') === 0;
            });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getCanvas
         * 
         * @access public
         * @return CanvasView
         */
        getCanvas: function() {
            return this._canvas;
        },

        /**
         * getDocument
         * 
         * @access public
         * @return Object
         */
        getDocument: function() {
            return this._document;
        },

        /**
         * getImage
         * 
         * @access public
         * @return ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getLayers
         * 
         * Returns all layers in the image document, possibly including
         * watermarks.
         * 
         * @access public
         * @param  Boolean includeWatermarks
         * @return Array
         */
        getLayers: function(includeWatermarks) {
            if (includeWatermarks === true) {
                return this._layers;
            }
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getLockedLayers
         * 
         * @access public
         * @return Array
         */
        getLockedLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('locked') === true;
            });
        },

        /**
         * getOrderedLayers
         * 
         * Returns layers that have a order-style property assigned to them,
         * which by nature excludes the background rectangle and background
         * image. Watermarks may be included in the check.
         * 
         * @access public
         * @param  Boolean includeWatermarks
         * @return Array
         */
        getOrderedLayers: function(includeWatermarks) {
            return this.filter(function(index, layer) {
                if (includeWatermarks === true) {
                    return layer.getProperty('background') !== true;
                }
                return layer.getProperty('background') !== true
                    && layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getTextLayers
         * 
         * @access public
         * @return Array
         */
        getTextLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'text';
            });
        },

        /**
         * getTopOrderedLayer
         * 
         * Returns the layer that has the highest order-style value, possibly
         * including watermarks.
         * 
         * @access public
         * @param  Boolean includeWatermarks
         * @return Layer|false
         */
        getTopOrderedLayer: function(includeWatermarks) {
            var orderedLayers = this.getOrderedLayers(includeWatermarks).length,
                layers = this.filter(function(index, layer) {
                    return layer.getProperty('background') !== true
                        && layer.getStyle('order') === orderedLayers - 1;
                });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getVectorImageLayers
         * 
         * @access public
         * @return Array
         */
        getVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true;
            });
        },

        /**
         * getWatermarkLayers
         * 
         * Returns _only_ watermark layers, which contrasts with the getLayers
         * method when true is passed in, which will return all layers
         * _including_ watermark layers.
         * 
         * @access public
         * @return Array
         */
        getWatermarkLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') === true;
            });
        },

        /**
         * getWatermarkLayersJson
         * 
         * Returns an object of all the watermark layer's properties as JSON.
         * I am not removing the order style-property, since at the moment, this
         * is only being used to track watermark json in an ImageAccessor to
         * determine if the image has changed, at which point the order of
         * watermarks is important.
         * 
         * @access public
         * @return Object
         */
        getWatermarkLayersJson: function() {
            var json = {
                    layers: []
                },
                layers = this.getWatermarkLayers();
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * json
         * 
         * Returns the JSON representation of the document.
         * 
         * @access public
         * @param  Boolean includeWatermarks
         * @return Object
         */
        json: function(includeWatermarks) {
            var json = {
                    layers: []
                },
                layers = this.getLayers(includeWatermarks);
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * mergeWatermarks
         * 
         * @access public
         * @return void
         */
        mergeWatermarks: function() {
            if (Stencil.get('smartToggleWatermarks') === true) {
                var _this = this,
                    document = this._document,
                    imageWatermarksJson = _this._image.setting('watermarks'),
                    imageWatermarks,
                    watermarks = Stencil.account().collection('watermarks'),
                    filters,
                    styles;
                if (imageWatermarksJson === '') {
                    imageWatermarksJson = JSON.stringify({
                        layers: []
                    });
                }
                if (JSON.valid(imageWatermarksJson) === false) {
                    imageWatermarksJson = JSON.stringify({
                        layers: []
                    });
                }
                imageWatermarks = JSON.parse(imageWatermarksJson).layers;

                /**
                 * Loop through all the watermarks that the account has stored
                 * in the associated collection.
                 */
                watermarks.each(function(index, watermark) {
                    var watermarkIsPartOfImage = function(watermark, imageWatermarks) {
                        for (var index in imageWatermarks) {
                            if (imageWatermarks[index].image === watermark.get('key')) {
                                return true;
                            }
                        }
                        return false;
                    };
                    if (watermarkIsPartOfImage(watermark, imageWatermarks) === true) {
                        for (var index in imageWatermarks) {
                            if (imageWatermarks[index].image === watermark.get('key')) {
                                filters = imageWatermarks[index].filters;
                                styles = imageWatermarks[index].styles;
                                styles.order = document.layers.length - 2;
                                document.layers.push({
                                    filters: filters,
                                    image: watermark.get('key'),
                                    styles: styles,
                                    type: 'image',
                                    watermark: true,
                                    locked: false
                                });
                                if (watermark.setting('active').toInt() === 0) {
                                    watermark.set({
                                        'settings.active': 1
                                    });
                                    watermark.save(['settings.active']);
                                }
                            }
                        }
                    } else {
                        if (watermark.setting('active').toInt() === 1) {
                            watermark.set({
                                'settings.active': 0
                            });
                            watermark.save(['settings.active']);
                        }
                    }
                });
            } else {
                Stencil.set('smartToggleWatermarks', false);
                var _this = this,
                    document = this._document,
                    watermarks = Stencil.account().collection('watermarks'),
                    filters,
                    styles,
                    active;
                watermarks.each(function(index, watermark) {
                    active = watermark.setting('active').toInt() === 1;
                    if (active === true) {
                        if (
                            JSON.valid(watermark.setting('filters')) === true
                            && JSON.valid(watermark.setting('styles')) === true
                        ) {
                            filters = JSON.parse(watermark.setting('filters'));
                            styles = JSON.parse(watermark.setting('styles'));
                            styles.order = document.layers.length - 2;
                            document.layers.push({
                                image: watermark.get('key'),
                                filters: filters,
                                styles: styles,
                                type: 'image',
                                watermark: true
                            });
                        } else {
                            StencilBooter.log('JSON parse error (ID:mW)');
                        }
                    }
                });
            }
        },

        /**
         * removeLayer
         * 
         * After removal, loops over the layers, and ensures that a proper
         * order-value is set (since removing a layer changes the order-values
         * across the board).
         * 
         * I only retrieve the ordered layers (for adjusting order-style
         * values), since the background rectangle and background image layers
         * would never be affected by a layer being removed (since they don't
         * have a order-style property, and their order can't actually be
         * changed).
         * 
         * It's important that the layer not be deleted from memory (eg. with a
         * delete call). This is because it might be referenced by a delayed
         * save function (at the moment, only ones I can think of are
         * watermarks). They'll reference the styles / properties of the layer
         * when it goes off and saves things.
         * 
         * @access public
         * @param  Layer toRemove
         * @return void
         */
        removeLayer: function(toRemove) {
            this.each(function(index, layer) {
                if (layer === toRemove) {
                    this._layers.splice(index, 1);
                }
            });
            var layers = this.getOrderedLayers(true);
            jQuery.each(layers, function(index, layer) {
                layer.setStyle('order', index);
            });
            this.sortLayers();
            this._image.setConfiguration();
        },

        /**
         * reorderWatermarks
         * 
         * Ensures that the watermarks are the top most layer by adjusting their
         * order-style value. This function works by setting the order of the
         * watermark style value to the index of the watermark among all other
         * watermarks on the canvas, in addition to the number of previous
         * non-watermark layers. You might want to draw this on a piece of paper
         * to help visualize it if you need to.
         * 
         * @access public
         * @return void
         */
        reorderWatermarks: function() {
            var ordered = this.getOrderedLayers(false).length,
                watermarks = this.getWatermarkLayers();
            jQuery.each(watermarks, function(index, layer) {
                layer.setStyle('order', index + ordered);
            });
            this.sortLayers();
        },

        /**
         * setImage
         * 
         * @access public
         * @param  ImageAccessor image
         * @return void
         */
        setImage: function(image) {
            this._image = image;
        },

        /**
         * setupLayers
         * 
         * @access public
         * @return void
         */
        setupLayers: function() {
            var layer,
                klass,
                _this = this;
            this._layers = [];
            jQuery.each(this._document.layers, function(index, properties) {
                klass = false;
                if (properties.type === 'text') {
                    klass = TextLayer;
                } else if (properties.type === 'rectangle') {
                    klass = BackgroundRectangleLayer;
                } else if (properties.type === 'image') {
                    if (properties.vector === true) {
                        klass = VectorImageLayer;
                    } else if (properties.watermark === true) {
                        klass = WatermarkBitmapImageLayer;
                    } else {
                        if (properties.background === true) {
                            klass = BackgroundBitmapImageLayer;
                        } else {
                            klass = ForegroundBitmapImageLayer;
                        }
                    }
                }
                layer = new klass(properties, _this);
                if (layer.valid() === true) {
                    // if (saved === true) {
                    //     layer.set({saved: true});
                    // }
                    _this._layers.push(layer);
                }
            });
        },

        /**
         * sortLayers
         * 
         * I had a lot of trouble with this function, and ended up converting it
         * to a simpler (Sergei inspired) algorithm whereby I convert the
         * toString values to integers based on the desired order (background
         * rectangle as 0, background image as 1, followed by the layers with
         * their style order value being used [with 2 being added since the
         * order values start at 0]). Then when I perform the sort, I simply
         * perform it numerically by casting the strings as integers. After the
         * sort has been completed, I revert the _string values.
         * 
         * While this seems more cumbersome, it's much more dependable than what
         * I was doing before. I have no idea how to use the comparison function
         * with properties :/
         * 
         * @access public
         * @return void
         */
        sortLayers: function() {
            jQuery.each(this._layers, function(index, layer) {
                layer._previous = layer._string;
                if (
                    layer.getProperty('type') === 'rectangle'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 0;
                } else if (
                    layer.getProperty('type') === 'image'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 1;
                } else {
                    layer._string = layer.getStyle('order').toInt() + 2;
                }
            });
            this._layers.sort(function(a, b) {
                return a.toString().toInt() - b.toString().toInt();
            });
            jQuery.each(this._layers, function(index, layer) {
                layer._string = layer._previous;
                delete layer._previous;
            });
        },

        /**
         * syncLockedState
         * 
         * @access public
         * @return void
         */
        syncLockedState: function() {
            var lockedLayers = this.getLockedLayers(),
                draft = Stencil.account().draft();
            if (Account.draftIsLocked() === true) {
                if (lockedLayers.length === 0) {
                    draft.set({
                        'settings.locked': 0
                    });
                    draft.save(['settings.locked']);
                }
            } else {
                if (lockedLayers.length > 0) {
                    draft.set({
                        'settings.locked': 1
                    });
                    draft.save(['settings.locked']);
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * Layer
     * 
     * @fires   change/angle
     *          change/position
     *          change/scale
     *          set/property
     *          set/property/x
     *          set/style
     *          set/style/x
     *          move/up
     *          move/down
     *          move/right
     *          move/left
     * @extends Simple
     */
    window.Layer = Simple.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    undefined|String (default: undefined)
         */
        _changeHistoryKeyPrefix: undefined,

        /**
         * _drawing
         * 
         * @access protected
         * @var    null|Drawing (default: null)
         */
        _drawing: null,

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'layer')
         */
        _handlerType: 'layer',

        /**
         * _imageDocument
         * 
         * @access protected
         * @var    false|ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return {
                'angle': function() {
                    this.on({
                        'change/angle': function(event, angle) {
                            this.setChangeOperationType('rotated');
                            this.setStyle('angle', angle);
                        }
                    });
                },
                'clone': function() {
                    this.on({
                        'clone': function(event) {
                            this.setChangeOperationType('cloned');
                            this.clone();
                        }
                    });
                },
                'delete': function() {
                    this.on({
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            this.getCanvas().setSelectedLayer(false);
                            this._imageDocument.removeLayer(this);
                        }
                    });
                },
                'flip': function() {
                    this.on({
                        'flip/x': function(event, flip) {
                            this.setChangeOperationType('flipped:x');
                            this.setStyle('flipX', flip);
                        },
                        'flip/y': function(event, flip) {
                            this.setChangeOperationType('flipped:y');
                            this.setStyle('flipY', flip);
                        }
                    });
                },
                'move': function() {
                    this.on({
                        'move/up': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/right': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        },
                        'move/down': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/left': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        }
                    });
                },
                'order': function() {
                    this.on({
                        'change/order': function(event, forward) {
                            if (forward === true) {
                                this.setChangeOperationType('sent:forward');
                                this.bringForward();
                            } else {
                                this.setChangeOperationType('sent:back');
                                this.sendBack();
                            }
                        }
                    });
                },
                'position': function() {
                    this.on({
                        'change/position': function(event, position) {
                            this.setChangeOperationType('moved');
                            this.setStyles({
                                'left': position.left,
                                'top': position.top
                            });
                        }
                    });
                },
                'properties': function() {
                    this.on({
                        'set/property': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        },
                        'set/style': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        }
                    });
                }
            };
        },

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _properties
         * 
         * @access protected
         * @var    null|Object (default: null)
         */
        _properties: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Layer')
         */
        _string: 'Layer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super();
            this._properties = properties;
            this._setupListeners();
            this._imageDocument = imageDocument;
        },

        /**
         * _setupListeners
         * 
         * @access protected
         * @return void
         */
        _setupListeners: function() {
            this._listeners = this._listeners();
            for (var index in this._listeners) {
                this._listeners[index].apply(this);
            }
        },

        /**
         * autoAlign
         * 
         * @access public
         * @return void
         */
        autoAlign: function() {
            this.setChangeOperationType('centered');
            this._drawing.autoAlign();
        },

        /**
         * back
         * 
         * Returns whether the layer is the back-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-background
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * Also note that it doesn't take watermarks into consideration at the
         * moment, since they're always the front-most layers.
         * 
         * @access public
         * @return Boolean
         */
        back: function() {
            return this === this._imageDocument.getBottomOrderedLayer();
        },

        /**
         * bringForward
         * 
         * Sends the layer one order forward, adjusting the one it replaced to
         * take it's order-value.
         * 
         * @todo!  Detect if the layer is overlapping any other ones, and when
         *         it is, show the layer-UI button options. This might prevent
         *         people from clicking them when there are no overlap layers,
         *         and not noticing a change (and thus not sure what the
         *         buttons do)
         * @access public
         * @return void
         */
        bringForward: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order + 1
                );
            this.setStyle('order', order + 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * clone
         * 
         * @access public
         * @return void
         */
        clone: function() {
            var properties = jQuery.extend(true, {}, this._properties),
                canvas = this.getCanvas();
            properties.styles.order = this._imageDocument.getOrderedLayers(false).length;
            properties.styles.left += 5;
            properties.styles.top += 5;
            var layer = new this.constructor(properties, this._imageDocument),
                drawing = layer.getDrawing();
            this._imageDocument.addLayer(layer);
            this._imageDocument.reorderWatermarks();
            drawing.once({
                'draw': function(event) {
                    this.select();
                    canvas.render();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * front
         * 
         * Returns whether the layer is the front-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-watermark
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * @access public
         * @return Boolean
         */
        front: function() {
            return this === this._imageDocument.getTopOrderedLayer(false);
        },

        /**
         * getCanvas
         * 
         * @access public
         * @return CanvasView
         */
        getCanvas: function() {
            return this._imageDocument.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access public
         * @return fabric.Object
         */
        getCotton: function() {
            return this._drawing.getCotton();
        },

        /**
         * getDrawing
         * 
         * @access public
         * @return Drawing
         */
        getDrawing: function() {
            return this._drawing;
        },

        /**
         * getImageDocument
         * 
         * @access public
         * @return ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getProperties
         * 
         * @access public
         * @return Object
         */
        getProperties: function() {
            return this._properties;
        },

        /**
         * getProperty
         * 
         * @access public
         * @param  String name
         * @return mixed
         */
        getProperty: function(name) {
            return this._properties[name];
        },

        /**
         * getStyle
         * 
         * @access public
         * @param  String name
         * @return mixed
         */
        getStyle: function(name) {
            return this._properties.styles[name];
        },

        /**
         * getStyles
         * 
         * @access public
         * @return Object
         */
        getStyles: function() {
            return this._properties.styles;
        },

        /**
         * goto
         * 
         * @access public
         * @var    Object
         */
        goto: {

            /**
             * previous
             * 
             * Focuses on the layer in the position lower than the selected
             * one. If no layer is lower, it grabs the top layer. If no layer
             * other than the one already selected is found, nothing happens.
             * 
             * @access public
             * @return void
             */
            previous: function() {
                var order = this._properties.styles.order.toInt(),
                    previousLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order - 1
                    );
                if (previousLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (previousLayer !== this.getCanvas().getSelectedLayer()) {
                        previousLayer.select();
                    }
                }
            },

            /**
             * next
             * 
             * Focuses on the layer in the position higher than the selected
             * one. If no layer is higher, it grabs the bottom layer. If no
             * layer other than the one already selected is found, nothing
             * happens.
             * 
             * @access public
             * @return void
             */
            next: function() {
                var order = this._properties.styles.order.toInt(),
                    nextLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order + 1
                    );
                if (nextLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (nextLayer !== this.getCanvas().getSelectedLayer()) {
                        nextLayer.select();
                    }
                }
            }
        },

        /**
         * select
         * 
         * @access public
         * @return void
         */
        select: function() {
            this._drawing.select();
        },

        /**
         * sendBack
         * 
         * Sends the layer one order back, adjusting the one it replaced to take
         * it's position-value.
         * 
         * @todo!  Detect if the layer is overlapping any other ones, and when
         *         it is, show the layer-UI button options. This might prevent
         *         people from clicking them when there are no overlap layers,
         *         and not noticing a change (and thus not sure what the
         *         buttons do)
         * @access public
         * @return void
         */
        sendBack: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order - 1
                );
            this.setStyle('order', order - 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * setImageDocument
         * 
         * @access public
         * @param  ImageDocument imageDocument
         * @return void
         */
        // setImageDocument: function(imageDocument) {
        //     this._imageDocument = imageDocument;
        // },

        /**
         * setChangeOperationType
         * 
         * This is more or less a proxy for the ChangeHistory setOperatioType
         * method, to simplify the type that is passed. I lookup the type-prefix
         * for this layer, and pass that along.
         * 
         * @access public
         * @param  String typePrefix
         * @return void
         */
        setChangeOperationType: function(typePrefix) {
            var changeHistoryKeyPrefix = this._changeHistoryKeyPrefix,
                type = (changeHistoryKeyPrefix) + (typePrefix);
            ChangeHistory.setOperationType(type);
        },

        /**
         * setProperty
         * 
         * @access public
         * @param  String name
         * @param  String value
         * @return mixed
         */
        setProperty: function(name, value) {
            var previous = this._properties[name];
            this._properties[name] = value;
            this.triggerHandler('set/property', [name, value, previous]);
            this.triggerHandler('set/property/' + (name), [value, previous]);
        },

        /**
         * setStyle
         * 
         * @access public
         * @param  String name
         * @param  mixed value
         * @return void
         */
        setStyle: function(name, value) {
            var previous = this._properties.styles[name];
            this._properties.styles[name] = value;
            this.triggerHandler('set/style', [name, value, previous]);
            this.triggerHandler('set/style/' + (name), [value, previous]);
        },

        /**
         * setStyles
         * 
         * @access public
         * @param  Object styles
         * @return void
         */
        setStyles: function(styles) {
            for (var property in styles) {
                this.setStyle(property, styles[property]);
            }
            this.triggerHandler('set/styles', [styles]);
        },

        /**
         * valid
         * 
         * @access public
         * @return Boolean
         */
        valid: function() {
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * BackgroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.BackgroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: image, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: true // ',

        /**
         * _listeners
         * 
         * @see    http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'image/changed': function() {
                    this.on({
                        'set/property/image': function(event, value, previous) {
                            if (value === false) {
                                this.setProperty('locked', false);
                            }
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundBitmapImageLayer')
         */
        _string: 'BackgroundBitmapImageLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeFlipStyles(properties);
            this._super(properties, imageDocument);
            this._drawing = new BackgroundBitmapImageDrawing(this);
            this.listenForGatewaySave();
            this.setupGatewaySave();
        },

        /**
         * _normalizeFlipStyles
         * 
         * Because we added in the ability to flip the background image after
         * many images have been created, this helper method was neede to
         * ensure that a flipX and flipY style property is always defined.
         * 
         * If one isn't defined, it causes errors whereby when a user loads up
         * an older image (or at launch time, is simply in their draft),
         * clicking the flip actions the first time will result in nothing
         * changing, since there wasn't any value in the first place.
         * 
         * @access protected
         * @return void
         */
        _normalizeFlipStyles: function(properties) {
            // if (properties.styles.flipX === undefined) {
            //     properties.styles.flipX = false;
            // }
            // if (properties.styles.flipY === undefined) {
            //     properties.styles.flipY = false;
            // }
            return properties;
        },

        /**
         * getToolbar
         * 
         * @access public
         * @return BackgroundBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.backgroundBitmapImage;
        },

        /**
         * goto
         * 
         * @access public
         * @var    Object
         */
        goto: {

            /**
             * previous
             * 
             * @access public
             * @return void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access public
             * @return void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        },

        /**
         * listenForGatewaySave
         * 
         * Listens for a save event against the ResourceAccessor that this
         * BackgroundBitmapImageLayer is set to (if any). This listener works a
         * bit differently than the similar one in VectorImageLayer layers, in
         * that it gets called multiple times. Specifically, whenever a
         * 3rd-party resource (at the moment, just Pixabay) is set as the
         * background image. This is because these layers work differently than
         * VectorImageLayer layers, in that they're never deleted, just shown /
         * hidden.
         * 
         * That being said, the calls need to exist in the constructor as well
         * to allow for the case when a 3rd-party resource is selected, and
         * before it's saved, a save attempt is made. In that case, when the
         * constructor is called, the image-property will be referencing that
         * 3rd-party resource, and the listener and save attempt logic need to
         * be triggered.
         * 
         * @access public
         * @return void
         */
        listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.getProperty('image') === previousKey) {
                            var newKey = asset.get('key')
                            ChangeHistory.syncResourceKeyInOperations(
                                previousKey,
                                newKey
                            );
                            _this.setImage(newKey);
                            var canvas = _this.getCanvas(),
                                background = canvas.getBackgroundImageLayer();
                            if (background.getCanvas() !== Canvases.Ghost) {
                                var drawing = background.getDrawing();
                                drawing.once({
                                    'refresh': function() {
                                        canvas.render();
                                    }
                                });
                                drawing.reload();
                            }
                        }
                    }
                });
            }
        },

        /**
         * setImage
         * 
         * This is a helper-method for dealing with times when the
         * image-property for the layer needs to change. It's intention was to
         * reset position-styles when needed, hide the layer which an image was
         * being removed, and change the image-property in the layer.
         * 
         * @access public
         * @param  String|false image
         * @return void
         */
        setImage: function(image) {

            /**
             * Image is being reset (eg. color being applied). I hide the layer
             * instead of deleting it, which would be the natually assumption,
             * to ensure the layer is always available.
             */
            if (image === false) {
                this.setStyles({
                    'flipX': false,
                    'flipY': false,
                    'left': 50,
                    'top': 50
                });
                this.getCotton().set({
                    'flipX': false,
                    'flipY': false,
                    'visible': false
                });
            } else {

                /**
                 * Reset position styles if the following are all true:
                 * 1. Image key is an asset
                 * 2. The asset doesn't correspond to a 3rd party resource that
                 *    is already set within the layer (detected via the
                 *    <getHash> check)
                 * 3. The asset isn't already set within the layer
                 */
                if (image.match(/^asst/) !== null) {
                    var asset = Stencil.getAccessor(image);
                    if (asset.getHash() !== this._properties.image) {
                        if (this._properties.image !== asset.get('key')) {
                            this.setStyles({
                                'flipX': false,
                                'flipY': false,
                                'left': 50,
                                'top': 50
                            });
                            this.getCotton().set({
                                'flipX': this._properties.styles.flipX,
                                'flipY': this._properties.styles.flipY
                            });
                        }
                    }
                }
                /**
                 * Not an asset, so it could be an upload or resource reference.
                 * Just check whether the image is being switched, or set to the
                 * same record.
                 */
                else {
                    if (image !== this._properties.image) {
                        this.setStyles({
                            'flipX': false,
                            'flipY': false,
                            'left': 50,
                            'top': 50
                        });
                        this.getCotton().set({
                            'flipX': this._properties.styles.flipX,
                            'flipY': this._properties.styles.flipY
                        });
                    }
                }
            }

            // Go ahead and switch the image
            this.setProperty('image', image);
        },

        /**
         * setupGatewaySave
         * 
         * Very similar to the save logic setup in VectorImageLayer layers, with
         * the exception that a save call is not made if the image-property is
         * different than the one when this method was initially called. This is
         * because these layers are never deleted, just shown / hidden.
         * 
         * Like the listener method above, this method is called each time the
         * image is changed.
         * 
         * This delay-method is not prone to the issues that VectorImageLayer
         * layers are because of the property-check that is being made below
         * within the delayed function. That check prevents a possible issue
         * whereby the _getResource method was returning an AssetAccessor
         * (instead of a ResourceAccessor), therefore circumventing the issue.
         * 
         * If that check was not being made, then yes, the _getResource lookup
         * would need to be executed before the delay.
         * 
         * @access public
         * @return void
         */
        setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Stencil.getSaveDelay('resource'),
                    key = this._properties.image;
                (function() {
                    if (this.getProperty('image') === key) {
                        this._getResource().save();
                    }
                }).delay(delay, this);
            }
        },

        /**
         * valid
         * 
         * I'm overriding the parent method because I need to ensure a
         * BackgroundBitmapImageLayer is always part of the image document. So
         * here, I use the parent to check if it's a valid layer (which in this
         * case means that if an image value is defined, it's set to an upload
         * or asset record), and if it's not, I still return true to ensure the
         * layer is not "skipped".
         *
         * It should not cause any issues, since in the parent <valid> method,
         * it properly updates the image-property for the layer.
         * 
         * @access public
         * @return Boolean
         */
        valid: function() {
            var image = this._properties.image;
            if (image === false) {
                return true;
            }
            if (this._super() === true) {
                return true;
            }
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('RectangleLayer', function() {

    /**
     * BackgroundRectangleLayer
     * 
     * @extends RectangleLayer
     */
    window.BackgroundRectangleLayer = RectangleLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: rectangle, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: rectangle, background: true // ',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'backgroundColor': function() {
                    this.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            if (removed === true) {
                                this.setChangeOperationType('backgroundColor:removed');
                            } else {
                                this.setChangeOperationType('backgroundColor:changed');
                            }
                            this.setStyle('backgroundColor', backgroundColor);
                        },
                        'clear/backgroundColor': function(event) {
                            this.setChangeOperationType('backgroundColor:cleared');
                            var white = 'rgba(0, 0, 0, 0)';
                            this.setStyle('backgroundColor', white);
                        },
                        'reset/backgroundColor': function(event) {
                            var white = 'rgba(255, 255, 255, 1)';
                            this.setStyle('backgroundColor', white);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundRectangleLayer')
         */
        _string: 'BackgroundRectangleLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new BackgroundRectangleDrawing(this);
        },

        /**
         * goto
         * 
         * @access public
         * @var    Object
         */
        goto: {

            /**
             * previous
             * 
             * @access public
             * @return void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access public
             * @return void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageLayer', function() {

    /**
     * BitmapImageLayer
     * 
     * @extends ImageLayer
     */
    window.BitmapImageLayer = ImageLayer.extend({

        /**
         * _listeners
         * 
         * @see    http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'filters': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            var filters = this.getProperty('filters');
                            filters.push(obj);
                            this.setProperty('filters', filters);
                        },
                        'filter/remove': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.setProperty('filters', filters);
                        },
                        'filter/update': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters[i].properties = obj.properties;
                                }
                            }
                            this.setProperty('filters', filters);
                        }
                    });
                },
                'colorOverlay': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @note There's a debounce on this because it results
                         *       in bitmap-level changes, which is slow.
                         */
                        'change/colorOverlay': _.debounce(
                            function(event, colorOverlay) {
                                var filter = this.getFilter('colorOverlay');
                                this.set({'renderFilters': true});
                                if (filter === false) {
                                    this.setChangeOperationType('filter:colorOverlay:added');
                                    this.triggerHandler('filter/add', [{
                                        type: 'colorOverlay',
                                        properties: {
                                            color: colorOverlay,
                                            strength: 0
                                        }
                                    }]);
                                } else {
                                    this.setChangeOperationType('filter:colorOverlay:set');
                                    filter.properties.color = colorOverlay;
                                    this.triggerHandler('filter/update', [filter]);
                                }

                                // 
                                App.triggerHandler('changeHistory/track');
                                // $range.on({
                                //     'mouseup': function(event) {
                                //         (function() {
                                //             App.triggerHandler('changeHistory/track');
                                //         }).delay(filterResampleDelay);
                                //     }
                                // });
                            },
                            Stencil.getFilterResampleDelay()
                        ),
                        'clear/colorOverlay': function(event) {
                            var filter = this.getFilter('colorOverlay');
                            if (filter !== false) {
                                this.setChangeOperationType('filter:colorOverlay:cleared');
                                this.set({'renderFilters': true});
                                this.triggerHandler('filter/remove', [filter]);
                            }
                        }
                    });
                },
                'customFiltersStrengths': function() {
                    var customFilterTypes = [
                            'blur',
                            'colorOverlay',
                            'darken',
                            'lighten',
                            'opacity'
                        ],
                        _this = this,
                        index,
                        customFilterType,
                        eventName;
                    for (index in customFilterTypes) {
                        customFilterType = customFilterTypes[index];
                        eventName = 'change/' + (customFilterType) + 'Strength';
                        (function(customFilterType) {
                            _this.on(
                                eventName,
                                function(event, strength) {
                                    strength = strength.toInt();
                                    _this.set({'renderFilters': true});
                                    if (strength === 0) {
                                        _this.setChangeOperationType('filter:' + (customFilterType) + ':removed');
                                        this.triggerHandler('filter/remove', [{
                                            type: customFilterType
                                        }]);
                                        if (customFilterType === 'colorOverlay') {
                                            var toolbar = _this.getToolbar();
                                            toolbar.colorOverlay.clear.apply(
                                                toolbar
                                            );
                                        }
                                    } else {
                                        var filter = _this.getFilter(customFilterType);
                                        if (filter === false) {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':added');
                                            var properties = {
                                                strength: strength
                                            };
                                            if (customFilterType === 'colorOverlay') {
                                                var color = 'rgba(0, 0, 0, 1)',
                                                    toolbar = _this.getToolbar();
                                                properties.color = color;
                                                toolbar._set.colorOverlay.apply(toolbar, [color]);
                                                toolbar.colorOverlay.show.apply(toolbar);
                                            }
                                            this.triggerHandler('filter/add', [{
                                                type: customFilterType,
                                                properties: properties
                                            }]);
                                        } else {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':set');
                                            filter.properties.strength = strength;
                                            this.triggerHandler('filter/update', [filter]);
                                        }
                                    }
                                }
                            );
                        })(customFilterType);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BitmapImageLayer')
         */
        _string: 'BitmapImageLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeFilters(properties);
            this._super(properties, imageDocument);
        },

        /**
         * _normalizeFilters
         * 
         * When we first launched Stencil, filters were stored in an array as an
         * array of strings. They were simply strings like "darken", "lighten"
         * etc. However when we introduced the new filters system, we started
         * storing filters as an array of objects, where the object defined the
         * type of filter, along with properties (eg. strength, color, etc).
         * 
         * So we normalize that here to ensure the same object storage pattern,
         * thus making operations against it simpler.
         * 
         * @access protected
         * @return void
         */
        _normalizeFilters: function(properties) {
            if (properties.filters === undefined) {
                properties.filters = [];
            } else {
                var filter, index, normalized;
                for (index in properties.filters) {
                    filter = properties.filters[index];
                    if (typeof filter === 'string') {
                        normalized = {
                            type: filter,
                            properties: {}
                        };
                    } else {
                        normalized = {
                            type: filter.type,
                            properties: filter.properties || {}
                        };
                    }
                    properties.filters[index] = normalized;
                }
            }
            return properties;
        },

        /**
         * clearFilters
         * 
         * @note   The renderFilers set and render are called after all filters
         *         have been removed to ensure a render isn't done for each one.
         * @access public
         * @return void
         */
        clearFilters: function() {
            var filters = this.getProperty('filters'),
                x = filters.length - 1;
            for (; x >= 0; x--) {
                this.triggerHandler('filter/remove', [filters[x]]);
            }
            this.set({'renderFilters': true});
            this.getCanvas().render();
        },

        /**
         * getFilter
         * 
         * @access public
         * @param  String type
         * @return Object|false
         */
        getFilter: function(type) {
            var filters = this.getProperty('filters'),
                index;
            for (index in filters) {
                if (type === filters[index].type) {
                    return filters[index];
                }
            }
            return false;
        },

        /**
         * sortFilters
         * 
         * @access public
         * @return void
         */
        sortFilters: function() {
            var cotton = this.getCotton(),
                filters = cotton.get('filters');
            filters.sort(function(a, b) {
                if (a.get('_stencilType') < b.get('_stencilType')) {
                    return -1;
                } else if (a.get('_stencilType') > b.get('_stencilType')) {
                    return 1;
                }
                return 0;
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * ForegroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.ForegroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: image, background: false // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: false // ',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ForegroundBitmapImageLayer')
         */
        _string: 'ForegroundBitmapImageLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new ForegroundBitmapImageDrawing(this);
        },

        /**
         * getToolbar
         * 
         * @access public
         * @return ForegroundBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.foregroundBitmapImage;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * ImageLayer
     * 
     * @extends Layer
     */
    window.ImageLayer = Layer.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'delete': function() {
                    this.on({
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            this.getCanvas().setSelectedLayer(false);
                            this._imageDocument.removeLayer(this);
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setChangeOperationType('scaled');
                            this.setStyles({
                                'flipX': dimensions.flipX,
                                'flipY': dimensions.flipY,
                                'left': dimensions.left,
                                'stretchX': dimensions.stretchX,
                                'stretchY': dimensions.stretchY,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        }
                    });
                },
                'locked': function() {
                    this.on({
                        'set/property/locked': function(event, locked) {
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageLayer')
         */
        _string: 'ImageLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        },

        /**
         * _getResource
         * 
         * Returns a ResourceAccessor relating to a 3rd-party resource, or else
         * false if it couldn't be found in memory.
         * 
         * @access protected
         * @return ResourceAccessor|false
         */
        _getResource: function() {
            var key = this._properties.image;
            return Stencil.getAccessor(key);
        },

        /**
         * _isResource
         * 
         * Checks whether the key specified by the image property value
         * corresponds to a 3rd-party resource, and that it's availabel in
         * memory.
         * 
         * Note that the key equaling false check is only made to accommodate
         * BackgroundBitmapImageLayer layers, which allow for this. This will
         * not ever happy with VectorImageLayer layers.
         * 
         * @access protected
         * @return Boolean
         */
        _isResource: function() {
            var key = this._properties.image;
            if (key === false) {
                return false;
            }
            if (key.match(/^asst/) === null && key.match(/^upld/) === null) {
                return this._getResource() !== false;
            }
            return false;
        },

        /**
         * valid
         * 
         * Returns whether the layer has a valid image defined. A valid image is
         * one that points to either an asset or upload record, or else resource
         * accessor. This needs to happen because it's possible that when a user
         * chooses a TNP icon or Pixabay image, something goes wrong when trying
         * to save it and change the image key for the layer from the 3rd party
         * resource id/hash to the Stencil asset. Without this check, it's
         * possible that if something does go wrong, the image document will
         * fail to be drawn.
         * 
         * So for the end user, it's possible that something might appear to be
         * "missing" for them, but it's to prevent larger issues.
         * 
         * In real life, this could happen in the following situation:
         * They click an icon from the search results, and it gets added to the
         * canvas. If something breaks on the server side and the resource can't
         * be saved as an asset, the user will then see the ErrorModal view.
         * After this, they'll reload the page, with an image document that has
         * a layer, which in turn has an image-property referencing a TNP or
         * Pixabay resource. That is when this method is useful; it will ensure
         * that the canvas is still drawn, simply by "skipping" over the defunkt
         * layer (this "skipping" logic is done elsewhere).
         * 
         * Note that if the above situation does occur, it's possible for the
         * layer not to be marked as defunkt, because if the ImageAccessor's
         * <saveConfiguration> method doesn't fire before the ErrorModal UI
         * kills the app, the layer won't actually be saved to the DB. But it is
         * possible, if for instance it takes a long time to save the resource.
         * In that case, the ImageAccessor's saveConfiguration method may have
         * fired, thus saving to the DB, and thus turning the image defunkt.
         * 
         * Another possible case is if the user chooses a Pixabay image, and
         * closes the app before the /save call has gone out, but after the
         * PATCH call has. In that case, the draft is referencing a resource, so
         * when they revisit the app, it could break unless this validiation
         * method is called.
         * 
         * After checking for an asset or upload (via the /^asst/ and /^upld/
         * regular expressions), I check if the image is an accessor on the
         * page, since if the user very-quickly adds a resource to the canvas,
         * and before it's saved as an asset, tries to download the image, the
         * Ghost canvas will be referencing a resource (eg. TheNounProject:123),
         * which is valid, since it's in memory. This therefore needs to pass.
         * 
         * Also note that if the image is invalid, I set the image-property to
         * false. This is to ensure in the next image-saveConfiguration call
         * that goes out, the json for the image no longer references a defunkt
         * image property.
         * 
         * @access public
         * @return Boolean
         */
        valid: function() {
            var key = this._properties.image;
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                return true;
            }
            if (Stencil.getAccessor(key) !== false) {
                return true;
            }
            this.log('Layer marked as invalid', true);
            this.setProperty('image', false);
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * RectangleLayer
     * 
     * @extends Layer
     */
    window.RectangleLayer = Layer.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'RectangleLayer')
         */
        _string: 'RectangleLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * TextLayer
     * 
     * @fires   change/fontFamily
     *          change/backdropColor
     *          change/fontSize
     *          change/bold
     *          change/italic
     *          change/underline
     *          change/align
     *          change/textColor
     *          change/text
     *          change/strokeColor
     * @extends Layer
     */
    window.TextLayer = Layer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: text // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: text // ',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'align': function() {
                    this.on({
                        'change/align': function(event, align) {
                            if (this.getStyle('align') !== align) {
                                this.setChangeOperationType('aligned:' + (align));
                            }
                            this.setStyle('align', align);
                        }
                    });
                },
                'backdropColor': function() {
                    this.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var backdropAdded = this.getStyle('backdropColor') === false;
                            if (backdropAdded === true) {
                                this.setChangeOperationType('backdrop:colorAdded');
                            } else {
                                this.setChangeOperationType('backdrop:colorChanged');
                            }
                            this.setStyle('backdropColor', backdropColor);
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            this.setChangeOperationType('backdrop:stretchChanged');
                            this.setStyle('backdropStretch', backdropStretch);
                        },
                        'clear/backdropColor': function(event) {
                            this.setChangeOperationType('backdrop:removed');
                            this.setStyle('backdropColor', false);
                        }
                    });
                },
                'bold': function() {
                    this.on({
                        'change/bold': function(event, bold) {
                            this.setStyle('bold', bold === true);
                            var changeName = 'bold:' + (
                                bold === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/bold': function(event) {
                            this.setStyle('bold', false);
                        }
                    });
                },
                /**
                 * Notice tht I'm accessing the fonts dropdown, and initiating a
                 * close call against it. This is because it's possible that a
                 * user selects a text layer, opens up the fonts drop down, and
                 * then presses the delete key on their keyboard. In this case,
                 * it's important to ensure the fonts dropdown is closed.
                 */
                'delete': function() {
                    this.on({
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            this.getCanvas().setSelectedLayer(false);
                            this._imageDocument.removeLayer(this);
                            Toolbars.text.getFontsDropdown().close();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setStyles({
                                'left': dimensions.left,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        },
                        'refresh/dimensions': function(event) {
                            var dimensions = this._drawing.getDimensions();
                            this.triggerHandler(
                                'change/dimensions',
                                dimensions
                            );
                        }
                    });
                },
                'fontFamily': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access private
                         * @param  Object event
                         * @param  FontAccessor font
                         * @return void
                         */
                        'change/fontFamily': function(event, font) {
                            this.setChangeOperationType('fontFamilyChanged');
                            var fontFamily = font.get('familyName');
                            this.setStyle('fontFamily', fontFamily);
                        }
                    });
                },
                'fontSize': function() {
                    this.on({
                        'change/fontSize': function(event, fontSize) {
                            this.setChangeOperationType('fontSizeChanged');
                            this.setStyle('fontSize', fontSize);
                        }
                    });
                },
                'italic': function() {
                    this.on({
                        'change/italic': function(event, italic) {
                            this.setStyle('italic', italic === true);
                            var changeName = 'italic:' + (
                                italic === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/italic': function(event) {
                            this.setStyle('italic', false);
                        }
                    });
                },
                'lineHeight': function() {
                    this.on({
                        'change/lineHeight': function(event, lineHeight) {
                            this.setChangeOperationType('lineHeightChanged');
                            this.setStyle('lineHeight', lineHeight);
                        }
                    });
                },
                'shadowStrength': function() {
                    this.on({
                        'change/shadowStrength': function(event, shadowStrength) {
                            if (shadowStrength.toInt() === 0) {
                                ChangeHistory.clearOperationType();
                                this.setChangeOperationType('shadowStrength:removed');
                            } else {
                                if (this.getStyle('shadowStrength').toInt() === 0) {
                                    this.setChangeOperationType('shadowStrength:added');
                                } else {
                                    this.setChangeOperationType('shadowStrength:changed');
                                }
                            }
                            this.setStyle(
                                'shadowStrength',
                                shadowStrength.toInt()
                            );
                        }
                    });
                },
                'strokeColor': function() {
                    this.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var strokeAdded = this.getStyle('strokeColor') === false;
                            if (strokeAdded === true) {
                                this.setChangeOperationType('strokeColor:added');
                            } else {
                                this.setChangeOperationType('strokeColor:changed');
                            }
                            this.setStyle('strokeColor', strokeColor);
                        },
                        'clear/strokeColor': function(event) {
                            this.setChangeOperationType('strokeColor:removed');
                            this.setStyle('strokeColor', false);
                        }
                    });
                },
                'text': function() {
                    this.on({
                        'change/text': function(event, text) {
                            this.setChangeOperationType('text:changed');
                            this.setProperty('text', text);
                        }
                    });
                },
                'textColor': function() {
                    this.on({
                        'change/textColor': function(event, textColor) {
                            this.setChangeOperationType('textColorChanged');
                            this.setStyle('textColor', textColor);
                        }
                    });
                },
                'underline': function() {
                    this.on({
                        'change/underline': function(event, underline) {
                            this.setStyle('underline', underline === true);
                            var changeName = 'underline:' + (
                                underline === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TextLayer')
         */
        _string: 'TextLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new TextDrawing(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageLayer', function() {

    /**
     * VectorImageLayer
     * 
     * @extends ImageLayer
     */
    window.VectorImageLayer = ImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, vector: true // ',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'fillColor': function() {
                    this.on({
                        'change/fillColor': function(event, fillColor) {
                            this.setChangeOperationType('fillColor:changed');
                            this.setStyle('fillColor', fillColor);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'VectorImageLayer')
         */
        _string: 'VectorImageLayer',

        /**
         * init
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new VectorImageDrawing(this);
            this._listenForTheNounProjectSave();
            this._setupTheNounProjectSave();
        },

        /**
         * _listenForTheNounProjectSave
         * 
         * Listeners for a save event against a TNP resource, and swaps out the
         * image key once returned if the layer has not been deleted.
         * 
         * @access protected
         * @return void
         */
        _listenForTheNounProjectSave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousyKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.get('deleted') === undefined) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousyKey,
                                newKey
                            );
                            _this.setProperty('image', newKey);
                        }
                    }
                });
            }
        },

        /**
         * _setupTheNounProjectSave
         * 
         * Triggers a /save action against a TNP icon after a globally-defined
         * delay if the layer has not been deleted. While the method <save>
         * could be called multiple times (for example, when cloning vectors),
         * it won't matter, since only one call to /save will go out at most.
         * 
         * It is important that the resource is stored as a local variable
         * before the delay, rather than be called from within there, because
         * it is possible (for example, in the case of adding an icon from TNP
         * and cloning it before it's been saved to the server) that by the time
         * the delayed-function is executed, the _getResource method points to
         * an AssetAccessor rather than a ResourceAccessor. In that case,
         * calling the save method was causing an error, since the save method
         * on an AssetAccessor is very different than on a ResoureAccessor.
         * 
         * The reason the _getResource method was pointing to the AssetAccessor
         * is because after the first icon had a /save called initiated, once
         * returned, all VectorImageLayer layers that were referencing that TNP
         * icon had their listeners triggered, and swapped out the
         * image-property for the asset. _getResource was thus pointing to an
         * AssetAccessor since it uses the _data.key property to look up the
         * accessor.
         * 
         * @access protected
         * @return void
         */
        _setupTheNounProjectSave: function() {
            if (this._isResource() === true) {
                var delay = Stencil.getSaveDelay('resource'),
                    resource = this._getResource();
                (function() {
                    if (this.get('deleted') === undefined) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * WatermarkBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.WatermarkBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access protected
         * @var    String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, watermark: true // ',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {

                /**
                 * Listener for when the WatermarkAccessor associated with this
                 * layer is deleted from an account all together. I simply
                 * trigger a delete event against the layer. The reason I ensure
                 * that the layer has not been deleted is because otherwise,
                 * deleting a watermark could result in triggering delete-events
                 * against all previously added-and-then-removed watermark
                 * layers.
                 * 
                 * Additionally, I ensure that the ImageDocument for the layer
                 * is the same as that of the draft ImageAccessor. This is to
                 * prevent updating layers belong to older ImageDocuments. That
                 * was resulting in a bug when deleting a watermark that was
                 * previously saved, but also resulted in PATCH calls against
                 * all previously saved images, since a layer within that image
                 * had been deleted.
                 */
                'delete/watermark': function() {
                    var layer = this;
                    this.getWatermark().once({
                        'delete': function(event) {
                            if (
                                Stencil.account().draft().getImageDocument() === layer.getImageDocument()
                                && layer.get('deleted') === undefined
                            ) {
                                // var uploadKey = this.get('key');
                                // ChangeHistory.syncWatermark(uploadKey);
                                layer.triggerHandler('delete');
                            }
                        }
                    });
                },

                /**
                 * The listener-key used here is just to communicate that there
                 * is a listener on the delete event, with an intention to
                 * access the draft.
                 * 
                 * When this watermark layer is deleted, I need to ensure that
                 * the draft ImageAccessor has the most up-to-date watermarks
                 * setting value. So I manage that here.
                 */
                'delete/draft': function() {
                    this.on({
                        'delete': function(event) {
                            Stencil.account().draft().setConfiguration();
                        }
                    });
                },
                'filters/sync': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/remove': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/update': function(event, obj) {
                            this.getWatermark().setFilters();
                        }
                    });
                },
                'setStyles': function() {
                    this.on({
                        'set/style': function(event, name, value, previous) {
                            this.getWatermark().setStyles();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkBitmapImageLayer')
         */
        _string: 'WatermarkBitmapImageLayer',

        /**
         * init
         * 
         * The below logic that checks whether the canvas that this layer
         * belongs to is the Ghost canvas was discovered when the following bug
         * happened:
         * After an initial save, the styles for the WatermarkAccessor were not
         * getting saved.
         * 
         * This seemed to be happening because after a save (or download, p+s,
         * or save as template), the WatermarkAccessor would reference a
         * different layer (namely, the ephemeral layer that is created for the
         * Ghost canvas). So the styles in that layer were not getting updated
         * as the user manipulated the WatermarkLayer layer.
         * 
         * Tough one to crack (level3) 
         * 
         * @access public
         * @param  Object properties
         * @param  ImageDocument imageDocument
         * @return void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new WatermarkBitmapImageDrawing(this);
            if (this.getCanvas() !== Canvases.Ghost) {
                this.getWatermark().setLayer(this);
                this.getWatermark().markStylesAsSaved();
            }
        },

        /**
         * getToolbar
         * 
         * @access public
         * @return WatermarkBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.watermarkBitmapImage;
        },

        /**
         * getWatermark
         * 
         * @access public
         * @return WatermarkAccessor
         */
        getWatermark: function() {
            return Stencil.getAccessor(this._properties.image);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * AccountModel
     * 
     * @extends Model
     */
    window.AccountModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/accounts')
         */
        _base: '/api/accounts',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AccountModel')
         */
        _string: 'AccountModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Account')
         */
        _type: 'Account',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * AssetModel
     * 
     * @extends Model
     */
    window.AssetModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/assets')
         */
        _base: '/api/assets',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AssetModel')
         */
        _string: 'AssetModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Asset')
         */
        _type: 'Asset',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * compress
         * 
         * @access public
         * @param  String key
         * @return void
         */
        compress: function(key) {
            var path = '/asset/' + (key) + '/compress',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'AssetModel', line: 56},
                url: path,
                type: 'PATCH',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('compress');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'aM65-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * BackgroundFeatureModel
     * 
     * @extends FeatureModel
     */
    window.BackgroundFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundFeatureModel')
         */
        _string: 'BackgroundFeatureModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'BackgroundFeature')
         */
        _type: 'BackgroundFeature',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * BackgroundResourceModel
     * 
     * @extends ResourceModel
     */
    window.BackgroundResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundResourceModel')
         */
        _string: 'BackgroundResourceModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'BackgroundResource')
         */
        _type: 'BackgroundResource',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Resource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StarModel', function() {

    /**
     * BackgroundStarModel
     * 
     * @extends StarModel
     */
    window.BackgroundStarModel = StarModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundStarModel')
         */
        _string: 'BackgroundStarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'BackgroundStar')
         */
        _type: 'BackgroundStar',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UploadModel', function() {

    /**
     * BackgroundUploadModel
     * 
     * @extends UploadModel
     */
    window.BackgroundUploadModel = UploadModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundUploadModel')
         */
        _string: 'BackgroundUploadModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'BackgroundUpload')
         */
        _type: 'BackgroundUpload',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Upload', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CategoryModel
     * 
     * @extends Model
     */
    window.CategoryModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/categories')
         */
        _base: '/api/categories',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CategoryModel')
         */
        _string: 'CategoryModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Category')
         */
        _type: 'Category',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ConnectionModel
     * 
     * @extends Model
     */
    window.ConnectionModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/connections')
         */
        _base: '/api/connections',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConnectionModel')
         */
        _string: 'ConnectionModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Connection')
         */
        _type: 'Connection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CouponModel
     * 
     * @extends Model
     */
    window.CouponModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/coupons')
         */
        _base: '/api/coupons',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CouponModel')
         */
        _string: 'CouponModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Coupon')
         */
        _type: 'Coupon',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CustomerModel
     * 
     * @extends Model
     */
    window.CustomerModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/customers')
         */
        _base: '/api/customers',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CustomerModel')
         */
        _string: 'CustomerModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Customer')
         */
        _type: 'Customer',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FacebookModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  connected
     *          denied
     * @extends Model
     */
    window.FacebookModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _callbacks: {},

        /**
         * _permissions
         * 
         * @notes  Breakdown of why below permissions are required
         *         user_posts       Analytics; access shared posts
         *         user_photos      Posting; post to Timeline album
         *         publish_pages    Posting; post to page
         *         manage_pages     Posting; access pages
         *         read_insights    Analytics; access posts on pages
         *         publish_action   Posting: post to profile
         * @see    https://developers.facebook.com/docs/apps/upgrading#v22tov23
         * @access protected
         * @var    Object
         */
        _permissions: {
            all: [
                'user_posts',
                'user_photos',
                'publish_pages',
                'manage_pages',
                'read_insights',
                'publish_actions'
            ],
            minimum: [
                'user_posts',
                'user_photos',
                'publish_actions'
            ]
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FacebookModel')
         */
        _string: 'FacebookModel',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * _connect
         * 
         * @todo   Add in timer so that if the busy modal doesn't go away after
         *         x seconds, give option to cancel. This can be useful for
         *         popup blockers where the window is not available, or else
         *         something goes wrong and they need to bail.
         * @todo!  Look into facebooks reauthenticate parameter. Might be a
         *         simpler way to get multiple accounts on:
         *         https://i.imgur.com/GBxeX9p.jpg
         * @access protected
         * @return void
         */
        _connect: function () {
            var _this = this;
            Stencil.ajax({
                signature: {file: 'Facebook', line: 86},
                url: '/facebook/connect',
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Track.event('Facebook connections added', {
                            _count: response.data.connections.length
                        });
                        if (response.data.connections.length === 0) {
                            Stencil.alert('facebook.logout');
                        } else {
                            var account = Stencil.account(),
                                collection = account.collection('connections'),
                                connections = collection.map(
                                    response.data.connections
                                );
                            _this.connected(connections);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'f68-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * _minimum
         * 
         * @see    https://i.imgur.com/rJ4wjwX.png
         * @access protected
         * @param  Object response
         * @return Boolean
         */
        _minimum: function (response) {
            if (response.data === undefined) {
                return false;
            }
            if (response.data.length === 0) {
                return false;
            }
            var minimum, x, y, permission;
            for (x = 0; x < this._permissions.minimum.length; x++) {
                minimum = this._permissions.minimum[x];
                for (y = 0; y < response.data.length; ++y) {
                    permission = response.data[y];
                    if (permission.permission === minimum) {
                        if (permission.status === 'granted') {
                            break;
                        }
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * connect
         * 
         * @note   Possible responses:
         *         Object {authResponse: null, status: "not_authorized"}
         *         Object {authResponse: undefined, status: undefined}
         * @note   I do a second call to determine the permissions because the
         *         documented <return_scopes> parameter does not always work. If
         *         it did, I could simply rely on the response from Facebook to
         *         check if the minimum permissions were granted.
         * @access public
         * @param  Object callbacks
         * @return void
         */
        connect: function (callbacks) {
            this._callbacks = callbacks;
            var _this = this,
                permissions = this._permissions.all,
                login = function(response) {
                    if (
                        response.authResponse !== null
                        && response.authResponse !== undefined
                    ) {
                        FB.api('/me/permissions', function(response) {
                            if (_this._minimum(response) === true) {
                                _this._connect();
                            } else {
                                Stencil.alert('facebook.auth.minimum');
                                _this.denied();
                            }
                        });
                        // var granted = response.authResponse.grantedScopes.split(
                        //     ','
                        // );
                        // if (_this._minimum(granted) === true) {
                        //     _this._connect();
                        // } else {
                        //     _this.denied();
                        // }
                        // // StencilBooter.log(response);
                        // // see https://i.imgur.com/4mXm6s2.png
                        // // Object {authResponse: undefined, status: undefined}
                    } else {
                        _this.denied();
                    }
                };
            // App.getBusy().show();
            Scripts.load('facebook', function() {
                // App.getBusy().hide();
                FB.login(
                    login,
                    {
                        auth_type: 'rerequest',
                        scope: permissions.join(','),
                        enable_profile_selector: true,
                        return_scopes: true
                    }
                );
            });
        },

        /**
         * connected
         * 
         * @access public
         * @param  Array connections
         * @return void
         */
        connected: function (connections) {
            if (this._callbacks.connected) {
                this._callbacks.connected.call(this, connections);
            }
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access public
         * @return void
         */
        denied: function () {
            if (this._callbacks.denied) {
                this._callbacks.denied.call(this);
            }
            this.triggerHandler('denied');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FeatureModel
     * 
     * @extends Model
     */
    window.FeatureModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/features')
         */
        _base: '/api/features',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FeatureModel')
         */
        _string: 'FeatureModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Feature')
         */
        _type: 'Feature',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FontModel
     * 
     * @extends Model
     */
    window.FontModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/fonts')
         */
        _base: '/api/fonts',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FontModel')
         */
        _string: 'FontModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Font')
         */
        _type: 'Font',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access public
         * @param  Object data
         * @param  Function callback
         * @param  Function failed
         * @return void
         */
        create: function(data, callback, failed) {
            var path = this._base;
            Stencil.ajax({
                signature: {file: 'Model', line: 56},
                url: path,
                type: 'POST',
                data: data || {},
                timeout: 60 * 1000,
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        if (failed !== undefined) {
                            failed(response);
                        } else {
                            var error = Stencil.extractError(response),
                                code = 'f69-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FrameModel
     * 
     * @extends Model
     */
    window.FrameModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/frames')
         */
        _base: '/api/frames',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FrameModel')
         */
        _string: 'FrameModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Frame')
         */
        _type: 'Frame',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * GoogleFontModel
     * 
     * @extends Model
     */
    window.GoogleFontModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/googleFonts')
         */
        _base: '/api/googleFonts',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GoogleFontModel')
         */
        _string: 'GoogleFontModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'GoogleFont')
         */
        _type: 'GoogleFont',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * import
         * 
         * @note   Extended timeout since fonts need to be converted
         * @access public
         * @param  GoogleFontAccessor accessor
         * @return void
         */
        import: function(accessor) {
            var path = '/googleFonts/import';
            Stencil.ajax({
                signature: {file: 'GoogleFontModel', line: 53},
                url: path,
                type: 'POST',
                data: accessor.data(),
                timeout: 60 * 1000,
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('import', response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'gF64-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * GraphicFeatureModel
     * 
     * @extends FeatureModel
     */
    window.GraphicFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicFeatureModel')
         */
        _string: 'GraphicFeatureModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'GraphicFeature')
         */
        _type: 'GraphicFeature',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * GraphicResourceModel
     * 
     * @extends ResourceModel
     */
    window.GraphicResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicResourceModel')
         */
        _string: 'GraphicResourceModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'GraphicResource')
         */
        _type: 'GraphicResource',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Resource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StarModel', function() {

    /**
     * GraphicStarModel
     * 
     * @extends StarModel
     */
    window.GraphicStarModel = StarModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicStarModel')
         */
        _string: 'GraphicStarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'GraphicStar')
         */
        _type: 'GraphicStar',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UploadModel', function() {

    /**
     * GraphicUploadModel
     * 
     * @extends UploadModel
     */
    window.GraphicUploadModel = UploadModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicUploadModel')
         */
        _string: 'GraphicUploadModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'GraphicUpload')
         */
        _type: 'GraphicUpload',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Upload', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ImageModel
     * 
     * @extends Model
     */
    window.ImageModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/images')
         */
        _base: '/api/images',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageModel')
         */
        _string: 'ImageModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Image')
         */
        _type: 'Image',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * compress
         * 
         * @access public
         * @param  String key
         * @return void
         */
        compress: function(key) {
            var path = '/images/' + (key) + '/compress',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 56},
                url: path,
                type: 'PATCH',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('compress');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM65-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * draft
         * 
         * @access public
         * @param  String key
         * @param  Function callback
         * @return void
         */
        // draft: function(key, callback) {
        //     // var model = Stencil.getModel('Template');
        //     // model.create({
        //     //     image: key
        //     // }, callback);
        // },

        /**
         * generateShortUrl
         * 
         * @access public
         * @param  String key
         * @return void
         */
        generateShortUrl: function(key) {
            var path = '/images/' + (key) + '/shortUrl',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 98},
                url: path,
                type: 'POST',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        // accessor.set({
                        //     legacyImporting: 0,
                        //     legacyImported: 1,
                        //     legacyNormalized: 1,
                        //     width: response.data.object.width,
                        //     height: response.data.object.height,
                        //     'settings.json': response.data.object.settings.json
                        // });
                        accessor.set({
                            'settings.shortUrl': response.data.object.settings.shortUrl
                        })
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM115-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getImageById
         * 
         * @access public
         * @param  Number imageId
         * @return ImageAccessor|false
         */
        getImageById: function(imageId) {
            var accessors = Stencil.get('accessors'),
                index, accessor;
            for (index in accessors) {
                accessor = accessors[index];
                if (accessor.get('class') !== 'image') {
                    continue;
                }
                if (accessor.get('id').toInt() === imageId.toInt()) {
                    return accessor;
                }
            }
            return false;
        },

        /**
         * markAsUploaded
         * 
         * @access public
         * @param  String key
         * @return void
         */
        markAsUploaded: function(key) {
            var path = '/images/' + (key) + '/uploaded',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 135},
                url: path,
                type: 'POST',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        // accessor.set({
                        //     legacyImporting: 0,
                        //     legacyImported: 1,
                        //     legacyNormalized: 1,
                        //     width: response.data.object.width,
                        //     height: response.data.object.height,
                        //     'settings.json': response.data.object.settings.json
                        // });
                        accessor.set({
                            'settings.shortUrl': response.data.object.settings.shortUrl
                        })
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM115-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * normalize
         * 
         * @access public
         * @param  String key
         * @return void
         */
        normalize: function(key) {
            var path = '/images/' + (key) + '/normalize',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 69},
                url: path,
                type: 'PATCH',
                data: {
                    json: accessor.setting('json')
                },
                success: function(response) {
                    if (response.success === true) {
                        accessor.set({
                            legacyImporting: 0,
                            legacyImported: 1,
                            legacyNormalized: 1,
                            width: response.data.object.width,
                            height: response.data.object.height,
                            'settings.json': response.data.object.settings.json
                        });
                        accessor.triggerHandler('normalize');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM78-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * template
         * 
         * @access public
         * @param  String key
         * @param  Function callback
         * @return void
         */
        template: function(key, callback) {
            var model = Stencil.getModel('Template');
            model.create({
                image: key
            }, callback);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StarModel', function() {

    /**
     * ImageStarModel
     * 
     * @extends StarModel
     */
    window.ImageStarModel = StarModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageStarModel')
         */
        _string: 'ImageStarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'ImageStar')
         */
        _type: 'ImageStar',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Image', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * Model
     * 
     * @extends Simple
     */
    window.Model = Simple.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '')
         */
        _base: '',

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'model')
         */
        _handlerType: 'model',

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Model')
         */
        _string: 'Model',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access public
         * @param  Object data
         * @param  Function callback
         * @param  Function failed
         * @return void
         */
        create: function(data, callback, failed) {
            var path = this._base;
            Stencil.ajax({
                signature: {file: 'Model', line: 64},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        if (failed !== undefined) {
                            failed(response);
                        } else {
                            var error = Stencil.extractError(response),
                                code = 'm86-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        },

        /**
         * delete
         * 
         * @access public
         * @param  String key
         * @param  Function callback
         * @return void
         */
        delete: function(key, callback) {
            var path = (this._base) + '/' + (key);
            Stencil.ajax({
                signature: {file: 'Model', line: 105},
                url: path,
                type: 'DELETE',
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm123-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * feature
         * 
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        feature: function(key, data, callback) {
            var path = (this._base) + '/' + (key) + '/feature';
            Stencil.ajax({
                signature: {file: 'Model', line: 146},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm164-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getBase
         * 
         * @access public
         * @return void
         */
        getBase: function() {
            return this._base;
        },

        /**
         * read
         * 
         * @access public
         * @param  String key
         * @param  Function callback
         * @return void
         */
        read: function(key, callback) {
            var path = (this._base) + '/' + (key);
            Stencil.ajax({
                signature: {file: 'Model', line: 197},
                url: path,
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm214-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            if (data === undefined) {
                console.trace();
            }
            return Stencil.setAccessor(data.key, this._type, data);
        },

        /**
         * star
         * 
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        star: function(key, data, callback) {
            var path = (this._base) + '/' + (key) + '/star';
            data = data || {};
            Stencil.ajax({
                signature: {file: 'Model', line: 253},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm269-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * unfeature
         * 
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        unfeature: function(key, data, callback) {
            var path = (this._base) + '/' + (key) + '/feature';
            Stencil.ajax({
                signature: {file: 'Model', line: 295},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm310-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * unstar
         * 
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        unstar: function(key, data, callback) {
            var path = (this._base) + '/' + (key) + '/star';
            Stencil.ajax({
                signature: {file: 'Model', line: 337},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm351-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * update
         * 
         * @note   The complicated callback event triggering is to faciliate
         *         events for individual settings being updated. See:
         *         https://i.imgur.com/Tr1UDre.png
         *         Goal is to have change/[name] and update/[name] match
         * @todo   Deprecate callbacks, and instead use events.
         * @todo   Passing in accessor seems redundant, since the key is already
         *         being passed. Instead, use the key to access the accessor,
         *         and fire corresponding event(s).
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Accessor accessor
         * @param  Object callbacks
         * @return void
         */
        update: function(key, data, accessor, callbacks) {
            var path = (this._base) + '/' + (key);
            Stencil.ajax({
                signature: {file: 'Model', line: 301},
                url: path,
                type: 'PATCH',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callbacks.success.apply(accessor, [response.data]);
                        jQuery.each(data, function(index1, value1) {
                            if (typeof value1 === 'object') {
                                jQuery.each(value1, function(index2, value2) {
                                    var event = 'update/' + (index1) + '.' + (index2);
                                    accessor.triggerHandler(event, [value2]);
                                });
                            } else {
                                var event = 'update/' + (index1);
                                accessor.triggerHandler(event, [value1]);
                            }
                        });
                        accessor.triggerHandler('update', [data]);
                    } else {
                        if (callbacks.error(response) === true) {
                            var error = Stencil.extractError(response),
                                code = 'm324-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * PromoModel
     * 
     * @extends Model
     */
    window.PromoModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/promos')
         */
        _base: '/api/promos',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoModel')
         */
        _string: 'PromoModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Promo')
         */
        _type: 'Promo',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * PromoSetModel
     * 
     * @extends Model
     */
    window.PromoSetModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/promoSets')
         */
        _base: '/api/promoSets',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoSetModel')
         */
        _string: 'PromoSetModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'PromoSet')
         */
        _type: 'PromoSet',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * QuoteFeatureModel
     * 
     * @extends FeatureModel
     */
    window.QuoteFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteFeatureModel')
         */
        _string: 'QuoteFeatureModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'QuoteFeature')
         */
        _type: 'QuoteFeature',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * QuoteResourceModel
     * 
     * @extends ResourceModel
     */
    window.QuoteResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteResourceModel')
         */
        _string: 'QuoteResourceModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'QuoteResource')
         */
        _type: 'QuoteResource',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'QuoteResource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StarModel', function() {

    /**
     * QuoteStarModel
     * 
     * @extends StarModel
     */
    window.QuoteStarModel = StarModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteStarModel')
         */
        _string: 'QuoteStarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'QuoteStar')
         */
        _type: 'QuoteStar',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            var name = 'Upload';
            if (data.class === 'asset') {
                name = 'Asset';
            }
            return Stencil.setAccessor(data.key, name, data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ResourceModel
     * 
     * @extends Model
     */
    window.ResourceModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/resources')
         */
        _base: '/resources',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ResourceModel')
         */
        _string: 'ResourceModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Resource')
         */
        _type: 'Resource',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * save
         * 
         * @note   This method is in the ResourceModel instead of Model, since
         *         at the moment it's always used by resources.
         * @access public
         * @param  String key
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        save: function(key, data, callback) {
            var _this = this,
                path = (this._base) + '/' + (key) + '/save';
            Stencil.ajax({
                signature: {file: 'Resource', line: 59},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'r68-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * S3UploadModel
     * 
     * @extends Model
     */
    window.S3UploadModel = Model.extend({

        /**
         * _bucket
         * 
         * @access protected
         * @var    String (default: false)
         */
        _bucket: false,

        /**
         * _identityPool
         * 
         * @note   Format is region:id
         * @access protected
         * @var    String (default: null)
         */
        _identityPool: null,

        /**
         * _regions
         * 
         * @access protected
         * @var    Object
         */
        _regions: {
            cognito: null,
            s3: null
        },

        /**
         * _retries
         * 
         * @access protected
         * @var    Number (default: 0)
         */
        _retries: 0,

        /**
         * _skewCheckPerformed
         * 
         * Tracks whether or not a check for possible skew within the clients
         * system time has occured.
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _skewCheckPerformed: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'S3UploadModel')
         */
        _string: 'S3UploadModel',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {

            // Ensure AWS has loaded
            if (typeof window.AWS === 'undefined') {
                Stencil.alert('dependency.failed');
                Stencil.kill();
            } else {

                // Config
                var config = Stencil.get('config');
                this._regions.cognito = config.amazon.cognito.pools.primary.region;
                this._regions.s3 = config.amazon.s3.buckets.app.region;
                this._bucket = config.amazon.s3.buckets.app.name;
                this._identityPool = (this._regions.cognito) + ':' +
                    (config.amazon.cognito.pools.primary.id);

                // Set up
                AWS.config.apiVersions = {
                    s3: '2006-03-01'
                };
                AWS.config.region = this._regions.cognito;
                AWS.config.credentials = new AWS.CognitoIdentityCredentials({
                    IdentityPoolId: this._identityPool
                });
            }
        },

        /**
         * _performSkewCheck
         * 
         * Triggers an event handler once the system time skew check has been
         * completed. If skew is found, the systemClockOffset is set to that
         * skew to ensure uploads go forward.
         * 
         * Note that I'm calling against the bucket location even though AWS
         * Support recommended doing a HEAD against the bucket, for two reasons:
         * 1. Permission for a HEAD against the bucket is called ListBucket,
         *    which grants permission to list objects (which should not be
         *    allowed for client machines).
         * 2. HEAD sends no response back, so if that fails for a reason other
         *    than RequestTimeTooSkewed, I will not know, nor will I be able to
         *    log it (since HEADs are not supposed to send any response back).
         * 
         * @access protected
         * @param  AWS.S3 s3
         * @return void
         */
        _performSkewCheck: function(s3) {
            if (this._skewCheckPerformed === true) {
                this.triggerHandler('skew/check/complete');
            } else {
                var _this = this;
                this._skewCheckPerformed = true;
                s3.getBucketLocation({Bucket: this._bucket}, function(err, data) {
                    if (err !== null) {
                        App.log('Skew check error', true);
                        App.log(arguments, true);
                    }
                    var clientUnixTimestamp = Date.parse(
                        this.httpResponse.headers.date
                    );
                    AWS.config.systemClockOffset = clientUnixTimestamp - new Date();
                    _this.triggerHandler('skew/check/complete');
                });
            }
        },

        /**
         * uploadData
         * 
         * @access public
         * @param  Accessor accessor
         * @param  String name
         * @param  String data
         * @return AWS.S3.ManagedUpload
         */
        uploadData: function(accessor, name, data) {
            var blob = dataURItoBlob(data);
            return this.uploadFile(accessor, name, blob);
        },

        /**
         * uploadFile
         * 
         * @access public
         * @param  Accessor accessor
         * @param  String name
         * @param  File file
         * @return Object
         */
        uploadFile: function(accessor, name, file) {
            var params = {
                    Bucket: this._bucket,
                    Key: name,
                    Body: file,
                    ContentType: file.type,
                    ACL: 'public-read'
                },
                s3 = new AWS.S3({
                    region: this._regions.s3,
                    maxRetries: this._retries,
                    httpOptions: {
                        // timeout: 2 * 60 * 1000
                        timeout: 4 * 60 * 1000
                    }
                }),
                push = new AWS.S3.ManagedUpload({
                    params: params,
                    service: s3
                });//,
                // uploads = Stencil.get('s3.uploads');
            // uploads.push(push);
            if (file.size === 0) {
                return {
                    success: false,
                    failedRules: [{
                        key: 'upload.filesize.zero'
                    }]
                };
            }
            push.on(
                'httpUploadProgress',
                function(event) {
                    accessor.triggerHandler(
                        'upload/progress',
                        [event.loaded, event.total]
                    );
                }
            );
            this.once({
                'skew/check/complete': function(event) {
                    push.send(
                        function(err, data) {

                            // Connection clearing
                            // jQuery.each(uploads, function(index, connection) {
                            //     if (connection === push) {
                            //         uploads.splice(index, 1);
                            //     }
                            // });

                            // Triggers
                            if (data) {
                                accessor.triggerHandler('upload/success', [data]);
                            } else {
                                if (err.code === 'RequestAbortedError') {
                                    accessor.triggerHandler('upload/abort', [err]);
                                } else {
                                    App.log('S3 Upload error', true);
                                    App.log(arguments, true);
                                    accessor.triggerHandler('upload/error', [err]);
                                }
                            }
                        }
                    );
                }
            });
            this._performSkewCheck(s3);
            return {
                success: true,
                response: {
                    managedUpload: push
                }
            };
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ShareModel
     * 
     * @extends Model
     */
    window.ShareModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/shares')
         */
        _base: '/api/shares',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ShareModel')
         */
        _string: 'ShareModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Share')
         */
        _type: 'Share',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * StarModel
     * 
     * @extends Model
     */
    window.StarModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/stars')
         */
        _base: '/api/stars',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StarModel')
         */
        _string: 'StarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Star')
         */
        _type: 'Star',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * TemplateModel
     * 
     * @extends Model
     */
    window.TemplateModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/templates')
         */
        _base: '/api/templates',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateModel')
         */
        _string: 'TemplateModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Template')
         */
        _type: 'Template',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * TemplateFeatureModel
     * 
     * @extends FeatureModel
     */
    window.TemplateFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateFeatureModel')
         */
        _string: 'TemplateFeatureModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'TemplateFeature')
         */
        _type: 'TemplateFeature',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Template', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StarModel', function() {

    /**
     * TemplateStarModel
     * 
     * @extends StarModel
     */
    window.TemplateStarModel = StarModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateStarModel')
         */
        _string: 'TemplateStarModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'TemplateStar')
         */
        _type: 'TemplateStar',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (data) {
            return Stencil.setAccessor(data.key, 'Template', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * TwitterModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  closed
     *          connected
     *          denied
     * @extends Model
     */
    window.TwitterModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _callbacks: {},

        /**
         * _reference
         * 
         * @access protected
         * @var    Window (default: null)
         */
        _reference: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TwitterModel')
         */
        _string: 'TwitterModel',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * _listenForWindowClose
         * 
         * @access protected
         * @return void
         */
        _listenForWindowClose: function () {
            var interval,
                check = function() {
                    if (this._reference.closed === true) {
                        jQuery.intervalPool.clear(interval);
                        this.closed();
                    }
                };
            interval = check.interval(100, this);
        },

        /**
         * closed
         * 
         * @access public
         * @return void
         */
        closed: function () {
            if (this._callbacks.closed) {
                this._callbacks.closed.call(this);
            }
            this.triggerHandler('closed');
        },

        /**
         * connect
         * 
         * @access public
         * @param  Object callbacks
         * @return void
         */
        connect: function (callbacks) {
            this._callbacks = callbacks;
            this._reference = window.open(
                '/twitter/redirect',
                'Twitter Connect',
                'width=640, height=420'
            );
            this._listenForWindowClose();
        },

        /**
         * connected
         * 
         * @access public
         * @param  Object response
         * @return void
         */
        connected: function (response) {
            var account = Stencil.account(),
                collection = account.collection('connections'),
                connections = collection.map(response.data.connections);
            if (this._callbacks.connected) {
                this._callbacks.connected.call(this, connections);
            }
            Track.event('Twitter connection added');
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access public
         * @return void
         */
        denied: function () {
            if (this._callbacks.denied) {
                this._callbacks.denied.call(this);
            }
            this.triggerHandler('denied');
        },

        /**
         * setup
         * 
         * @access public
         * @return void
         */
        setup: function () {
            var key = 'twitter.connection.connected';
            Stencil.set(key, this.connected.proxy(this));
            key = 'twitter.connection.denied';
            Stencil.set(key, this.denied.proxy(this));
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UploadModel
     * 
     * @extends Model
     */
    window.UploadModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/uploads')
         */
        _base: '/api/uploads',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UploadModel')
         */
        _string: 'UploadModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Upload')
         */
        _type: 'Upload',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * compress
         * 
         * @access public
         * @param  String key
         * @return void
         */
        compress: function(key) {
            var path = '/upload/' + (key) + '/compress',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'UploadModel', line: 56},
                url: path,
                type: 'PATCH',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('compress');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'uM64-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * sync
         * 
         * Calls /sync against the upload in order to have the width/height of
         * the upload stored in the database, but more importantly, initiated by
         * the server side (instead of downloading the S3-stored image to the
         * client-side, checking the width/height, and then sending that over to
         * the db).
         * 
         * The reason I switched to this approach is I didn't want the user to
         * upload a large (eg. greater than 1mb) image, just to re-download it
         * so that I could store the width/height. The front-end is so finely
         * tuned now that they'll likely never need to reference the original
         * upload, so it just seems like a waste.
         * 
         * @access public
         * @param  String key
         * @return void
         */
        sync: function(key) {
            var _this = this,
                path = (this._base) + '/' + (key) + '/sync';
            Stencil.ajax({
                signature: {file: 'Upload', line: 67},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        var upload = Stencil.getAccessor(key);
                        upload.merge(response.data.object);
                        upload.triggerHandler(
                            'sync/complete',
                            [response.data]
                        );
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'u73-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UpgradeModel
     * 
     * @extends Model
     */
    window.UpgradeModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/upgrades')
         */
        _base: '/api/upgrades',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UpgradeModel')
         */
        _string: 'UpgradeModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Upgrade')
         */
        _type: 'Upgrade',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UserModel
     * 
     * @extends Model
     */
    window.UserModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/users')
         */
        _base: '/api/users',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UserModel')
         */
        _string: 'UserModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'User')
         */
        _type: 'User',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UserAccountModel
     * 
     * @extends Model
     */
    window.UserAccountModel = Model.extend({

        /**
         * _base
         * 
         * @access protected
         * @var    String (default: '/api/userAccounts')
         */
        _base: '/api/userAccounts',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UserAccountModel')
         */
        _string: 'UserAccountModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'UserAccount')
         */
        _type: 'UserAccount',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UploadModel', function() {

    /**
     * WatermarkModel
     * 
     * @extends UploadModel
     */
    window.WatermarkModel = UploadModel.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkModel')
         */
        _string: 'WatermarkModel',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'Watermark')
         */
        _type: 'Watermark',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * Accessor
     * 
     * @events  delete     
     *          change    When a property or setting is changed (any)
     *          change/<> When a specific property or setting is changed
     *          save      When a property/setting or group of them start to be
     *                    sent to the server
     *          update    After a property/setting or group of them has been
     *                    updated on the backend (aka. patched)
     * @extends Simple
     */
    window.Accessor = Simple.extend({

        /**
         * _collections
         * 
         * Hash map of collections that the accessor may have attributed with
         * it. For example, an Account has frames, connections, and watermarks.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _collections: {},

        /**
         * _data
         * 
         * The public data returned for this accessor.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _data: {},

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'accessor')
         */
        _handlerType: 'accessor',

        /**
         * _logEvents
         * 
         * Whether or not events should be logged to the console.
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _model
         * 
         * Reference to the model responsible for CRUD operations on the
         * accessor.
         * 
         * @access protected
         * @var    Model (default: null)
         */
        _model: null,

        /**
         * _references
         * 
         * Hash of other accessors attribute with this Accessor. For example,
         * AccountAccessor's have a <draft> Accessor referenced to it, which is
         * an ImageAccessor for the image they're creating.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _references: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Accessor')
         */
        _string: 'Accessor',

        /**
         * _within
         * 
         * Array of collections that the Accessor is part of. For example, a
         * WatermarkAccessor is part of the WatermarksCollection. This is used
         * in the deletion process of an accessor, to ensure it's properly
         * removed from associated collections.
         * 
         * @access protected
         * @var    Array
         */
        _within: [],

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super();
            this._collections = {};
            this._references = {};
            this._within = [];
            this._data = data;
        },

        /**
         * collection
         * 
         * Returns the collection stored at <key> in the hash.
         * 
         * @access public
         * @param  String key
         * @return Collection
         */
        collection: function(key) {
            return this._collections[key];
        },

        /**
         * data
         * 
         * @access public
         * @return Object
         */
        data: function() {
            return this._data;
        },

        /**
         * delete
         * 
         * @note   Order below matters: delete needs to happen before collection
         *         removal
         * @access public
         * @return void
         */
        delete: function() {
            this.set({
                'deleted': true
            });
            Stencil.features.remove(this);
            // DOOOO
            Stencil.stars.remove(this);
            this._model.delete(this._data.key);
            this.triggerHandler('delete');
            this.removeAll();
        },

        /**
         * deleted
         * 
         * @access public
         * @return Boolean
         */
        deleted: function() {
            return this._data.deleted === true;
        },

        /**
         * featured
         * 
         * @access  public
         * @return  Boolean
         */
        featured: function() {
            var features = Stencil.get('features');
            return features.indexOf(this._data.key) !== -1;
        },

        /**
         * featuredInAnyCategory
         * 
         * @access public
         * @return Boolean
         */
        featuredInAnyCategory: function() {
            var categories = Stencil.get('categories').all(),
                index, features;
            for (index in categories) {
                features = categories[index].get('features');
                if (jQuery.inArray(this._data.key, features) !== -1) {
                    return true;
                }
            }
            return false;
        },

        /**
         * featuredInCategory
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features');
            return jQuery.inArray(this._data.key, features) !== -1;
        },

        /**
         * get
         * 
         * @param  String key
         * @return mixed
         */
        get: function(key) {
            // if (this._data[key] === undefined) {
            //     throw new Error('Invalid key: ' + (key));
            // }
            return this._data[key];
        },

        /**
         * merge
         * 
         * Merges passed in data with the internal <_data> hash.
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        merge: function(data) {
            this._data = jQuery.extend(true, {}, this._data, data);
        },

        /**
         * push
         * 
         * Performs a set and save, so long as the initial value that is being
         * set for a key is different than what's already stored in memory.
         * This is a more performant way of doing things, since it'll prevent
         * server calls if the key is already set to the value. Currently
         * being used with UserAccount settings.
         * 
         * Note that I called it key instead of column, since it could be a
         * setting (eg. settings.name) that is being pushed.
         * 
         * @todo    Update this so it can accept a hash of properties / values.
         *          Once you do that, update ImageAccessor.sync method to
         *          prevent making calls with extraneous data (eg. the frame
         *          changed, but the json didn't. In that case, no point sending
         *          the json to the server and requiring the server to check if
         *          something has changed or not).
         * @access  public
         * @param   String key
         * @param   String value
         * @return  void
         */
        push: function(key, value) {
            var current;
            if (key.indexOf('settings.') === -1) {
                current = this._data[key];
            } else {
                current = this._data.settings[key.split('settings.').pop()];
            }
            if (current !== value) {
                this.set(key, value);
                this.save([key]);
            }
        },

        /**
         * read
         * 
         * @access public
         * @param  Function callback
         * @return void
         */
        read: function(callback) {
            var _this = this;
            this._model.read(this._data.key, function(data) {
                callback.apply(_this, [data.object]);
            });
        },

        /**
         * reference
         * 
         * Returns the reference stored at <key> in the hash.
         * 
         * @access public
         * @param  String key
         * @return Accessor
         */
        reference: function(key) {
            return this._references[key];
        },

        /**
         * removeAll
         * 
         * Removes the accessor from it's associated collections.
         * 
         * @access public
         * @return void
         */
        removeAll: function() {
            var _this = this;
            jQuery.each(this._within, function(index, collection) {
                collection.remove(_this);
            });
        },

        /**
         * save
         * 
         * @example Accessor.save('column')
         *          Accessor.save(['column1', 'column2'])
         *          Accessor.save(['settings.sub'])
         *          Accessor.save(['settings.1', 'settings.2'])
         * @access  public
         * @param   Array columns
         * @param   undefined|Object callbacks
         * @return  void
         */
        save: function(columns, callbacks) {
            var _this = this,
                data = {},
                column;

            // Format callbacks
            if (callbacks === undefined) {
                callbacks = {
                    success: function(data) {},
                    error: function(response) {
                        return true;
                    }
                };
            }
            if (callbacks.success === undefined) {
                callbacks.success = function(data) {};
            }
            if (callbacks.error === undefined) {
                callbacks.error = function(response) {
                    return true;
                };
            }

            // Ensure columns are array
            if (jQuery.isArray(columns) === false) {
                columns = [columns];
            }
            jQuery.each(columns, function(index, column) {
                if (column.indexOf('settings.') === 0) {
                    data.settings = data.settings || {};
                    column = column.split('settings.').pop();
                    data.settings[column] = _this._data.settings[column];
                } else {
                    data[column] = _this._data[column];
                }
            });
            this._model.update(this._data.key, data, this, callbacks);
            this.triggerHandler('save', [columns]);
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   String|Object key
         * @param   Number|String|undefined value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Events
            var handler,
                _this = this;
            jQuery.each(data, function(key, value) {
                handler = 'change/' + (key);
                if (key.indexOf('settings.') === 0) {
                    key = key.split('settings.').pop();
                    _this._data.settings[key] = value;
                } else {
                    _this._data[key] = value;
                }
                _this.triggerHandler(handler, [value]);
            });
            this.triggerHandler('change');
        },

        /**
         * setting
         * 
         * Returns a setting value if one is found, or else throws an error.
         * 
         * @param  String key
         * @return mixed
         */
        setting: function(key) {
            if (this._data.settings[key] === undefined) {
                throw 'Invalid key: ' + (key);
            }
            return this._data.settings[key];
        },

        /**
         * starred
         * 
         * @access  public
         * @return  Boolean
         */
        starred: function() {
            var stars = Stencil.account().get('stars'),
                key = this._data.key;
            return stars.indexOf(key) !== -1;
        },

        /**
         * swap
         * 
         * Swaps out the data for the accessor. Should only be called when an
         * ephemeral key was used, since the previous key will be deleted from
         * memory. At the moment, only used when creating a template, or when a
         * user logs in (which swaps out their temporary account data with
         * whatever is returned).
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        swap: function(data) {
            var all = Stencil.get('accessors'),
                previous = this._data.key;
            this._data = data;
            all[this._data.key] = this;
            delete all[previous];
        },

        /**
         * within
         * 
         * Stores the collection in the <within> Array, so that we can keep
         * track of where the Accessor is being used.
         * 
         * @access public
         * @param  Collection collection
         * @return void
         */
        within: function(collection) {
            this._within.push(collection);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'AccountModel'], function() {

    /**
     * AccountAccessor
     * 
     * @fires   draft/create
     * @extends Accessor
     */
    window.AccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Account'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AccountAccessor')
         */
        _string: 'AccountAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupConnections();
            this._setupDraft();
            this._setupFonts();
            this._collections.fonts.map(Stencil.get('config').defaults.fonts, true);
            this._setupFrames();
            this._collections.frames.map(Frames.all(), true);
            this._setupOrphanFrame();
            this._setupUpgrade();
            this._setupUserAccount();
            this._setupWatermarks();
        },

        /**
         * _setupConnections
         * 
         * @access protected
         * @return void
         */
        _setupConnections: function() {
            this._collections.connections = this._collections.connections || new ConnectionsCollection();
            this._collections.connections.map(this._data.connections, true);
        },

        /**
         * _setupDraft
         * 
         * @access protected
         * @return void
         */
        _setupDraft: function() {
            var model = Stencil.getModel('Image');
            this._references.draft = model.setAccessor(
                this._data.draft
            );
        },

        /**
         * _setupFonts
         * 
         * @access protected
         * @return void
         */
        _setupFonts: function() {
            this._collections.fonts = this._collections.fonts || new FontsCollection();
            this._collections.fonts.unbind('add');
            this._collections.fonts.on({

                /**
                 * (anonymous)
                 * 
                 * @access private
                 * @param  Object event
                 * @param  FontAccessor font
                 * @param  Number position
                 * @return void
                 */
                'add': function(event, font, position) {
                    if (font.get('uploaded').toInt() === 1) {
                        font.drawStyleSheet();
                    }
                }
            });

            // The following will only map an account's fonts to the collection
            var _this = this;
            jQuery.each(this._data.fonts, function(index, font) {
                if (_this._collections.fonts.find(font.key) === false) {
                    _this._collections.fonts.map(font, true);
                }
            });
        },

        /**
         * _setupFrames
         * 
         * Adds any frames that aren't yet in memory to the account's
         * FramesCollection.
         * 
         * @access protected
         * @return void
         */
        _setupFrames: function() {
            var _this = this;
            this._collections.frames = this._collections.frames || new FramesCollection();
            jQuery.each(this._data.frames, function(index, frame) {
                if (_this._collections.frames.find(frame.key) === false) {
                    _this._collections.frames.map(frame, true);
                }
            });
        },

        /**
         * _setupOrphanFrame
         * 
         * @access protected
         * @return void
         */
        _setupOrphanFrame: function() {
            var model = Stencil.getModel('Frame');
            this._references.orphanFrame = model.setAccessor({
                class: 'frame',
                type: 'orphan',
                tag: 'backup',
                key: 'frm-orphan',
                label: 'Custom',
                width: 0,
                height: 0
            });
        },

        /**
         * _setupUpgrade
         * 
         * @access protected
         * @return void
         */
        _setupUpgrade: function() {
            if (this._data.upgrade !== false) {
                var model = Stencil.getModel('Upgrade');
                this._references.upgrade = model.setAccessor(
                    this._data.upgrade
                );
            }
            Account.once({
                'upgrade': this._setupUpgrade.proxy(this)
            });
        },

        /**
         * _setupUserAccount
         * 
         * @todo!  Look into whether the login / signup events need to be added
         *         below, since if the userAccount is found, we know they're
         *         already logged in.
         * @access protected
         * @return void
         */
        _setupUserAccount: function() {
            if (this._data.userAccount !== false) {
                var model = Stencil.getModel('UserAccount');
                this._references.userAccount = model.setAccessor(
                    this._data.userAccount
                );
            }
            User.once({
                'login': this._setupUserAccount.proxy(this),
                'signup': this._setupUserAccount.proxy(this)
            });
        },

        /**
         * _setupWatermarks
         * 
         * @access protected
         * @return void
         */
        _setupWatermarks: function() {
            this._collections.watermarks = this._collections.watermarks || new WatermarksCollection();
            this._collections.watermarks.map(this._data.watermarks, true);
        },

        /**
         * cancel
         * 
         * @access public
         * @param  Boolean later
         * @param  Boolean disapproveLastCommission
         * @param  Function callback
         * @return void
         */
        cancel: function(later, disapproveLastCommission, callback) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/cancel';
            Stencil.ajax({
                signature: {file: 'Account', line: 171},
                url: path,
                type: 'POST',
                data: {
                    later: (later === true ? 1 : 0),
                    disapproveLastCommission: (
                        disapproveLastCommission === true
                        ? 1
                        : 0
                    )
                },
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'a172-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * coupon
         * 
         * Returns whether or not the account used a coupon during upgrading.
         * 
         * @access public
         * @return Boolean
         */
        coupon: function() {
            return this.upgrade() !== undefined
                && this.upgrade().get('coupon') !== false;
        },

        /**
         * createdBefore
         * 
         * @example
         *          this.createdBefore('1 day');
         *          this.createdBefore('2 weeks');
         * @access  public
         * @param   String relativeTime
         * @return  Boolean
         */
        createdBefore: function(relativeTime) {
            var period = 'seconds';
            if (relativeTime.match(/minute/) !== null) {
                period = 'minutes';
            } else if (relativeTime.match(/hour/) !== null) {
                period = 'hours';
            } else if (relativeTime.match(/day/) !== null) {
                period = 'days';
            } else if (relativeTime.match(/week/) !== null) {
                period = 'weeks';
            } else if (relativeTime.match(/month/) !== null) {
                period = 'months';
            } else if (relativeTime.match(/year/) !== null) {
                period = 'years';
            }
            var number = relativeTime.replace(/[^0-9]/, '').toInt(),
                comparisonTimestamp = moment().subtract(number, period),
                createdTimestamp = moment.unix(this._data.created);
            return createdTimestamp.isBefore(comparisonTimestamp);
        },

        /**
         * createNewDraft
         * 
         * @access public
         * @param  ImageAccessor current
         * @return ImageAccessor
         */
        createNewDraft: function(current) {
            var _this = this,
                model = Stencil.getModel('Image'),
                draft = model.setAccessor({
                    class: 'image',
                    key: random(),
                    draft: 1,
                    width: current.get('width'),
                    height: current.get('height'),
                    sourceImage: current.data(),
                    sourceImageId: current.get('id'),// careful
                    uploaded: 0,// Needed for preloading elsewhere
                    frame: current.get('frame'),
                    settings: {
                        json: current.setting('json'),
                        watermarks: current.setting('watermarks')
                    },
                    ip: Stencil.account().get('geo').ip
                });
            this._references.draft = draft;
            model.create({
                frame: draft.get('frame'),
                draft: draft.get('draft'),
                width: draft.get('width'),
                height: draft.get('height'),
                sourceImageId: draft.getSourceImage().get('id'),// careful
                settings: {
                    json: draft.setting('json'),
                    watermarks: draft.setting('watermarks')
                }
            }, function(data) {
                draft.swap(data.object);
                _this.triggerHandler('draft/create', [draft]);
            });
            return draft;
        },

        /**
         * orphanFrame
         * 
         * @access public
         * @return FrameAccessor
         */
        orphanFrame: function() {
            return this._references.orphanFrame;
        },

        /**
         * delinquent
         * 
         * Returns whether or not the account is in delinquent mode.
         * 
         * @access public
         * @return Boolean
         */
        delinquent: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('delinquent').toInt() === 1;
        },

        /**
         * draft
         * 
         * @access public
         * @return ImageAccessor
         */
        draft: function() {
            return this._references.draft;
        },

        /**
         * draftIsLocked
         * 
         * @access public
         * @return Boolean
         */
        draftIsLocked: function() {
            return this._references.draft.isLocked();
        },

        /**
         * free
         * 
         * Returns whether or not the account is both not a guest and has not
         * been upgraded.
         * 
         * @access public
         * @return Boolean
         */
        free: function() {
            return this.guest() === false
                && this.upgraded() === false
                && User.admin() === false;
        },

        /**
         * geo
         * 
         * @access public
         * @return false|Object
         */
        geo: function() {
            if (
                this._data.geo.country.code === false
                || this._data.geo.country.code === ''
            ) {
                return false;
            }
            return this._data.geo;
        },

        /**
         * getImagesRemaining
         * 
         * @note   Can return less than 0, since users can saved a bunch of
         *         images, and then downgrade.
         * @access public
         * @return Number
         */
        getImagesRemaining: function() {
            var max = this._data.monthlyMaxImages.toInt(),
                saved = this._data.monthlySavedImages.toInt(),
                bonus = this._data.bonusImages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - saved + bonus;
            if (left < 0) {
                return 0;
            }
            return max - saved + bonus;
        },

        /**
         * getReferralUrl
         * 
         * @access public
         * @return Number
         */
        getReferralUrl: function() {
            var role = Stencil.get('config').role,
                hash = {
                    local: 'https://local.getstencil.com',
                    dev: 'https://dev.getstencil.com',
                    prod: 'https://getstencil.com'
                };
            return (hash[role]) + '/a/ref/' + (this._data.key);
        },

        /**
         * getRefillDate
         * 
         * @note   There are 4 cases here, all of which are covered the same:
         *         - Guests
         *         - Free users
         *         - Upgraded users
         *         - Downgraded free users
         *         I use the account record created date
         * @access public
         * @return String
         */
        getRefillDate: function() {
            var format = 'MMMM DD, YYYY \@ h\:mm a',
                micro = this._data.refill.toInt() * 1000;
            return moment(micro).format(format);
        },

        /**
         * getSmsMessagesRemaining
         * 
         * @access public
         * @return Number
         */
        getSmsMessagesRemaining: function() {
            var max = this._data.monthlyMaxSmsMessages.toInt(),
                sent = this._data.monthlySentSmsMessages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - sent;
            if (left < 0) {
                return 0;
            }
            return max - sent;
        },

        /**
         * getStarsRemaining
         * 
         * @note   Can return less than 0, since users can star a bunch of
         *         objects, and then downgrade.
         * @access public
         * @return Number
         */
        getStarsRemaining: function() {
            var max = this._data.maxStars.toInt();
            if (max === 0) {
                return Infinity;
            }
            return max - this._data.stars.length;
        },

        /**
         * getUpgradedPath
         * 
         * Returns the path the user should be sent to after an upgrade,
         * depending on what plan and interval they chose. This is abstracted
         * here to lookup the plan and interval, but also because it's used in a
         * conventional checkout flow as well as through a redemption flow. Note
         * also that while the parameters being passed are not currently (at the
         * time of documentation) being used within the application-logic, but
         * are being used by Google Analytics for goal-conversion-tracking.
         * 
         * @access public
         * @return String
         */
        getUpgradedPath: function() {
            var plan = this.upgrade().get('plan'),
                interval = this.upgrade().get('interval'),
                gateway = this.upgrade().get('gateway'),
                path = '/app/upgraded/' + (plan) +
                    '?clean=1' +
                    '&interval=' + (interval) +
                    '&gateway=' + (gateway);
            return path;
        },

        /**
         * guest
         * 
         * Returns whether or not the account is a guest.
         * 
         * @access public
         * @return Boolean
         */
        guest: function() {
            return this._data.guest.toInt() === 1;
        },

        /**
         * max
         * 
         * @access public
         * @return Object
         */
        max: {

            /**
             * bonus
             * 
             * Returns whether or not the account has received the max number of
             * bonus images.
             * 
             * @access public
             * @return Boolean
             */
            bonus: function() {
                if (this._data.followBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.tweetBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.shareBonus.toInt() === 0) {
                    return false;
                }
                return true;
            },

            /**
             * images
             * 
             * Returns whether or not the account has saved the maximum number
             * of images (for the month). Does the check using <= (instead of
             * checking if it equals 0) since when a user is downgraded, it's
             * possible for the number remaining to be less than 0 (eg. if they
             * created 20 one month, then downgraded).
             * 
             * @access public
             * @return Boolean
             */
            images: function() {
                var remaining = this.getImagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * sms
             * 
             * @access public
             * @return Boolean
             */
            sms: function() {
                var remaining = this.getSmsMessagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * stars
             * 
             * Returns whether or not the account has starred the maximum number
             * of stars allowable. Does the check using <= (instead of checking
             * if it equals 0) since when a user is downgraded, it's possible
             * for the number remaining to be less than 0 (eg. if they starred
             * 20, then downgraded).
             * 
             * @access public
             * @return Boolean
             */
            stars: function() {
                var remaining = this.getStarsRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            }
        },

        /**
         * plan
         * 
         * Returns whether or not the account is on the passed in plan. Does not
         * check whether they are active on that plan. Use <paying> for that.
         * 
         * @access public
         * @param  String plan
         * @return Boolean
         */
        plan: function(plan) {
            if (this.guest() === true) {
                return false;
            }
            if (this.upgrade() === undefined) {
                if (plan === 'free') {
                    return true;
                }
                return false;
            }
            return this.reference('upgrade').get('plan') === plan;
        },

        /**
         * promo
         * 
         * Returns whether or not the account was upgraded via a promo code.
         * 
         * @access public
         * @return Boolean
         */
        promo: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('type') === 'promo';
        },

        /**
         * reload
         * 
         * @access public
         * @return void
         */
        reload: function() {
            this._setupConnections();
            this._setupFonts();
            this._collections.fonts.loadUploadedNormal();
            this._collections.fonts.each(function(index, font) {
                if (font.get('uploaded').toInt() === 1) {
                    Toolbars.text.getFontsDropdown().addFont(font, false);
                }
            });
            this._setupFrames();
            // this._setupDraft();
            this._setupUpgrade();
            this._setupWatermarks();
        },

        /**
         * syncRefillData
         * 
         * @access public
         * @param  Function callback
         * @return void
         */
        syncRefillData: function(callback) {
            this.read(function(data) {
                if (this.get('refill').toInt() !== data.refill.toInt()) {
                    this.set({
                        monthlySavedImages: data.monthlySavedImages.toInt(),
                        monthlySentSmsMessages: data.monthlySentSmsMessages.toInt(),
                        bonusImages: data.monthlySavedImages.toInt(),
                        refill: data.refill.toInt()
                    });
                    callback.apply(this, [true]);
                } else {
                    callback.apply(this, [false]);
                }
            });
        },

        /**
         * syncStars
         * 
         * @access public
         * @return void
         */
        syncStars: function() {

            /**
             * Backgrounds
             * 
             */

            // Get collection references
            var collections = {
                    categories: [],
                    queries: []
                },
                search = App.getEditor().getArea('backgrounds').getChild('search');
            jQuery.each(search.getChild('categories')._children, function(index, child) {
                collections.categories.push(child._collection);
            });
            jQuery.each(search.getChild('queries')._children, function(index, child) {
                collections.queries.push(child._collection);
            });

            // Check whether they're starred
            jQuery.each(collections.categories, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });
            jQuery.each(collections.queries, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });

            /**
             * Graphics
             * 
             */

            // Get collection references
            collections = {
                categories: [],
                queries: []
            };
            search = App.getEditor().getArea('graphics').getChild('search');
            jQuery.each(search.getChild('categories')._children, function(index, child) {
                collections.categories.push(child._collection);
            });
            jQuery.each(search.getChild('queries')._children, function(index, child) {
                collections.queries.push(child._collection);
            });

            // Check whether they're starred
            jQuery.each(collections.categories, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });
            jQuery.each(collections.queries, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });

            /**
             * Quotes
             * 
             */

            // Get collection references
            collections = {
                categories: [],
                queries: []
            };
            search = App.getEditor().getArea('quotes').getChild('search');
            jQuery.each(search.getChild('categories')._children, function(index, child) {
                collections.categories.push(child._collection);
            });
            jQuery.each(search.getChild('queries')._children, function(index, child) {
                collections.queries.push(child._collection);
            });

            // Check whether they're starred
            jQuery.each(collections.categories, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });
            jQuery.each(collections.queries, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });

            /**
             * Templates
             * 
             */

            // Get collection references
            collections = {
                categories: [],
                queries: []
            };
            search = App.getEditor().getArea('templates').getChild('search');
            jQuery.each(search.getChild('categories')._children, function(index, child) {
                collections.categories.push(child._collection);
            });

            // Check whether they're starred
            jQuery.each(collections.categories, function(index, collection) {
                collection.each(function(index, accessor) {
                    if (accessor.starred() === true) {
                        accessor.triggerHandler('star/ui');
                    }
                });
            });

            // Get collection
            // Don't think this is needed, since this method is only
            // called upon login, and users can't save a template without being
            // logged in
            // collection = App.getEditor().getArea('templates').getChild('saved')._collection;

            // Check whether they're starred
            // collection.each(function(index, accessor) {
            //     if (accessor.starred() === true) {
            //         accessor.triggerHandler('star/ui');
            //     }
            // });
        },

        /**
         * upgrade
         * 
         * Returns the UpgradeAccessor reference for the account, or else
         * undefined if no reference found.
         * 
         * @access public
         * @return UpgradeAccessor|undefined
         */
        upgrade: function() {
            return this._references.upgrade;
        },

        /**
         * upgraded
         * 
         * Returns whether or not the account has been upgraded. This is
         * independent of how they upgraded (eg. conventional, or through for
         * example an AppSumo deal).
         * 
         * @access public
         * @return Boolean
         */
        upgraded: function() {
            var upgrade = this.upgrade();
            if (upgrade === undefined) {
                return false;
            }
            return upgrade.get('active').toInt() === 1;
        },

        /**
         * upgradeToPlan
         * 
         * @access public
         * @param  String plan
         * @return void
         */
        upgradeToPlan: function(plan) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/upgrade';
            Stencil.ajax({
                data: {
                    plan: plan
                },
                signature: {file: 'Account', line: 881},
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'a424-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                },
                type: 'POST',
                url: path
            });
        },

        /**
         * userAccount
         * 
         * @access public
         * @return UserAccountAccessor|undefined
         */
        userAccount: function() {
            return this._references.userAccount;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'AssetModel'], function() {

    /**
     * AssetAccessor
     * 
     * @extends MediaAccessor
     */
    window.AssetAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AssetAccessor')
         */
        _string: 'AssetAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupResource();
            this.on({
                'feature': function(event, category) {
                    Track.event('Asset featured', {
                        _key: this._data.key
                    });
                },
                'star': function(event) {
                    Track.event('Asset starred', {
                        _key: this._data.key
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Asset unfeatured', {
                        _key: this._data.key
                    });
                },
                'unstar': function(event) {
                    Track.event('Asset unstarred', {
                        _key: this._data.key
                    });
                }
            });
            this.on({
                'select': function(event, type, method, locked, options) {
                    if (this._data.resourceType === 'TheNounProject') {
                        this._addTheNounProjectLayer(locked);
                    } else if (this._data.resourceType === 'Pixabay') {
                        this._setBackgroundBitmapLayer(locked);
                    } else if (this._data.resourceType === 'Pexels') {
                        this._setBackgroundBitmapLayer(locked);
                    } else if (this._data.resourceType === 'Unsplash') {
                        this._setBackgroundBitmapLayer(locked);
                    } else if (this._data.resourceType === 'AlgoliaQuote') {
                        this._addQuoteTextLayers();
                    }
                }
            });
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access protected
         * @return void
         */
        _addQuoteTextLayers: function() {
            if (JSON.valid(this._data.settings.raw) === true) {
                var raw = JSON.parse(this._data.settings.raw),
                    quotation = raw.quotation,
                    author = raw.author,
                    canvas = Canvases.Preview,
                    layers = {
                        author: canvas.addTextLayer({
                            align: 'center',
                            fontFamily: 'Leckerli One',
                            fontSize: 35,
                            text: author,
                            top: 70,
                            width: 90
                        }),
                        quotation: canvas.addTextLayer({
                            align: 'center',
                            fontFamily: Stencil.account().setting('defaultFontFamily'),
                            // fontFamily: Stencil.get('config').defaults.font,
                            fontSize: 50,
                            text: quotation,
                            top: 45,
                            width: 90
                        })
                    },
                    drawings = {
                        author: layers.author.getDrawing(),
                        quotation: layers.quotation.getDrawing()
                    };
                layers.author.setChangeOperationType('quote:added');
                drawings.author.once({
                    'draw': function(event) {
                        this.trim();
                        this.repositionRelativeTo(drawings.quotation);
                        this.animate();
                        drawings.quotation.animate();
                        drawings.quotation.select();
                        // this._cotton.trigger('changed');
                        layers.author.triggerHandler('refresh/dimensions');
                    }
                });
                drawings.quotation.once({
                    'draw': function(event) {
                        drawings.author.draw();
                    }
                });
                drawings.quotation.draw();
            } else {
                StencilBooter.log('JSON parse error (A:_aQTL)');
            }
        },

        /**
         * _addTheNounProjectLayer
         * 
         * @note   I don't call <sync> against The Noun Project assets since
         *         they're all vectors, and the only thing I want to know about
         *         them is their filesize (which I already collect on the
         *         backend).
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _addTheNounProjectLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _setBackgroundBitmapLayer
         * 
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _setBackgroundBitmapLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundImageLayer(),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('image:changed');
            layer.setImage(this._data.key);
            layer.setProperty('locked', locked);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access private
                 * @return void
                 */
                'refresh': function() {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                }
            });
            drawing.reload();
        },

        /**
         * _setupResource
         * 
         * @access protected
         * @return void
         */
        _setupResource: function() {
            var model = Stencil.getModel('Resource');
            if (this._data.resourceType === 'AlgoliaQuote') {
                model = Stencil.getModel('QuoteResource');
            }
            this._references.resource = model.setAccessor({
                class: 'resource',
                key: this.getHash(),
                platform: this._data.resourceType,
                id: this._data.resourceId
            });
        },

        /**
         * feature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        feature: function(category) {
            var type = category.get('type'),
                area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.features.add(this);
            category.features.add.apply(category, [this])
            this._model.feature(this._data.key, {
                category: category.get('id').toInt()
            }, (function(data) {
                this.triggerHandler('feature/complete');
            }).proxy(this));
            var slug = category.get('slug'),
                features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
            features.add(this, false);
            this.triggerHandler('feature', [category]);
            this._references.resource.triggerHandler('feature', [category]);
        },

        /**
         * featured
         * 
         * @access  public
         * @return  Boolean
         */
        featured: function() {
            var features = Stencil.get('features'),
                hash = this.getHash();
            return features.indexOf(hash) !== -1;
        },

        /**
         * featuredInAnyCategory
         * 
         * @access public
         * @return Boolean
         */
        featuredInAnyCategory: function() {
            var categories = Stencil.get('categories').all(),
                index, features;
            for (index in categories) {
                features = categories[index].get('features');
                if (jQuery.inArray(this.getHash(), features) !== -1) {
                    return true;
                }
            }
            return false;
        },

        /**
         * featuredInCategory
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features');
            return jQuery.inArray(this.getHash(), features) !== -1;
        },

        /**
         * getDisplayableQuotation
         * 
         * @see    http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access public
         * @return String
         */
        getDisplayableQuotation: function() {
            if (JSON.valid(this._data.settings.raw) === true) {
                var raw = JSON.parse(this._data.settings.raw);
                return raw.quotation.trimToLength(200).replace(
                    /(?:\r\n|\r|\n)/g,
                    '<br />'
                );
            }
            StencilBooter.log('JSON parse error (A:gDQ)');
            return 'error #A:gDQ';
        },

        /**
         * getHash
         * 
         * Returns a hash (as a string) of the resource type and id. Useful for
         * comparing resource keys to assets, to see if an asset is actually
         * just a saved version of a resource.
         * 
         * @access public
         * @return String
         */
        getHash: function() {
            return (this._data.resourceType) + ':' + (this._data.resourceId);
        },

        /**
         * owned
         * 
         * @access public
         * @return false
         */
        owned: function() {
            return false;
        },

        /**
         * preload
         * 
         * Contains two different flows for preloading resized resources based
         * on whether the asset is a bitmap (eg. Pixabay) or vector (eg. The
         * Noun Project). When it's a vector, for now, I'm booting in the
         * original asset, because with TNP, it's a relatively small 84x84 pixel
         * bitmap.
         * 
         * @access public
         * @param  Function success
         * @param  Function error
         * @return void
         */
        preload: function(success, error) {
            if (this._data.resourceType === 'AlgoliaQuote') {
                success = success || function(){};
                success.apply(this);
            } else {

                // Bitmaps
                var urls = [];
                if (this._data.bitmap.toInt() === 1) {
                    urls.push(this.url('thumb'));
                }
                // Vectors
                else {
                    urls.push(this.url('original'));
                }

                // Load
                success = success || function(){};
                error = error || function(){};
                Images.preload(urls, success.proxy(this), error.proxy(this));
            }
        },

        /**
         * star
         * 
         * @access public
         * @param  String type
         * @return void
         */
        star: function(type) {
            var area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.stars.add(this);
            this._model.star(this._data.key, {
                type: type
            });
            var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
            stars.add(this, false);
            this.triggerHandler('star');
            this._references.resource.triggerHandler('star');
        },

        /**
         * starred
         * 
         * @access  public
         * @return  Boolean
         */
        starred: function() {
            var stars = Stencil.account().get('stars'),
                hash = this.getHash();
            return stars.indexOf(hash) !== -1;
        },

        /**
         * unfeature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        unfeature: function(category) {
            var type = category.get('type'),
                area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.features.remove(this);
            category.features.remove.apply(category, [this])
            this._model.unfeature(this._data.key, {
                category: category.get('id').toInt()
            });
            var slug = category.get('slug'),
                features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
            features.remove(this);
            this.triggerHandler('unfeature', [category]);
            this._references.resource.triggerHandler('unfeature', [category]);
        },

        /**
         * unstar
         * 
         * @access public
         * @param  String type
         * @return void
         */
        unstar: function(type) {
            var area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.stars.remove(this);
            this._model.unstar(this._data.key, {
                type: type
            });
            var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
            stars.remove(this);
            this.triggerHandler('unstar');
            this._references.resource.triggerHandler('unstar');
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with The Noun Project icons for the
         *   preview thumbnail
         * - Thumb image url, at the moment used for Pixabay resources that have
         *   been saved as assets
         * 
         * @access public
         * @param  String type
         * @param  Object|undefined options
         * @return String|false
         */
        url: function(type, options) {
            if (type === 'original') {
                return Images.cloudinary(this._data.key, {
                    type: 'original'
                });
            } else if (type === 'thumb') {
                return Images.cloudinary(this._data.key, {
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CategoryModel'], function() {

    /**
     * CategoryAccessor
     * 
     * @extends Accessor
     */
    window.CategoryAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CategoryAccessor')
         */
        _string: 'CategoryAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on('delete', function(event) {
                Track.event('Category deleted');
            });
        },

        /**
         * features
         * 
         * @access public
         * @var    Object
         */
        features: {

            /**
             * add
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            add: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key');
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                features.push(key);
                this.set('count', this._data.count + 1);
            },

            /**
             * remove
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            remove: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key'),
                    index;
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = features.indexOf(key);
                if (index !== -1) {
                    features.splice(index, 1);
                }
                this.set('count', this._data.count - 1);
            }
        },

        /**
         * getName
         * 
         * @access public
         * @return String
         */
        getName: function() {
            if (this._data.slug === 'featured') {
                if (this._data.type === 'background') {
                    return 'Featured Backgrounds';
                }
                if (this._data.type === 'graphic') {
                    return 'Featured Icons &amp; Graphics';
                }
                if (this._data.type === 'quote') {
                    return 'Featured Quotes';
                }
                return 'Featured Templates';
            }
            return this._data.name;
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            if (this._data.type === 'background') {
                if (this._data.slug === 'featured') {
                    return '/app';
                }
                return '/app/backgrounds/' + (this._data.slug);
            }
            if (this._data.type === 'graphic') {
                if (this._data.slug === 'featured') {
                    return '/app/icons';
                }
                return '/app/icons/' + (this._data.slug);
            }
            if (this._data.type === 'quote') {
                if (this._data.slug === 'featured') {
                    return '/app/quotes';
                }
                return '/app/quotes/' + (this._data.slug);
            }
            if (this._data.slug === 'all') {
                return '/app/templates';
            }
            return '/app/templates/' + (this._data.slug);
        },

        /**
         * isActive
         * 
         * Returns whether or not this category is currently being viewed.
         * 
         * @access public
         * @return Boolean
         */
        isActive: function() {
            if (location.pathname === this.getPath()) {
                return true;
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'ConnectionModel'], function() {

    /**
     * ConnectionAccessor
     * 
     * @extends Accessor
     */
    window.ConnectionAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConnectionAccessor')
         */
        _string: 'ConnectionAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on('delete', function(event) {
                Track.event('Connection deleted');
            });
        },

        /**
         * getLabel
         * 
         * @access public
         * @return String
         */
        getLabel: function() {
            var type = this._data.type;
            if (type === 'account') {
                return 'Page';
            }
            return 'Profile';
        },

        /**
         * getImageSrc
         * 
         * @access public
         * @return String
         */
        getImageSrc: function() {
            if (this._data.network === 'twitter') {
                return this._data.image;
            }
            return this._data.image.replace(
                'graph.facebook.com/',
                'graph.facebook.com/v2.5/'
            );
        },

        /**
         * getPath
         * 
         * @throws Error
         * @access public
         * @return String
         */
        getPath: function() {
            var id = this._data.networkResourceId,
                label = this._data.label;
            switch (this._data.network) {
                case 'facebook':
                    return 'https://facebook.com/' + (id);
                case 'twitter':
                    return 'https://twitter.com/' + (label);
            }
            throw new Error('Invalid network');
        },

        /**
         * getRaw
         * 
         * @access public
         * @return Object
         */
        getRaw: function() {
            return JSON.parse(this._data.raw);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CouponModel'], function() {

    /**
     * CouponAccessor
     * 
     * @extends Accessor
     */
    window.CouponAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CouponAccessor')
         */
        _string: 'CouponAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on('delete', function(event) {
                Track.event('Coupon deleted');
            });
        },

        /**
         * trial
         * 
         * @access public
         * @return Boolean
         */
        trial: function() {
            return this._data.trial.toInt() !== 0;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CustomerModel'], function() {

    /**
     * CustomerAccessor
     * 
     * @extends Accessor
     */
    window.CustomerAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CustomerAccessor')
         */
        _string: 'CustomerAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * stripe
         * 
         * @access public
         * @return String
         */
        stripe: function() {
            var link = 'https://dashboard.stripe.com/';
            if (Stencil.get('config').role !== 'prod') {
                link += 'test/';
            }
            link += 'customers/' + (this._data.gatewayKey);
            return link;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FeatureModel'], function() {

    /**
     * FeatureAccessor
     * 
     * @extends Accessor
     */
    window.FeatureAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FeatureAccessor')
         */
        _string: 'FeatureAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FontModel'], function() {

    /**
     * FontAccessor
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/full
     * @extends Accessor
     */
    window.FontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FontAccessor')
         */
        _string: 'FontAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupUpload();
        },

        /**
         * _setupUpload
         * 
         * @access protected
         * @return void
         */
        _setupUpload: function() {
            var model = Stencil.getModel('Upload');
            this._references.upload = model.setAccessor(this._data.upload);
        },

        /**
         * delete
         * 
         * I'm overriding the Accessor delete method, because with fonts, they
         * never actually deleted. Rather they get marked as inactive, to ensure
         * the data can still be loaded later on (eg. for deleted fonts in saved
         * images, or featured templates that use uploaded or imported fonts).
         * 
         * @access public
         * @return void
         */
        delete: function() {
            this.set({
                'deleted': true
            });
            Stencil.features.remove(this);
            Stencil.stars.remove(this);
            this.push('active', 0);
            this.triggerHandler('delete');
            this.removeAll();
        },

        /**
         * drawStyleSheet
         * 
         * @access public
         * @return void
         */
        drawStyleSheet: function() {
            var type = 'woff';
            if (Browser.woff2() === true) {
                type = 'woff2';
            }
            var style = '@font-face {' +
                'font-family:"' + (this.get('familyName')) + '";' +
                'src:url("' + (this.getUrl(type)) + '") ' +
                'format("' + (type) + '");' +
            '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getUrl
         * 
         * @access public
         * @param  String type
         * @return String
         */
        getUrl: function(type) {
            var key = this._references.upload.get('key');
            if (type === 'woff') {
                key += '.woff';
                return Images.cloudFront(key);
            }
            if (type === 'woff2') {
                key += '.woff2';
                return Images.cloudFront(key);
            }
            if (type === 'otf') {
                key += '.otf';
                return Images.cloudFront(key);
            }
            if (type === 'ttf') {
                key += '.ttf';
                return Images.cloudFront(key);
            }
            throw new Error('Invalid type for getUrl of font');
        },

        /**
         * loadFull
         * 
         * Fully loads specific font (including any available styles such as
         * bold, italic and bold + italic).
         * 
         * @access public
         * @param  Function callback
         * @return void
         */
        loadFull: function(callback) {

            // Determine what should be loaded
            var familyName = this.get('familyName'),
                loadableVersions = [];
            loadableVersions.push((familyName) + ':n4');
            if (this.get('bold').toInt() === 1) {
                loadableVersions.push((familyName) + ':n7');
            }
            if (this.get('italic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i4');
            }
            if (this.get('boldItalic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i7');
            }

            // Determine what font versions (if any) should be loaded
            var collection = Stencil.account().collection('fonts'),
                loadedFontFamilies = collection.getLoaded(),
                fontsAlreadyLoaded = _.intersection(
                    loadedFontFamilies,
                    loadableVersions
                );
                fontVersionToLoad = _.difference(
                    loadableVersions,
                    fontsAlreadyLoaded
                );

            // If there's nothing to load, we're good
            if (fontVersionToLoad.length === 0) {
                callback && callback();
            }
            // If it's a native font
            else if (this.get('native').toInt() === 1) {
                callback && callback();
            }
            // Otherwise let's go ahead with this
            else {

                // If the font is already being loaded
                var loadingFontFamilies = collection.getLoading(),
                    fontBeingLoaded = _.indexOf(
                        loadingFontFamilies,
                        fontVersionToLoad[0]
                    ) !== -1;
                if (callback !== undefined) {
                    this.once({
                        'load/full/success load/full/failed': callback
                    });
                }

                // Font hasn't yet been loaded
                if (fontBeingLoaded === false) {

                    // Track what's being loaded
                    loadingFontFamilies.push.apply(
                        loadingFontFamilies,
                        fontVersionToLoad
                    );

                    /**
                     * There's a strange bug with the WebFont library, in
                     * that when only a custom font is requested, the
                     * library will error out with "No fonts to load!"
                     * 
                     * This is because it does not seem to be accounting
                     * for a single custom font being loaded along with an
                     * empty array of Google fonts.
                     * 
                     * To deal with this, I make the call to the load method
                     * by passing in the webFontConfigObject, which only
                     * adds the google fonts if the array has at least one
                     * entry.
                     */
                    var webFontConfigObject = {
                        classes: false,
                        fontactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadedFontFamilies.push(formattedFamilyName);
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/success');
                            }
                        }).proxy(this),
                        /** 
                         * There was an issue with IE11 whereby a font
                         * would fail to load. To accommodate this, for
                         * now, trigger a failed alert, which is the
                         * same as the loaded event.
                         * 
                         * This will ensure the callback gets triggered
                         * (even if it is wrong for now).
                         */
                        fontinactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/failed');
                            }
                        }).proxy(this),
                        timeout: 5000
                    };

                    // Determine which kind of font is being loaded
                    if (this.get('uploaded').toInt() === 0) {
                        webFontConfigObject.google = {
                            families: replaceFontColons(fontVersionToLoad)
                        };
                    } else {
                        webFontConfigObject.custom = {
                            families: replaceFontColons(fontVersionToLoad)
                        };
                    }

                    // Initiate the load
                    WebFont.load(webFontConfigObject);
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FrameModel'], function() {

    /**
     * FrameAccessor
     * 
     * @extends Accessor
     */
    window.FrameAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FrameAccessor')
         */
        _string: 'FrameAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Frame deleted');
                }
            });
        },

        /**
         * getIcon
         * 
         * @access public
         * @return string
         */
        getIcon: function() {
            switch (this._data.tag) {
                case 'email':
                    return 'fa-envelope-o';
                case 'facebook':
                    return 'fa-facebook';
                case 'googlePlus':
                    return 'fa-google-plus';
                case 'instagram':
                    return 'fa-instagram';
                case 'linkedin':
                    return 'fa-linkedin';
                case 'pinterest':
                    return 'fa-pinterest-p';
                case 'twitter':
                    return 'fa-twitter';
                case 'youtube':
                    return 'fa-youtube';
                default:
                    return 'fa-circle';
            }
        },

        /**
         * getRatio
         * 
         * @access public
         * @return Number
         */
        getRatio: function() {
            return this._data.width / this._data.height;
        },

        /**
         * select
         * 
         * @access public
         * @return void
         */
        select: function() {
            window.Frame = this;
            var draft = Stencil.account().draft();
            draft.set({
                frame: Frame.get('key'),
                width: Frame.get('width'),
                height: Frame.get('height')
            });
        },

        /**
         * setToPreviewCanvas
         * 
         * @access public
         * @return void
         */
        setToPreviewCanvas: function() {
            var content = App.getStage().getContent(),
                framer = content.getFramer(),
                canvas = Canvases.Preview;
            this.updateMessaging();
            canvas.once({
                'refresh': function() {
                    var layer = canvas.getBackgroundImageLayer();
                    layer.getCotton().trigger('lock');
                    canvas.render();
                }
            });
            canvas.refreshLayers();
        },

        /**
         * updateMessaging
         * 
         * @access public
         * @return void
         */
        updateMessaging: function() {
            var content = App.getStage().getContent(),
                framer = content.getFramer();
            content.updateReframer();
            framer.updateSelected();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'GoogleFontModel'], function() {

    /**
     * GoogleFontAccessor
     * 
     * @extends Accessor
     */
    window.GoogleFontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GoogleFontAccessor')
         */
        _string: 'GoogleFontAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * alreadyImported
         * 
         * @access public
         * @return Boolean
         */
        alreadyImported: function() {
            var uploadedFonts = Stencil.account().collection('fonts').getUploaded(),
                index,
                upload;
            for (index in uploadedFonts) {
                upload = uploadedFonts[index].reference('upload');
                if (this._data.file.indexOf(upload.get('name')) !== -1) {
                    return true;
                }
            }
            return false;
        },

        /**
         * drawStyleSheet
         * 
         * @access public
         * @return void
         */
        drawStyleSheet: function() {
            var fontFamily = this.get('id'),
                style = '@font-face {' +
                    'font-family:"' + (fontFamily) + '";' +
                    'src:url("' + (this.get('file')) + '")'  +
                '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getExtendedSubsets
         * 
         * @access public
         * @return Array
         */
        getExtendedSubsets: function() {
            var standardSubsets = ['latin', 'latin-ext'],
                extendedSubsets = [],
                index,
                subset;
            for (index in this._data.subsets) {
                subset = this._data.subsets[index];
                if (jQuery.inArray(subset, standardSubsets) === -1) {
                    extendedSubsets.push(subset);
                }
            }
            return extendedSubsets;
        },

        /**
         * getExtendedSubsetsTooltip
         * 
         * @access public
         * @return String
         */
        getExtendedSubsetsTooltip: function() {
            var extendedSubsets = this.getExtendedSubsets(),
                index;
            for (index in extendedSubsets) {
                extendedSubsets[index] = extendedSubsets[index].ucfirst();
            }
            return 'Supports: <br> - ' + extendedSubsets.join('<br> - ');
        },

        /**
         * getVariant
         * 
         * @note   The following is the breakdown of strength to english
         *         adjective:
         *         - 100: Thin
         *         - 200: Extra-Light
         *         - 300: Light
         *         - 400: Regular
         *         - 500: Medium
         *         - 600: Semi-Bold
         *         - 700: Bold
         *         - 800: Extra-Bold
         *         - 900: Black
         * @access public
         * @return String
         */
        getVariant: function() {

            // Map the weights to the english equivalent
            var weightMap = {
                    100: 'Thin',
                    200: 'Extra-Light',
                    300: 'Light',
                    400: 'Regular',
                    500: 'Medium',
                    600: 'Semi-Bold',
                    700: 'Bold',
                    800: 'Extra-Bold',
                    900: 'Black'
                },
                useWeightMap = true;

            // No italics
            if (this._data.variant.match(/italic/) === null) {
                if (useWeightMap === true) {
                    return weightMap[this._data.variant];
                }
                return this._data.variant;
            }

            // Italics
            if (useWeightMap === true) {
                var weight = this._data.variant.match(/^[0-9]+/)[0];
                return (weightMap[weight]) + ' + Italic';
            }

            // Keep weight
            return this._data.variant.replace(/^([0-9]+)italic$/, '$1 + Italic');
        },

        /**
         * hasExtendedSubsetSupport
         * 
         * @access public
         * @return Boolean
         */
        hasExtendedSubsetSupport: function() {
            return this.getExtendedSubsets().length > 0;
        },

        /**
         * import
         * 
         * @access public
         * @return void
         */
        import: function() {
            this._model.import(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'ImageModel'], function() {

    /**
     * ImageAccessor
     * 
     * @fires   download
     *          normalize
     *          preload
     *          select
     *          star
     *          template
     *          unstar
     *          upload/abort
     *          upload/error
     *          upload/progress
     *          upload/success
     * @extends MediaAccessor
     */
    window.ImageAccessor = MediaAccessor.extend({

        /**
         * _imageDocument
         * 
         * @access protected
         * @var    ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _lastSavedConfigurationString
         * 
         * Reference to the last JSON string that was saved for this image. Used
         * to prevent PATCH calls on an image when it's underlying JSON hasn't
         * changed.
         * 
         * @access protected
         * @var    String (default: '')
         */
        _lastSavedConfigurationString: '',

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageAccessor')
         */
        _string: 'ImageAccessor',

        /**
         * _saveConfigurationTimeout
         * 
         * @access protected
         * @var    null|Number (default: null)
         */
        _saveConfigurationTimeout: null,

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupSourceImage();
            this.markConfigurationAsSaved();
            // var document = this.json();
            // this._imageDocument = new ImageDocument(document, this);
            // this._imageDocument.setupLayers();
            // this.markConfigurationAsSaved();
            this.on({
                'change/settings.locked': function(event, value) {
                    var $lock = App.getStage().getContent().find('div.sandbox a.lock');
                    $lock.addClass('hidden');
                    if (value.toInt() === 1) {
                        $lock.removeClass('hidden');
                    }
                },
                'delete': function(event) {
                    Track.event('Image deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'download': function(event) {
                    Track.event('Image downloaded', {
                        _url: this.url('original')
                    });
                },
                'preload': function(event) {
                    this.set({
                        'preloaded': 1
                    });
                },
                'select': function(event, type, method, locked, options) {
                    if (
                        this._data.legacy.toInt() === 1
                        && this._data.legacyNormalized.toInt() === 0
                    ) {
                        this.normalize();
                    } else {

                        // If they don't own it
                        if (ChangeHistory.persistWatermarksForFeaturedTemplates() === true) {
                            Stencil.set('smartToggleWatermarks', true);
                            if (this.owned() === false) {
                                Stencil.set('smartToggleWatermarks', false);
                            }
                        }

                        // 
                        // this._confirmImageChange().on({
                        //     'yes': function(event) {
                                var canvas = Canvases.Preview;
                                if (canvas.get('drawing') === true) {
                                    var key = 'image.select.pending',
                                        msg = Stencil.getMessage(key);
                                    App.getBusy().show(msg);
                                    var start = new Date();
                                    canvas.once({
                                        'render': function(event, content) {
                                            var busy = App.getBusy();
                                            busy.hide.minDelay(
                                                start,
                                                1750,
                                                busy
                                            );
                                        }
                                    });
                                } else {
                                    // Footer.disable.save.apply(Footer);
                                    this._setToPreviewCanvas(
                                        type, method, locked, options
                                    );
                                }
                            // }
                        // });
                    }
                },
                'star': function(event) {
                    Track.event('Image starred', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'unstar': function(event) {
                    Track.event('Image unstarred', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
            if (this._data.uploaded.toInt() === 1) {
                this.set({
                    'preloaded': 1
                });
            }
        },

        /**
         * _confirmImageChange
         * 
         * @access protected
         * @return ConfirmModal
         */
        _confirmImageChange: function() {
            var _this = this,
                h1 = 'This will swap out all your images and text.',
                h2 = 'Are you sure?',
                modal = Modals.showConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function() {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * _download
         * 
         * This internal method is as complicated as it is because in Safari,
         * triggering a location change kills any running ajax calls. So I wait
         * for all active remote connections to finish before triggering the
         * location change.
         * 
         * After that, I check for a cookie (set on the server side which
         * communicates to the front end that the image download has begun), to
         * hide the busy modal.
         * 
         * Note that it be worthwhile flow for Safari, since it is the only
         * outlier.
         * 
         * @access protected
         * @param  false|String mime
         * @param  false|String filename
         * @param  Boolean scaleForRetina
         * @return void
         */
        _download: function(mime, filename, scaleForRetina) {
            var path = this._getDownloadPath(mime, filename, scaleForRetina),
                intervals = {},
                checks = {
                    cookie: function() {
                        if (
                            Cookies.get('image.download.started') !== undefined
                        ) {
                            jQuery.intervalPool.clear(intervals.cookie);
                            Stencil.cookies.remove('image.download.started');
                            App.getBusy().hide();
                            this.triggerHandler('download');
                            Stencil.set('redirecting', false);
                            Stencil.triggerHandler('redirect/complete');
                        }
                    },
                    connections: function() {
                        if (jQuery.xhrPool.length === 0) {
                            jQuery.intervalPool.clear(intervals.connections);
                            Stencil.triggerHandler('redirect/start');
                            Stencil.set('redirecting', true);
                            if (
                                (
                                    Browser.extension() === true
                                    && Browser.hasCSP() === true
                                )
                                // || Browser.ipad() === true
                            ) {
                                window.open(path);
                            } else {
                                window.location.assign(path);
                            }
                            intervals.cookie = checks.cookie.interval(50, this);
                        }
                    }
                };
            intervals.connections = checks.connections.interval(50, this);
        },

        /**
         * _getDownloadPath
         * 
         * @access protected
         * @param  false|String mime
         * @param  false|String filename
         * @param  Boolean scaleForRetina
         * @return String
         */
        _getDownloadPath: function(mime, filename, scaleForRetina) {
            var path = '/images/' + (this._data.key) + '/download',
                params = {};
            if (mime !== false) {
                if (mime === 'image/jpeg') {
                    params.m = '1';
                } else if (mime === 'image/png') {
                    params.m = '2';
                } else if (mime === 'application/octet-stream') {
                    params.m = '3';
                }
            }
            if (filename !== false) {
                params.filename = filename;
            }
            if (scaleForRetina === true) {
                params.pushRaw = 1;
            }
            return (path) + '?' + jQuery.param(params);
        },

        /**
         * _setSourceImage
         * 
         * @access protected
         * @param  ImageAccessor sourceImage
         * @return void
         */
        _setSourceImage: function(sourceImage) {
            this._references.sourceImage = sourceImage;
        },

        /**
         * _setToPreviewCanvas
         * 
         * Method to draw the image represented in the current ImageAccessor to
         * the preview canvas. Does this by deleting any existing layers,
         * setting the account draft to this ImageAccessor (which simply copies
         * over relevant data, such as the frame, width, height, source image
         * id, and json), setting the frame to the new size, and preparing /
         * drawing the canvas.
         * 
         * The check within the render event is intended to check if the image
         * being loaded into the preview canvas is owned by the user (regardless
         * of whether it's a template or image). If it is, I set the image (in
         * the footer, of all places, haha) to ensure that the user can download
         * and P+S, since the image is not yet different.
         * 
         * @access protected
         * @param  String type
         * @param  String method
         * @param  Boolean locked
         * @param  Object options
         * @return void
         */
        _setToPreviewCanvas: function(type, method, locked, options) {
            var _this = this,
                account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                frame,
                document,
                imageDocument,
                canvas = Canvases.Preview;
            draft.getImageDocument().deleteAllLayers();
            draft.setToImage(this, type, method, locked, options);
            App.setSelectedFrame();

            // // Ensure proper draft is set
            // frame = draft.get('frame');
            // frame = Stencil.getAccessor(frame);
            // if (frame === false || frame === orphan) {
            //     frame = orphan;
            //     orphan.set({
            //         width: draft.get('width'),
            //         height: draft.get('height')
            //     });
            // } else {
            //     if (
            //         frame.get('width').toInt() !== draft.get('width').toInt()
            //         || frame.get('height').toInt() !== draft.get('height').toInt()
            //     ) {
            //         frame = orphan;
            //         orphan.set({
            //             width: draft.get('width'),
            //             height: draft.get('height')
            //         });
            //     }
            // }
            // frame.select();
            // frame.updateMessaging();

            // Draw
            document = draft.json();
            imageDocument = new ImageDocument(document, draft, canvas);
            draft.setImageDocument(imageDocument);
            canvas.once({
                'render': function(event) {
                    if (_this.owned() === true) {
                        // console.log('owned');

                        /**
                         * The following prevents the same image from being set
                         * in the Footer when it's just a redo or undo operation
                         * being completed.
                         */
                        if (draft !== _this) {
                            Footer.setLastSavedImage(_this);
                        } else {
                            var sourceImage = _this.getSourceImage();
                            if (sourceImage === false) {
                                Footer.setLastSavedImage(false);
                            } else if (sourceImage === undefined) {
                                Footer.setLastSavedImage(false);
                            } else {
                                if (sourceImage.deleted() === false) {
                                    if (sourceImage.owned() === true) {
                                        Footer.setLastSavedImage(sourceImage);
                                    }
                                }
                            }
                        }
                    }
                    _this.triggerHandler('set/previewCanvas/finish');
                }
            });

            /**
             * Same goes here: I'm only showing the busy modal over top of the
             * preview canvas if it's not the draft itself that's being set,
             * which if it is, it's just a redo or undo operation being
             * completed.
             */
            var showBusyModal = true;
            if (draft === this) {
                showBusyModal = false;
            }
            canvas.draw(showBusyModal);
            draft.setConfiguration();
        },

        /**
         * _setupSourceImage
         * 
         * The first check against the property being undefined is because when
         * an image-record's public data is retrieved, no sourceImage property
         * is passed down unless it's a deep-public-data retrieval.
         * 
         * In the case that it is, it's possible that there is no sourceImage
         * (for example, legacy images). For those, false is passed down, thus
         * the second check.
         * 
         * @access protected
         * @return void
         */
        _setupSourceImage: function() {
            if (this._data.sourceImage !== undefined) {
                if (this._data.sourceImage !== false) {
                    var model = Stencil.getModel('Image');
                    this._references.sourceImage = model.setAccessor(
                        this._data.sourceImage
                    );
                }
            }
        },

        /**
         * clearSaveConfigurationTimeout
         * 
         * @access public
         * @return void
         */
        clearSaveConfigurationTimeout: function() {
            jQuery.timeoutPool.clear(this._saveConfigurationTimeout);
        },

        /**
         * delete
         * 
         * @access public
         * @return void
         */
        delete: function() {
            if (this._data.uploaded.toInt() === 1) {
                App.getBusy().hide();
                if (Stencil.account().draft().getSourceImage() === this) {
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                }
                this._super();
            } else {
                var msg = Stencil.getMessage('image.delete.pending');
                App.getBusy().show(msg);
                this.once({
                    'update/uploaded': this.delete.proxy(this)
                });
            }
        },

        /**
         * download
         * 
         * @todo   Look into whether this may be a problem for popup blockers.
         *         If so, for those browsers, show messaging in the busy modal
         *         that we're saving the image, and once complete, show an
         *         alert prompting them to try downloading again.
         * @access public
         * @param  false|String mime
         * @param  false|String filename
         * @param  Boolean scaleForRetina
         * @param  Boolean showBusyModal
         * @return void
         */
        download: function(mime, filename, scaleForRetina, showBusyModal) {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else {
                if (this._data.uploaded.toInt() === 1) {
                    if (showBusyModal === true) {
                        App.getBusy().show();
                    }
                    this._download.apply(this, [
                        mime,
                        filename,
                        scaleForRetina
                    ]);
                } else {
                    if (showBusyModal === true) {
                        var msg = Stencil.getMessage('image.download.pending');
                        App.getBusy().show(msg);
                    }
                    this.once({
                        'change/uploaded': this._download.proxy(
                            this,
                            [mime, filename, scaleForRetina]
                        )
                    });
                }
            }
        },

        /**
         * generateShortUrl
         * 
         * @access public
         * @return void
         */
        generateShortUrl: function() {
            if (this._data.uploaded.toInt() === 1) {
                this._model.generateShortUrl(this._data.key);
            } else {
                this.once({
                    'update/uploaded': this.generateShortUrl.proxy(this)
                });
            }
        },

        /**
         * getConfiguration
         * 
         * Returns the unique "recipe" for this image, including the frame (if
         * any, otherwise an empty string), the width and height (traditionally
         * set through a Frame, but now set explictly if the Frame has since
         * been deleted or else does not exist) and the settings, including the
         * json (which defines the layout of all the drawings) and watermarks
         * (which helps determine whether the image is unique relative to other
         * watermarks being turned on and off).
         * 
         * @access public
         * @return Object
         */
        getConfiguration: function() {
            // var json = this._imageDocument.json(false),
            //     watermarks = this._imageDocument.getWatermarkLayersJson(),
            var configuration = {
                frame: this._data.frame,
                width: this._data.width,
                height: this._data.height,
                sourceImageId: 0,
                settings: {
                    json: this.setting('json'),
                    watermarks: this.setting('watermarks')
                }
            };
            if (this._imageDocument !== false) {
                var imageDocument = this._imageDocument;
            // if (this === Stencil.account().draft()) {
                configuration.settings = {
                    json: JSON.stringify(imageDocument.json(false)),
                    watermarks: JSON.stringify(
                        imageDocument.getWatermarkLayersJson()
                    )
                };
                if (this._imageDocument.getCanvas() === Canvases.Preview) {
                    configuration.frame = Frame.get('key');
                }
            }
            if (
                this.getSourceImage() !== undefined
                && this.getSourceImage() !== false
            ) {
                configuration.sourceImageId = this.getSourceImage().get('id');
            }
            return configuration;
        },

        /**
         * getDefaultFilename
         * 
         * @access public
         * @return String
         */
        getDefaultFilename: function() {
            var mime = this.getRecommendedExportMime(),
                extension = 'png';
            if (mime === 'image/jpeg') {
                extension = 'jpg';
            }
            if (Frame.get('key') === 'frm-orphan') {
                return 'stencil.' + (extension);
            }
            if (Frame.get('key').match(/frm0/) !== null) {
                var frame = Stencil.getAccessor(Frame.get('key'));
                if (frame === false) {
                    return 'stencil.' + (extension);
                }
                if (frame.get('label').trim() === '') {
                    return 'stencil.' + (extension);
                }
                return 'stencil.' + frame.get('label').slugify(48) + '.' + (extension);
            }
            var frames = Frames.all(),
                frame;
            for (var index in frames) {
                frame = frames[index];
                if (Frame.get('key') === frame.key) {
                    return 'stencil.' + Frame.get('label').slugify(48) + '.' + (extension);
                }
            }
            return 'stencil.' + (extension);
        },

        /**
         * getIcons
         * 
         * @access public
         * @return Array
         */
        getIcons: function() {
            var layers = this._imageDocument.getVectorImageLayers(),
                icons = [];
            for (var index in layers) {
                icons.push(layers[index].getProperty('image'));
            }
            return icons;
        },

        /**
         * getImageDocument
         * 
         * @access public
         * @return ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getRecommendedExportMime
         * 
         * @access public
         * @return String
         */
        getRecommendedExportMime: function() {
            var layer = Canvases.Preview.getBackgroundImageLayer();
            if (layer.getProperty('image') === false) {
                return 'image/png';
            }
            return 'image/jpeg';
        },

        /**
         * getSentPath
         * 
         * @access public
         * @return String
         */
        getSentPath: function() {
            var path = '/app/images/';
            path += this._data.key;
            path += '/sent?clean=1';
            return path;
        },

        /**
         * getSharePath
         * 
         * @access public
         * @param  String network
         * @return String
         */
        getSharePath: function(network) {
            var path = '/app/images/';
            path += this._data.key;
            path += '/share/' + (network);
            return path;
        },

        /**
         * getSnippet
         * 
         * I am checking if it is a legacy image here because I want to prevent
         * looping over the json-setting for them. This is simply because most
         * of the time for legacy images, the json-setting will not have been
         * normalized at the start.
         * 
         * In this case, I still return the placeholder text below, because if
         * I do not, Buffer fails to pull in the image itself.
         * 
         * @access public
         * @param  Number|false limit
         * @return Object
         */
        getSnippet: function(limit) {
            if (this._data.legacy.toInt() === 1) {
                return {
                    default: true,
                    snippet: 'Enter your own message here'
                };
            }
            if (JSON.valid(this._data.settings.json) === true) {
                var layers = JSON.parse(this._data.settings.json).layers,
                    text = [];
                jQuery.each(layers, function(index, layer) {
                    if (layer.type === 'text') {
                        text.push(layer.text.trim());
                    }
                });
                if (text.length === 0) {
                    return {
                        default: true,
                        snippet: 'Enter your own message here'
                    };
                }

                // Limit check
                if (limit === false) {
                    return {
                        default: false,
                        snippet: text.join(' / ')
                    };
                }
                text = text.join(' / ');
                if (text.length > limit) {
                    return {
                        default: false,
                        snippet: text.substring(0, limit - 3) + '...'
                    };
                }
                return {
                    default: false,
                    snippet: text
                };
            }
            StencilBooter.log('JSON parse error (I:gS)');
            return {
                default: true,
                snippet: 'Enter your own message here'
            };
        },

        /**
         * getSourceImage
         * 
         * @access public
         * @return ImageAccessor|undefined
         */
        getSourceImage: function() {
            return this._references.sourceImage;
        },

        /**
         * getSrc
         * 
         * Function intended to be used with views to output some image, even if
         * it's not yet fully uploaded to S3.
         * 
         * Returns the raw canvas data if the image hasn't yet finished
         * uploading. If it has, it checks to see if a width is defined. If none
         * is defined (eg. cases with legacy saved images), a url with a scaled
         * width of 800 pixels is returned. Or else, a url with the proper
         * scaled width is returned.
         * 
         * @access public
         * @return String
         */
        getSrc: function() {
            if (
                this._data.uploaded.toInt() === 0
                || this.preloaded() === false
            ) {
                return Canvases.Preview.getElement()[0].toDataURL();
            }
            var width = this._data.width.toInt();
            if (width === 0) {
                return this.url('scale', {
                    width: 800
                });
            }
            return this.url('scale', {
                width: width
            });
        },

        /**
         * isLocked
         * 
         * @access public
         * @return Boolean
         */
        isLocked: function() {
            return this._data.settings.locked.toInt() === 1;
        },

        /**
         * json
         * 
         * Returns a default canvas JSON object (based on guest/user status), or
         * else the JSON object for the image object if it's <json> value is not
         * an empty string.
         * 
         * @access public
         * @return Object
         */
        json: function() {
            if (this._data.settings.json === '') {
                if (User.exists() === false) {
                    return Stencil.get('config').defaults.canvases.guest;
                }
                return Stencil.get('config').defaults.canvases.user;
            }
            if (JSON.valid(this._data.settings.json) === false) {
                this._data.settings.json = '';
                return this.json();
            }
            var parsed = JSON.parse(this._data.settings.json);
            if (parsed.layers === undefined) {
                this._data.settings.json = '';
                return this.json();
            }
            if (parsed.layers.length === 0) {
                this._data.settings.json = '';
                return this.json();
            }
            return parsed;
        },

        /**
         * loadDependentFonts
         * 
         * Loads any fonts that are dependents of this image. The reason they
         * might not already be loaded is because they might have been deleted
         * by the user, or else they were used in a featured template.
         * 
         * It's important that I set the hasRegularAccess property to 0 so that
         * the rest of the font flow knows that this font is not traditionally
         * accessible by the account.
         * 
         * Also, I set the label to the parsedFamilyName property, incase the
         * user who originally uploaded or imported the font changed it's name
         * at one point. It makes more sense to use whatever was parsed at the
         * time of conversion / upload / importing, rather than whatever they
         * might have changed it to.
         * 
         * @access public
         * @return void
         */
        loadDependentFonts: function() {
            var fontObjects = this._data.fonts,
                index, fontObject,
                collection = Stencil.account().collection('fonts'),
                model = Stencil.getModel('Font'),
                accessors;
            for (index in fontObjects) {
                fontObject = fontObjects[index];
                if (collection.find(fontObject.key) !== false) {
                    continue;
                }
                fontObject.hasRegularAccess = 0;
                fontObject.label = fontObject.parsedFamilyName;
                accessors = collection.map([fontObject]);
                Toolbars.text.getFontsDropdown().addFont(accessors[0], true);
            }
        },

        /**
         * markAsUploaded
         * 
         * @access public
         * @return void
         */
        markAsUploaded: function() {
            this._model.markAsUploaded(this._data.key);
        },

        /**
         * markConfigurationAsSaved
         * 
         * Calling this method converts the configuration for the image to json,
         * and stores it locally. The intention of calling this method should be
         * to prevent any future PATCH calls against the record from being
         * triggered by setting the last-saved configuration local varaible to
         * exactly what is set for the image.
         * 
         * @access public
         * @return void
         */
        markConfigurationAsSaved: function() {
            var configuration = this.getConfiguration();
            this._lastSavedConfigurationString = JSON.stringify(configuration);
        },

        /**
         * normalize
         * 
         * @access public
         * @return void
         */
        normalize: function() {
            var path = '/app/images/' + (this._data.key) + '/normalize?clean',
                normalized = Normalizer.image(this.setting('json'));
            Stencil.navigate(path);
            this.set('settings.json', normalized);
            this._model.normalize(this._data.key);
        },

        /**
         * owned
         * 
         * Checks whether the logged in account owns the image, which is used in
         * determining whether a saved-draft should have the save button enabled
         * upon app-init. This is because it's possible for a user to load a
         * template, but not save or interact with it. In that case, the save
         * button should be available to the user.
         * 
         * @access public
         * @return Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Contains preloading logic for images that either don't have their
         * width defined (eg. legacy images), or else do, and should have the
         * exact scaled-width version preloaded.
         * 
         * @access public
         * @param  Function success
         * @param  Function error
         * @return void
         */
        preload: function(success, error) {
            var urls = [
                this.url('thumb')
            ];

            /**
             * Assumes that if no width is defined, something went wrong with
             * syncing call. In that case, the 800px wide image will likely be
             * used in the getSrc call above. So preload that resource.
             */
            if (this._data.width.toInt() === 0) {
                urls.push(this.url('scale', {
                    width: 800
                }));
            }
            /**
             * Scale image to the exact width, which via Cloudinary, will also
             * (conveniently) take care of compression.
             */
            else {
                urls.push(this.url('scale', {
                    width: this._data.width.toInt()
                }));
            }

            // Function context scoping and calls
            success = success || function(){};
            error = error || function(){};
            Images.preload(urls, success.proxy(this), error.proxy(this));
        },

        /**
         * preloaded
         * 
         * @access public
         * @return Boolean
         */
        preloaded: function() {
            if (this._data.preloaded === undefined) {
                return false;
            }
            return this._data.preloaded.toInt() === 1;
        },

        /**
         * removeSourceImage
         * 
         * @access public
         * @return void
         */
        removeSourceImage: function() {
            this.push('sourceImageId', 0);
            // delete this._data.sourceImageId;
            delete this._references.sourceImage;
        },

        /**
         * saveConfiguration
         * 
         * Note that the deleted check here is because if the image has been
         * deleted in the database, any PATCH calls against it will naturally
         * fail. Not sure at the moment how or when this might happen, but
         * likely can't hurt.
         * 
         * @access public
         * @return void
         */
        saveConfiguration: function() {
            if (this.deleted() === false) {
                var configuration = this.getConfiguration(),
                    configurationString = JSON.stringify(configuration);
                if (
                    configurationString !== this._lastSavedConfigurationString
                ) {
                    var columns = [
                        'frame',
                        'sourceImageId',
                        'width',
                        'height',
                        'settings.json',
                        'settings.watermarks'
                    ];
                    this.save(columns, {
                        error: function(response) {
                            var error = Stencil.extractError(response);
                            if (error.validator[1] === 'notUploaded') {
                                Stencil.alert('image.uploaded.already');
                                Stencil.kill();
                                return false;
                            } else if (error.validator[1] === 'validRecordByKey') {
                                Stencil.alert('image.uploaded.deleted');
                                Stencil.kill();
                                return false;
                            }
                            return true;
                        }
                    });
                    this.markConfigurationAsSaved();
                }
            }
        },

        /**
         * select
         * 
         * @note   There is an exception whereby if the image (or template)
         *         being selected is a legacy image that has not yet been
         *         normalized, the user first see's the LegacyImageNormalize
         *         modal. After confirming the modal, the image is then
         *         loaded into the canvas. Unfortunately, the four params are
         *         lost in this process (because they're not being sent along
         *         to the LegacyImageNormalize modal, partially because the flow
         *         for this is a bit cumbersome, including a controller action
         *         and Router route). See LegacyImageNormalize.js to see the
         *         default values being passed into this method in that case.
         * @access public
         * @param  String type
         * @param  String method
         * @param  Boolean locked
         * @param  Object options
         * @return void
         */
        select: function(type, method, locked, options) {
            ChangeHistory.setOperationType('image // loaded');
            this.loadDependentFonts();
            this._super(type, method, locked, options);
        },

        /**
         * setConfiguration
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the configuration associated with the image. A delay is set here to
         * prevent too-many PATCH calls against the record, since this method is
         * called frequently.
         * 
         * This method is also responsible for registering objects within the
         * change history architecture. The delay value for how often objects
         * are registered there is different than the saveDelay used to prevent
         * excessive PATCH calls.
         * 
         * @access public
         * @return void
         */
        setConfiguration: function() {
            var configuration = this.getConfiguration(),
                delay = Stencil.getSaveDelay('image');
            this.set({
                'frame': configuration.frame,
                'sourceImageId': configuration.sourceImageId,
                'width': configuration.width,
                'height': configuration.height,
                'settings.json': configuration.settings.json,
                'settings.watermarks': configuration.settings.watermarks
            });
            this.clearSaveConfigurationTimeout();
            this._saveConfigurationTimeout = this.saveConfiguration.delay(
                delay,
                this
            );
        },

        /**
         * setImageDocument
         * 
         * @access public
         * @param  ImageDocument imageDocument
         * @return void
         */
        setImageDocument: function(imageDocument) {
            this._imageDocument = imageDocument;
        },

        /**
         * setToImage
         * 
         * Swaps out the frame and settings.json values, and triggers a sync to
         * ensure that after the delay, a call is made to save the image.
         * 
         * @access public
         * @param  ImageAccessor image
         * @param  String type
         * @param  String method
         * @param  Boolean locked
         * @param  Object options
         * @return void
         */
        setToImage: function(image, type, method, locked, options) {

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image being set and the current
             * one are not the same.
             * 
             * @todo!!!Maybe the property should just be exempted, rather than
             *         set to 0? Seems a bit funky to set this to 0...
             */
            var sourceImageId = this.get('id').toInt();
            if (method === 'redo' || method === 'undo') {
                sourceImageId = image.get('sourceImageId').toInt();
            }

            // 
            this.set({
                'frame': image.get('frame'),
                'width': image.get('width'),
                'height': image.get('height'),
                'sourceImageId': sourceImageId,
                'settings.json': image.setting('json'),
                'settings.watermarks': image.setting('watermarks')
            });

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image that being set is _not_
             * the same one, since redo / undo functionality uses this approach.
             * When the source image is set to itself, it causes issues with
             * the Footer view, since it thinks an image is available to be
             * downloaded (since that's determined by checking the source
             * image).
             */
            if (method === 'redo' || method === 'undo') {
                this._setSourceImage(image.getSourceImage());
            } else {
                this._setSourceImage(image);
            }
            // this.set({
            //     'settings.json': image.setting('json'),
            //     'frame': Frame.get('key')
            // });
            // this.save(['frame', 'settings.json']);
        },

        /**
         * share
         * 
         * Redirects the user to the share page / experience, based on the user
         * account's shareNetwork setting, which tracks the last network they
         * tried sharing to.
         * 
         * @access public
         * @return void
         */
        share: function() {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else {
                var network = Stencil.account().userAccount().setting(
                        'shareNetwork'
                    ),
                    path = this.getSharePath(network);
                Stencil.navigate(path);
                // this.triggerHandler('share');
            }
        },

        /**
         * star
         * 
         * @access public
         * @return void
         */
        star: function() {
            Stencil.stars.add(this);
            this._model.star(this._data.key);
            var stars = App.getEditor().getArea('images').getChild('stars').getCollection();
            stars.add(this, false);
            this.triggerHandler('star');
        },

        /**
         * template
         * 
         * @access public
         * @return void
         */
        template: function() {
            var collection = App.getEditor().getArea('templates').getChild('saved').getCollection(),
                templates = collection.map({
                    class: 'template',
                    key: random(),
                    image: this._data
                }, false);
            this._model.template(this._data.key, function(data) {
                templates[0].swap(data.object);
            });
            this.triggerHandler('template');
        },

        /**
         * unstar
         * 
         * @access public
         * @return void
         */
        unstar: function() {
            Stencil.stars.remove(this);
            this._model.unstar(this._data.key);
            var stars = App.getEditor().getArea('images').getChild('stars').getCollection();
            stars.remove(this);
            this.triggerHandler('unstar');
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with Buffer + Pinterest sharing
         * - Scaled image url, used in Share modal to show a maximum resolution
         *   image (since the full dimension is a waste of bandwidth)
         * - Thumb image url, used in images and templates tab
         * 
         * @access public
         * @param  String type
         * @param  Object|undefined options
         * @return String|false
         */
        url: function(type, options) {
            var key, proxy = 's3';
            if (type === 'original') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'sai';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.cloudinary(key, {
                    proxy: proxy,
                    type: 'original'
                });
            } else if (type === 'scale') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'sai';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.cloudinary(key, {
                    proxy: proxy,
                    type: 'scale',
                    width: options.width
                });
            } else if (type === 'thumb') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'sai';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.cloudinary(key, {
                    proxy: proxy,
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor'], function() {

    /**
     * MediaAccessor
     * 
     * @extends Accessor
     */
    window.MediaAccessor = Accessor.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'MediaAccessor')
         */
        _string: 'MediaAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * compress
         * 
         * @access public
         * @param  Function callback
         * @return void
         */
        compress: function(callback) {
            var compress = Stencil.get('config').defaults.compress;
            if (compress === true) {
                this.once({
                    'compress': function(event) {
                        callback.apply(this);
                    }
                });
                this._model.compress(this._data.key);
            } else {
                callback.apply(this);
            }
        },

        /**
         * getFrameUrl
         * 
         * Returns the frame-specific url. Used in preloading so that when an
         * image is uploaded, it'll be available as soon as it's been processed.
         * Not perfect, since the getFrameUrl method in Images assumes a lot.
         * See that class / function for more documentation.
         * 
         * @access public
         * @param  CanvasView canvas
         * @return String
         */
        getFrameUrl: function(canvas) {
            return Images.getFrameUrl(this._data.key, canvas);
        },

        /**
         * select
         * 
         * @access public
         * @param  String type Possible values:
         *         - background
         *         - graphic
         *         - template
         *         - quote
         *         - image
         * @param  String method Possible values:
         *         - click
         *         - drop
         *         - undo
         *         - redo
         * @param  Boolean locked Used to lock certain assets for free users
         * @param  Object options Used to pass along x/y coordinates for a drag
         * @return void
         */
        select: function(type, method, locked, options) {
            this.triggerHandler(
                'select',
                [type, method, locked === true, options]
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'PromoModel'], function() {

    /**
     * PromoAccessor
     * 
     * @extends Accessor
     */
    window.PromoAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Promo'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoAccessor')
         */
        _string: 'PromoAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupPromoSet();
        },

        /**
         * _setupPromoSet
         * 
         * @access protected
         * @return void
         */
        _setupPromoSet: function() {
            var model = Stencil.getModel('PromoSet');
            this._references.promoSet = model.setAccessor(this._data.promoSet);
        },

        /**
         * promoSet
         * 
         * @access public
         * @return PromoSetAccessor
         */
        promoSet: function() {
            return this._references.promoSet;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'PromoSetModel'], function() {

    /**
     * PromoSetAccessor
     * 
     * @extends Accessor
     */
    window.PromoSetAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoSetAccessor')
         */
        _string: 'PromoSetAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourceAccessor'], function() {

    /**
     * QuoteResourceAccessor
     * 
     * @extends ResourceAccessor
     */
    window.QuoteResourceAccessor = ResourceAccessor.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteResourceAccessor')
         */
        _string: 'QuoteResourceAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access protected
         * @return void
         */
        _addQuoteTextLayers: function() {
            var quotation = this._data.quotation,
                author = this._data.author,
                canvas = Canvases.Preview,
                layers = {
                    author: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: 'Leckerli One',
                        fontSize: 35,
                        text: author,
                        top: 70,
                        width: 90
                    }),
                    quotation: canvas.addTextLayer({
                        align: 'center',
                        // fontFamily: Stencil.get('config').defaults.font,
                        fontFamily: Stencil.account().setting('defaultFontFamily'),
                        fontSize: 50,
                        text: quotation,
                        top: 45,
                        width: 90
                    })
                },
                drawings = {
                    author: layers.author.getDrawing(),
                    quotation: layers.quotation.getDrawing()
                };
            layers.author.setChangeOperationType('quote:added');
            drawings.author.once({
                'draw': function(event) {
                    this.trim();
                    this.repositionRelativeTo(drawings.quotation);
                    this.animate();
                    drawings.quotation.animate();
                    drawings.quotation.select();
                    // this._cotton.trigger('changed');
                    layers.author.triggerHandler('refresh/dimensions');
                }
            });
            drawings.quotation.once({
                'draw': function(event) {
                    drawings.author.draw();
                }
            });
            drawings.quotation.draw();
        },

        /**
         * getDisplayableQuotation
         * 
         * @see    http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access public
         * @return String
         */
        getDisplayableQuotation: function() {
            return this._data.quotation.trimToLength(200).replace(
                /(?:\r\n|\r|\n)/g,
                '<br />'
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'ResourceModel'], function() {

    /**
     * ResourceAccessor
     * 
     * @extends MediaAccessor
     */
    window.ResourceAccessor = MediaAccessor.extend({

        /**
         * _asset
         * 
         * Possible reference to the asset that the resource was saved to.
         * 
         * @access protected
         * @var    AssetAccessor (default: false)
         */
        _asset: false,

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _saved
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _saved: false,

        /**
         * _saving
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _saving: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ResourceAccessor')
         */
        _string: 'ResourceAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'feature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource featured', {
                            _key: this._data.key
                        });
                    // }
                },
                'star': function(event) {
                    // if (this._asset === false) {
                        Track.event('Resource starred', {
                            _key: this._data.key
                        });
                    // }
                },
                'unfeature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource unfeatured', {
                            _key: this._data.key
                        });
                    // }
                },
                'unstar': function(event) {
                    // if (this._asset === false) {
                        Track.event('Resource unstarred', {
                            _key: this._data.key
                        });
                    // }
                }
            });
            this.on({
                'select': function(event, type, method, locked, options) {
                    // if (this._data.filesize <= 20 * 1024 * 1024) {
                        if (this._data.platform === 'TheNounProject') {
                            this._addTheNounProjectLayer(locked);
                        } else if (this._data.platform === 'Pixabay') {
                            this._setBackgroundBitmapLayer(locked);
                        } else if (this._data.platform === 'Pexels') {
                            this._setBackgroundBitmapLayer(locked);
                        } else if (this._data.platform === 'Unsplash') {
                            this._setBackgroundBitmapLayer(locked);
                        } else if (this._data.platform === 'AlgoliaQuote') {
                            this._addQuoteTextLayers();
                        }
                    // } else {
                    //     Stencil.alert('resource.filesize.excessive');
                    // }
                }
            });
        },

        /**
         * _addTheNounProjectLayer
         * 
         * @todo   After saving is complete, preload the asset at the new url
         *         via a crossDomain ajax call to have the preflight request
         *         fire as well
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _addTheNounProjectLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _incrementResourceOperations
         * 
         * Helper method to increment the general and specific
         * operation-counters to ensure that once the maximum is reached, the
         * user is blocked until previous operations finish.
         * 
         * This helper was required because of how the save method works.
         * Namely, it allows multiple calls to it, such that when the resource
         * has already been saved, the save-listener is triggered right away.
         * 
         * While that was the initial intention, it is nice having this in one
         * place regardless.
         * 
         * @access protected
         * @param  String type
         * @return void
         */
        _incrementResourceOperations: function(type) {
            var lookup = {
                    feature: 'parallelResourceFeatures',
                    save: 'parallelResourceSaves',
                    star: 'parallelResourceStars'
                },
                parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                parallelResourceOperationsByType = Stencil.get(lookup[type]);
            ++parallelResourceOperations;
            Stencil.set('parallelResourceOperations', parallelResourceOperations);
            ++parallelResourceOperationsByType;
            Stencil.set(lookup[type], parallelResourceOperationsByType);
        },

        /**
         * _setBackgroundBitmapLayer
         * 
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _setBackgroundBitmapLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundImageLayer(),
                drawing = layer.getDrawing(),
                key = this._data.key;
            layer.setChangeOperationType('image:changed');
            layer.setImage(key);
            layer.setProperty('locked', locked);
            layer.listenForGatewaySave();
            layer.setupGatewaySave();
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access private
                 * @return void
                 */
                'refresh': function() {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                }
            });
            drawing.reload();
        },

        /**
         * feature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        feature: function(category) {
            var check = this.validate.feature.apply(this, [category]);
            if (check.valid === false) {
                check.callback();
            } else {
                this._incrementResourceOperations('feature');
                var type = category.get('type'),
                    area = 'backgrounds';
                if (type === 'graphic') {
                    area = 'graphics';
                } else if (type === 'quote') {
                    area = 'quotes';
                }
                Stencil.features.add(this);
                category.features.add.apply(category, [this])
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('id').toInt(),
                        collections: this._data.collections || [],
                        package: this._data.package,
                        tags: this._data.tags,
                        uploader: this._data.uploader || {},
                        urls: this._data.urls
                    },
                    /**
                     * (anonymous)
                     * 
                     * Passes in a data object representing an asset record.
                     * 
                     * @access private
                     * @param  Object data
                     * @return void
                     */
                    function(data) {
                        if (data.object.uploaded.toInt() === 0) {
                            var code = 'r262',
                                reference = 'resource';
                            Stencil.error(code, reference);
                        } else {
                            var model = Stencil.getModel('Asset'),
                                accessor = model.setAccessor(data.object);
                            accessor.preload();
                            Stencil.triggerHandler('resource/feature/complete', [accessor]);
                            Stencil.triggerHandler('resource/operation/complete', ['feature', accessor]);
                        }
                    }
                );
                var slug = category.get('slug'),
                    features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
                features.add(this, false);
                this.triggerHandler('feature', [category]);
            }
        },

        /**
         * owned
         * 
         * @access public
         * @return false
         */
        owned: function() {
            return false;
        },

        /**
         * save
         * 
         * @todo!  Look into removing save-event and having listeners within the
         *         app look to resource/save/complete event.
         * @todo   This is a bad name; can get confused with saving and
         *         accessor's data (but maybe, that's okay, since it's a
         *         resource and it doesn't have any data other than the binary
         *         image itself?)
         * @note   Sometimes in the console it'll seem like there's a lag
         *         between when the /save ajax call returns, and when the
         *         callback is fired. This is because the newly saved resource
         *         is preloaded before the callback is fired.
         * @note   I cannot recall, but I believe I delayed things until after
         *         preload because when a save happens, it is often within the
         *         context of swapping out an image in the canvas. So I wanted
         *         to only swap it out once a preload action has occured (to
         *         prevent any flickering while the resource is requested).
         * @access public
         * @return void
         */
        save: function() {
            var check = this.validate.save.apply(this);
            if (check.valid === false) {
                check.callback();
            } else {
                if (this._saving === false) {
                    if (this._saved === true) {
                        this.triggerHandler('save', [this._asset]);
                    } else {
                        this._incrementResourceOperations('save');
                        var _this = this;
                        this._saving = true;
                        this._model.save(
                            this._data.key,
                            {
                                collections: this._data.collections || [],
                                // tags: this._data.tags || [],
                                tags: this._data.tags,
                                uploader: this._data.uploader || {},
                                urls: this._data.urls
                            },
                            /**
                             * (anonymous)
                             * 
                             * Passes in a data object representing an asset record.
                             * 
                             * @access private
                             * @param  Object data
                             * @return void
                             */
                            function(data) {
                                if (data.object.uploaded.toInt() === 0) {
                                    var code = 'r314',
                                        reference = 'resource';
                                    Stencil.error(code, reference);
                                } else {
                                    var model = Stencil.getModel('Asset'),
                                        accessor = model.setAccessor(data.object);
                                    _this._asset = accessor;
                                    accessor.preload(function() {
                                        _this._saved = true;
                                        _this._saving = false;
                                        _this.triggerHandler('save', [accessor]);
                                        Stencil.triggerHandler('resource/save/complete', [accessor]);
                                        Stencil.triggerHandler('resource/operation/complete', ['save', accessor]);
                                    });
                                }
                            }
                        );
                    }
                }
            }
        },

        /**
         * saved
         * 
         * @access public
         * @return Boolean
         */
        saved: function() {
            return this._saved;
        },

        /**
         * saving
         * 
         * @access public
         * @return Boolean
         */
        saving: function() {
            return this._saving;
        },

        /**
         * star
         * 
         * @access public
         * @param  String type
         * @return void
         */
        star: function(type) {
            var check = this.validate.star.apply(this, [type]);
            if (check.valid === false) {
                check.callback();
            } else {
                this._incrementResourceOperations('star');
                var area = 'backgrounds';
                if (type === 'graphic') {
                    area = 'graphics';
                } else if (type === 'quote') {
                    area = 'quotes';
                }
                Stencil.stars.add(this);
                this._model.star(
                    this._data.key,
                    {
                        collections: this._data.collections || [],
                        package: this._data.package,
                        tags: this._data.tags,
                        type: type,
                        uploader: this._data.uploader || {},
                        urls: this._data.urls
                    },
                    /**
                     * (anonymous)
                     * 
                     * Passes in a data object representing an asset record.
                     * 
                     * @access private
                     * @param  Object data
                     * @return void
                     */
                    function(data) {
                        var asset = data.object;
                        if (data.object.uploaded.toInt() === 0) {
                            var code = 'r377',
                                reference = 'resource';
                            Stencil.error(code, reference);
                        } else {
                            var model = Stencil.getModel('Asset'),
                                accessor = model.setAccessor(data.object);
                            accessor.preload();
                            Stencil.triggerHandler('resource/star/complete', [accessor]);
                            Stencil.triggerHandler('resource/operation/complete', ['star', accessor]);
                        }
                    }
                );
                var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
                stars.add(this, false);
                this.triggerHandler('star');
            }
        },

        /**
         * unfeature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        unfeature: function(category) {
            var type = category.get('type'),
                area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.features.remove(this);
            category.features.remove.apply(category, [this])
            this._model.unfeature(this._data.key, {
                category: category.get('id').toInt()
            });
            var slug = category.get('slug'),
                features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
            features.remove(this.getObject(type, features));
            this.triggerHandler('unfeature', [category]);
        },

        /**
         * getObject
         * 
         * @access public
         * @param  String type
         * @param  Collection collection
         * @return ResourceAccessor|AssetAccessor
         */
        getObject: function(type, collection) {
            var _this = this,
                area = (type === 'graphic' ? 'graphics' : 'backgrounds'),
                objects = collection.filter(function(index, accessor) {
                    return (
                        accessor.get('class') === 'resource'
                        && accessor.get('key') === _this._data.key
                    ) || (
                        accessor.get('class') === 'asset'
                        && accessor.get('resourceType') === _this._data.platform
                        && accessor.get('resourceId') === _this._data.id
                    );
                });
            return objects[0];
        },

        /**
         * unstar
         * 
         * @access public
         * @param  String type
         * @return void
         */
        unstar: function(type) {
            var area = 'backgrounds';
            if (type === 'graphic') {
                area = 'graphics';
            } else if (type === 'quote') {
                area = 'quotes';
            }
            Stencil.stars.remove(this);
            this._model.unstar(this._data.key, {
                type: type
            });
            var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
            stars.remove(this.getObject(type, stars));
            this.triggerHandler('unstar');
        },

        /**
         * url
         * 
         * Provides URLs (not through Cloudinary) for resources to match the
         * following cases:
         * - SVG image url (eg. The Noun Project)
         * - Preview image url, used to show both Pixabay and The Noun Project
         *   thumbs
         * - Small image urls, currently only used to draw Pixabay resources
         *   into the canvas so that the resolution is good enough until the
         *   image gets fully downloaded and a higher-resolution is swapped in
         * 
         * @access public
         * @param  String type
         * @return String|false
         */
        url: function(type) {
            if (type === 'svg') {
                return this._data.urls.svg;
            } else if (type === 'thumb') {
                return this._data.urls.preview;
            } else if (type === 'small') {
                return this._data.urls.small;
            }
            return false;
        },

        /**
         * validate
         * 
         * @access public
         * @var    Object
         */
        validate: {

            /**
             * operation
             * 
             * @access public
             * @param  String type This is the type of operation that is being
             *         validated (eg. feature, save or star). It is important
             *         that this variable is different than the second argument
             *         in the resource/operation/complete-event. It caused a bug
             *         whereby the completed-operation was getting reattempted
             *         because the type-param was named "operation" as well.
             *         Yikes.
             * @param  Array args
             * @return Object
             */
            operation: function(type, args) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                    max = Stencil.get('config').defaults.maxParallelResourceOperations,
                    _this = this,
                    reattemptMinDelay = 2000;
                if (parallelResourceOperations === undefined) {
                    parallelResourceOperations = 0;
                    Stencil.set('parallelResourceOperations', parallelResourceOperations);
                }
                if (parallelResourceOperations >= max) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.operations.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/operation/complete': function(event, operation, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this[type].apply(_this, args);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * feature
             * 
             * @access public
             * @param  CategoryAccessor category
             * @return Object
             */
            feature: function(category) {
                var check = this.validate.operation.apply(this, ['feature', [category]]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures'),
                    max = Stencil.get('config').defaults.maxParallelResourceFeatures,
                    reattemptMinDelay = 2000;
                if (parallelResourceFeatures === undefined) {
                    parallelResourceFeatures = 0;
                    Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
                }
                if (parallelResourceFeatures >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.features.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/feature/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.feature(category);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access public
             * @return Object
             */
            save: function() {
                var check = this.validate.operation.apply(this, ['save', []]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceSaves = Stencil.get('parallelResourceSaves'),
                    max = Stencil.get('config').defaults.maxParallelResourceSaves,
                    reattemptMinDelay = 2000;
                if (parallelResourceSaves === undefined) {
                    parallelResourceSaves = 0;
                    Stencil.set('parallelResourceSaves', parallelResourceSaves);
                }
                if (parallelResourceSaves >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.saves.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/save/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.save();
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * star
             * 
             * @access public
             * @param  String type
             * @return Object
             */
            star: function(type) {
                var check = this.validate.operation.apply(this, ['star', [type]]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceStars = Stencil.get('parallelResourceStars'),
                    max = Stencil.get('config').defaults.maxParallelResourceStars,
                    reattemptMinDelay = 2000;
                if (parallelResourceStars === undefined) {
                    parallelResourceStars = 0;
                    Stencil.set('parallelResourceStars', parallelResourceStars);
                }
                if (parallelResourceStars >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.stars.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/star/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.star(type);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'ShareModel'], function() {

    /**
     * ShareAccessor
     * 
     * @extends Accessor
     */
    window.ShareAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Share'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ShareAccessor')
         */
        _string: 'ShareAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupConnection();
            this._setupImage();
        },

        /**
         * _setupConnection
         * 
         * @access protected
         * @return void
         */
        _setupConnection: function() {
            var model = Stencil.getModel('Connection');
            this._references.connection = model.setAccessor(
                this._data.connection
            );
        },

        /**
         * _setupImage
         * 
         * @access protected
         * @return void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
        },

        /**
         * connection
         * 
         * @access public
         * @return ConnectionAccessor
         */
        connection: function() {
            return this._references.connection;
        },

        /**
         * getPath
         * 
         * Returns the path the user should be sent to after a successful share.
         * Note that while the network-parameter being passed is not currently
         * (at the time of documentation) being used within the
         * application-logic, it is being used by Google Analytics for
         * goal-conversion-tracking.
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            var network = this.connection().get('network'),
                path = '/app/shares/' + (this._data.key) +  '/success' +
                    '?clean=1' +
                    '&network=' + (network);
            return path;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'StarModel'], function() {

    /**
     * StarAccessor
     * 
     * @extends Accessor
     */
    window.StarAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Star'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StarAccessor')
         */
        _string: 'StarAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'TemplateModel'], function() {

    /**
     * TemplateAccessor
     * 
     * @extends Accessor
     */
    window.TemplateAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Template'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateAccessor')
         */
        _string: 'TemplateAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupImage();
            this.on({
                'delete': function(event) {
                    Track.event('Template deleted', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Template featured');
                },
                'star': function(event) {
                    Track.event('Template starred', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Template unfeatured');
                },
                'unstar': function(event) {
                    Track.event('Template unstarred', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                }
            });
        },

        /**
         * _setupImage
         * 
         * @access protected
         * @return void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
            this._references.image.set({template: true});
        },

        /**
         * delete
         * 
         * @access public
         * @return void
         */
        delete: function() {
            var image = this._references.image;
            if (image.get('uploaded').toInt() === 1) {
                App.getBusy().hide();
                if (Stencil.account().draft().getSourceImage() === image) {
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                }
                this._super();
            } else {
                App.getBusy().show();
                image.once({
                    'update/uploaded': this.delete.proxy(this)
                });
            }
        },

        /**
         * feature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        feature: function(category) {
            Stencil.features.add(this);
            category.features.add.apply(category, [this])
            this._model.feature(this._data.key, {
                category: category.get('id').toInt()
            }, (function(data) {
                this.triggerHandler('feature/complete');
            }).proxy(this));
            var slug = category.get('slug'),
                features = App.getEditor().getArea('templates').getChild('search').getChild('categories').getChild(slug).getCollection();
            features.add(this, false);
            this.triggerHandler('feature', [category]);
        },

        /**
         * owned
         * 
         * @access public
         * @return Boolean
         */
        owned: function() {
            return this._references.image.owned();
        },

        /**
         * select
         * 
         * Triggers a template select unless the user isn't a Pro / admin user.
         * At the moment the below logic to hide the spinner is a big hack. Will
         * probably need to deal with this post-launch.
         * 
         * @todo!  Clean up: spinner removal should not be happening here.
         * @access public
         * @param  String type
         * @param  String method
         * @param  Boolean locked
         * @param  Object options
         * @return void
         */
        select: function(type, method, locked, options) {
            if (
                Account.upgraded() === true
                || User.admin() === true
            ) {
                ChangeHistory.setOperationType('template // loaded');
                this._references.image.select(type, method, locked, options);
                // this._references.image.triggerHandler('select');
            } else {
                Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                (function() {
                    App.getElement().find('div.spinning div.spinner').remove();
                    App.getElement().find('div.spinning').removeClass('spinning');
                }).delay(10);
            }
        },

        /**
         * star
         * 
         * @access public
         * @return void
         */
        star: function() {
            Stencil.stars.add(this);
            this._model.star(this._data.key);
            var stars = App.getEditor().getArea('templates').getChild('stars').getCollection();
            stars.add(this, false);
            this.triggerHandler('star');
        },

        /**
         * unfeature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        unfeature: function(category) {
            Stencil.features.remove(this);
            category.features.remove.apply(category, [this])
            this._model.unfeature(this._data.key, {
                category: category.get('id').toInt()
            });
            var slug = category.get('slug'),
                features = App.getEditor().getArea('templates').getChild('search').getChild('categories').getChild(slug).getCollection();
            features.remove(this);
            this.triggerHandler('unfeature', [category]);
        },

        /**
         * unstar
         * 
         * @access public
         * @return void
         */
        unstar: function() {
            Stencil.stars.remove(this);
            this._model.unstar(this._data.key);
            var stars = App.getEditor().getArea('templates').getChild('stars').getCollection();
            stars.remove(this);
            this.triggerHandler('unstar');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'UploadModel'], function() {

    /**
     * UploadAccessor
     * 
     * @events  upload/success
     *          upload/progress
     *          upload/error
     * @extends MediaAccessor
     */
    window.UploadAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UploadAccessor')
         */
        _string: 'UploadAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Upload deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Upload featured');
                },
                'star': function(event) {
                    Track.event('Upload starred', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Upload unfeatured');
                },
                'unstar': function(event) {
                    Track.event('Upload unstarred', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
            this.on({
                'select': function(event, type, method, locked, options) {
                    this.syncDimensions();
                    if (this._data.type === 'graphic') {
                        this._addForegroundBitmapLayer(locked);
                    } else {
                        this._setBackgroundBitmapLayer(locked);
                    }
                }
            });
        },

        /**
         * _addForegroundBitmapLayer
         * 
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _addForegroundBitmapLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.addForegroundBitmapImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * _setBackgroundBitmapLayer
         * 
         * @access protected
         * @param  Boolean locked
         * @return void
         */
        _setBackgroundBitmapLayer: function(locked) {
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundImageLayer(),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('image:changed');
            layer.setImage(this._data.key);
            layer.setProperty('locked', locked);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access private
                 * @return void
                 */
                'refresh': function() {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                }
            });
            drawing.reload();
        },

        /**
         * feature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        feature: function(category) {
            var type = category.get('type'),
                area = (type === 'graphic' ? 'graphics' : 'backgrounds');
            Stencil.features.add(this);
            category.features.add.apply(category, [this])
            this._model.feature(this._data.key, {
                category: category.get('id').toInt()
            }, (function(data) {
                this.triggerHandler('feature/complete');
            }).proxy(this));
            var slug = category.get('slug'),
                features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
            features.add(this, false);
            this.triggerHandler('feature', [category]);
        },

        /**
         * owned
         * 
         * @access public
         * @return Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Preloads alternate resource sizes, including:
         * - The original image, routed through Cloudinary
         * - Preview size, based on the platform wide thumbnail dimensions
         * - 800px wide resource, used for background image setting
         * - 150px wide resource, used in the graphics tab
         * - 160px wide resource, used in the watermarks tab
         * 
         * @todo   Optimize this so only the sizes used for each upload type
                   (eg. background, graphic, watermark) is preloaded
         * @todo   Optimize this so for graphic and watermark uploads, the size
         *         that would be added to the canvas is preloaded (eg. at the
         *         moment, that size is 15% of the canvas).
         * @access public
         * @param  Function success
         * @param  Function error
         * @return void
         */
        preload: function(success, error) {

            // Determine urls
            var urls = [
                this.url('thumb')
            ];
            if (this._data.type === 'watermark') {
                // urls.push(this.url('scale', {width: 160}));
                // urls.push(this.url('thumb'));
            } else if (this._data.type === 'graphic') {
                // urls.push(this.url('scale', {width: 150}));
                // urls.push(this.url('thumb'));
            } else if (this._data.type === 'background') {
                urls.push(this.getFrameUrl(Canvases.Preview));
                // urls.push(this.url('thumb'));
            }

            // Run preload with callback functions
            success = success || function(){};
            error = error || function(){};
            Images.preload(urls, success.proxy(this), error.proxy(this));
        },

        /**
         * star
         * 
         * @access public
         * @param  String type
         * @return void
         */
        star: function(type) {
            var area = (type === 'graphic' ? 'graphics' : 'backgrounds');
            Stencil.stars.add(this);
            this._model.star(this._data.key);
            var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
            stars.add(this, false);
            this.triggerHandler('star');
        },

        /**
         * sync
         * 
         * @access public
         * @return void
         */
        sync: function() {
            this._model.sync(this._data.key);
            this.triggerHandler('sync/start');
        },

        /**
         * syncDimensions
         * 
         * Syncs the width/height of the upload if it's not yet stored in the
         * object. Will only be used via legacy image uploads being selected,
         * since all new ones are routed through /sync against the upload record
         * to have the server pull the width/height in.
         * 
         * @access public
         * @return void
         */
        syncDimensions: function() {
            if (
                this._data.width.toInt() === 0
                || this._data.height.toInt() === 0
            ) {
                var _this = this,
                    image = new Image();
                image.onload = function() {
                    _this.set({
                        'width': image.width,
                        'height': image.height
                    });
                    _this.save(['width', 'height']);
                };
                image.src = this.url('original');
            }
        },

        /**
         * unfeature
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        unfeature: function(category) {
            var type = category.get('type'),
                area = (type === 'graphic' ? 'graphics' : 'backgrounds');
            Stencil.features.remove(this);
            category.features.remove.apply(category, [this])
            this._model.unfeature(this._data.key, {
                category: category.get('id').toInt()
            });
            var slug = category.get('slug'),
                features = App.getEditor().getArea(area).getChild('search').getChild('categories').getChild(slug).getCollection();
            features.remove(this);
            this.triggerHandler('unfeature', [category]);
        },

        /**
         * unstar
         * 
         * @access public
         * @param  String type
         * @return void
         */
        unstar: function(type) {
            var area = (type === 'graphic' ? 'graphics' : 'backgrounds');
            Stencil.stars.remove(this);
            this._model.unstar(this._data.key);
            var stars = App.getEditor().getArea(area).getChild('stars').getCollection();
            stars.remove(this);
            this.triggerHandler('unstar');
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with legacy upload dimension syncing
         * - Scaled image url, used for thumbnails for watermarks and graphics
         * - Thumb image url, used for within Backgrounds and Graphics for
         *   upload thumbs
         * 
         * @access public
         * @param  String type
         * @param  Object|undefined options
         * @return String|false
         */
        url: function(type, options) {
            if (type === 'original') {
                return Images.cloudinary(this._data.key, {
                    type: 'original'
                });
            } else if (type === 'scale') {
                return Images.cloudinary(this._data.key, {
                    type: 'scale',
                    width: options.width
                });
            } else if (type === 'thumb') {
                return Images.cloudinary(this._data.key, {
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UpgradeModel'], function() {

    /**
     * UpgradeAccessor
     * 
     * @extends Accessor
     */
    window.UpgradeAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Upgrade'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UpgradeAccessor')
         */
        _string: 'UpgradeAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupCoupon();
            this._setupCustomer();
            this._setupPromo();
        },

        /**
         * _setupCoupon
         * 
         * @access protected
         * @return void
         */
        _setupCoupon: function() {
            if (this._data.coupon !== false) {
                var model = Stencil.getModel('Coupon');
                this._references.coupon = model.setAccessor(
                    this._data.coupon
                );
            }
        },

        /**
         * _setupCustomer
         * 
         * @access protected
         * @return void
         */
        _setupCustomer: function() {
            if (this._data.customer !== false) {
                var model = Stencil.getModel('Customer');
                this._references.customer = model.setAccessor(
                    this._data.customer
                );
            }
        },

        /**
         * _setupPromo
         * 
         * @access protected
         * @return void
         */
        _setupPromo: function() {
            if (this._data.promo !== false) {
                var model = Stencil.getModel('Promo');
                this._references.promo = model.setAccessor(this._data.promo);
            }
        },

        /**
         * coupon
         * 
         * Returns the CouponAccessor reference for the upgrade.
         * 
         * @access public
         * @return undefined|CouponAccessor
         */
        coupon: function() {
            return this._references.coupon;
        },

        /**
         * customer
         * 
         * Returns the CustomerAccessor reference for the upgrade.
         * 
         * @access public
         * @return CustomerAccessor
         */
        customer: function() {
            return this._references.customer;
        },

        /**
         * getCentsPaid
         * 
         * Returns the number of cents that was processed against the Upgrade
         * record, based on the plan and interval.
         * 
         * @access public
         * @return Number
         */
        // getCentsPaid: function() {
        //     var interval = this._data.interval,
        //         plan = this._data.plan.ucfirst(),
        //         column = (interval) + (plan) + 'Rate';
        //     return this._data[column];
        // },

        /**
         * getTapfiliateCommissionTypeIdentifier
         * 
         * @access public
         * @return String
         */
        getTapfiliateCommissionTypeIdentifier: function() {
            var plan = this._data.plan,
                interval = this._data.interval;
            return (plan) + '-' + (interval);
        },

        /**
         * promo
         * 
         * @access public
         * @return PromoAccessor
         */
        promo: function() {
            return this._references.promo;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UserModel'], function() {

    /**
     * UserAccessor
     * 
     * @extends Accessor
     */
    window.UserAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UserAccessor')
         */
        _string: 'UserAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
            this._setupActive();
            this._setupCustomers();
        },

        /**
         * _setupActive
         * 
         * @note   The problem with this method is it'll overwrite the
         *         already-loaded account, but with less data (since the
         *         server-side call doesn't go deep into the AccountAccessor
         *         reference).
         * @access protected
         * @return void
         */
        _setupActive: function() {
            var model = Stencil.getModel('Account');
            this._references.active = model.setAccessor(
                this._data.active
            );
        },

        /**
         * _setupCustomers
         * 
         * @access protected
         * @return void
         */
        _setupCustomers: function() {
            this._collections.customers = this._collections.customers || new CustomersCollection();
            this._collections.customers.map(this._data.customers, true);
            Account.once({
                'upgrade': this._setupCustomers.proxy(this)
            });
        },

        /**
         * active
         * 
         * Returns the active AccountAccessor for the user. Currently only being
         * used in admin area and analytics below.
         * 
         * @access public
         * @return AccountAccessor
         */
        active: function() {
            return this._references.active;
            // return Stencil.account();
        },

        /**
         * admin
         * 
         * @access public
         * @return Boolean
         */
        admin: function() {
            return this.setting('admin').toInt() === 1;
        },

        /**
         * customer
         * 
         * Returns whether or not the account has a customer record.
         * 
         * @access public
         * @return Boolean
         */
        // customer: function() {
        //     return this._collections.customers.all().length !== 0;
        // },

        /**
         * customers
         * 
         * @access public
         * @param  undefined|Function filter
         * @return Array
         */
        customers: function(filter) {
            if (filter === undefined) {
                return this._collections.customers;
            }
            return this._collections.customers.filter(filter);
        },

        /**
         * getInterval
         * 
         * @access public
         * @return String
         */
        getInterval: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('interval');
            }
            return '';
        },

        /**
         * getPartner
         * 
         * @access public
         * @return String
         */
        getPartner: function() {
            if (this.active().promo() === true) {
                return this.active().upgrade().customer().get('gateway');
            }
            return '';
        },

        /**
         * getPlan
         * 
         * @access public
         * @return String
         */
        getPlan: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('plan');
            }
            return 'free';
        },

        /**
         * getTraits
         * 
         * @todo   Ensure all properties below (eg. frames connections, uploads,
         *         stars) properly sync to Segment when their values change.
         * @note   Properties here need to be set in Segment:
         *         https://i.imgur.com/oonHgPN.png
         *         If they're not set, they own't be received. A way around this
         *         was to have all traits be set as super properties. The
         *         problem with that was properties would be passed along to
         *         events as well.
         * @access public
         * @return Object
         */
        getTraits: function() {
            return {

                // Basics
                _akey: this.active().get('key'),
                _secret: this._data.secret,
                _legacy: this._data.legacy,
                _email: this._data.email,
                _name: this._data.name,
                _plan: this.getPlan(),
                _partner: this.getPartner(),
                _interval: this.getInterval(),
                _promotions: this._data.notification.promotions,
                _resources: this._data.notification.resources,
                _blog: this._data.notification.blog,
                _account: this._data.notification.account,
                _product: this._data.notification.product,

                // Connections
                _connections: this.active().collection('connections').all().length,
                _facebookConnections: this.active().collection('connections').facebook().length,
                _twitterConnections: this.active().collection('connections').twitter().length,

                // Frames
                _frames: this.active().collection('frames').custom().length,

                // Extras
                _stars: this.active().get('stars').length,
                _monthlyMaxImages: this.active().get('monthlyMaxImages'),
                _monthlySavedImages: this.active().get('monthlySavedImages'),
                _totalSavedImages: this.active().get('totalSavedImages'),
                _bonusImages: this.active().get('bonusImages'),
                _tweetBonus: this.active().get('tweetBonus'),
                _shareBonus: this.active().get('shareBonus'),
                _followBonus: this.active().get('followBonus')
            };
        },

        /**
         * showLegacyWelcome
         * 
         * @access public
         * @return void
         */
        showLegacyWelcome: function() {
            if (
                this._data.legacy.toInt() === 1
                && this._data.settings.legacyWelcomed.toInt() === 0
                && Modals.open().length === 0
            ) {
                this.set({
                    'settings.legacyWelcomed': 1
                });
                this.save(['settings.legacyWelcomed']);
                Stencil.navigate('/app/legacy?clean=1');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UserAccountModel'], function() {

    /**
     * UserAccountAccessor
     * 
     * @extends Accessor
     */
    window.UserAccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('UserAccount'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UserAccountAccessor')
         */
        _string: 'UserAccountAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadAccessor', 'WatermarkModel'], function() {

    /**
     * WatermarkAccessor
     * 
     * @extends UploadAccessor
     */
    window.WatermarkAccessor = UploadAccessor.extend({

        /**
         * _lastSavedFiltersString
         * 
         * Reference to the last filter-based JSON string that was saved for
         * this watermark. Used to prevent PATCH calls on an upload when it's
         * underlying filters have not changed.
         * 
         * @access protected
         * @var    String (default: '')
         */
        _lastSavedFiltersString: '',

        /**
         * _lastSavedStylesString
         * 
         * Reference to the last style-based JSON string that was saved for this
         * watermark. Used to prevent PATCH calls on an upload when it's
         * underlying styles have not changed.
         * 
         * @access protected
         * @var    String (default: '')
         */
        _lastSavedStylesString: '',

        /**
         * _layer
         * 
         * @access protected
         * @var    false|Layer (default: false)
         */
        _layer: false,

        /**
         * _model
         * 
         * @access protected
         * @var    WatermarkModel
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _saveFiltersTimeout
         * 
         * @access protected
         * @var    null|Number (default: null)
         */
        _saveFiltersTimeout: null,

        /**
         * _saveStylesTimeout
         * 
         * @access protected
         * @var    null|Number (default: null)
         */
        _saveStylesTimeout: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkAccessor')
         */
        _string: 'WatermarkAccessor',

        /**
         * init
         * 
         * @access public
         * @param  Object data
         * @return void
         */
        init: function(data) {
            if (data.settings.filters === '') {
                // var filters = [];
                // data.settings.filters = JSON.stringify(filters);
// window.t = this;
// StencilBooter.log(String(this));
// StencilBooter.log(JSON.stringify(filters));
//                 this.set({
//                     'settings.filters': JSON.stringify(filters)
//                 });
            }
            this._super(data);
        },

        /**
         * _getDefaultStyles
         * 
         * @access protected
         * @return Object
         */
        _getDefaultStyles: function() {
            return {
                angle: 0,
                flipX: false,
                flipY: false,
                left: 50,
                stretchX: 1,
                stretchY: 1,
                top: 50,
                width: 15
            };
        },

        /**
         * _getLayerFilters
         * 
         * @note   Slicing array here to clone it
         * @see    http://stackoverflow.com/questions/3775480/is-there-a-method-to-clone-an-array-in-jquery
         * @access protected
         * @return Object
         */
        _getLayerFilters: function() {
            return this._layer.getProperty('filters').slice();
        },

        /**
         * _getLayerStyles
         * 
         * @access protected
         * @return Object
         */
        _getLayerStyles: function() {
            var styles = this._layer.getStyles(),
                cloned = jQuery.extend(true, {}, styles);
            delete cloned.order;
            return cloned;
        },

        /**
         * addToCanvas
         * 
         * At the moment, the only time <focus> is set to false is when this
         * method is called from the User.login routine. The intention is to
         * prevent any watermarks from being focused on when they're simply
         * turned on via logging in.
         * 
         * @access protected
         * @param  Boolean focus
         * @return void
         */
        addToCanvas: function(focus) {
            if (
                JSON.valid(this._data.settings.filters) === true
                && JSON.valid(this._data.settings.styles) === true
            ) {
                var filters = JSON.parse(this._data.settings.filters),
                    styles = JSON.parse(this._data.settings.styles),
                    canvas = Canvases.Preview,
                    layer = canvas.addWatermarkBitmapImageLayer({
                        filters: filters,
                        image: this._data.key,
                        styles: styles,
                        type: 'image',
                        watermark: true
                    }),
                    drawing = layer.getDrawing();
                layer.setChangeOperationType('added');
                drawing.once({
                    'draw': function(event) {
                        focus && this.select();
                        canvas.render();
                        drawing.animate();
                    }
                });
                drawing.draw();
            } else {
                StencilBooter.log('JSON parse error (W:aTC)');
            }
        },

        /**
         * clearSaveFiltersTimeout
         * 
         * @access public
         * @return void
         */
        clearSaveFiltersTimeout: function() {
            jQuery.timeoutPool.clear(this._saveFiltersTimeout);
        },

        /**
         * clearSaveStylesTimeout
         * 
         * @access public
         * @return void
         */
        clearSaveStylesTimeout: function() {
            jQuery.timeoutPool.clear(this._saveStylesTimeout);
        },

        /**
         * delete
         * 
         * @access public
         * @return void
         */
        delete: function() {
            // this.set({
            //     'deleted': true
            // });
            Stencil.features.remove(this);
            Stencil.stars.remove(this);
            this.push('usable', 0);
            this.triggerHandler('delete');
            jQuery.each(this._within, function(index, collection) {
                collection.triggerHandler('update');
            });
            // this.removeAll();
        },

        /**
         * markFiltersAsSaved
         * 
         * @access public
         * @return void
         */
        markFiltersAsSaved: function() {
            var filters = this._getLayerFilters();
            this._lastSavedFiltersString = JSON.stringify(filters);
        },

        /**
         * markStylesAsSaved
         * 
         * @access public
         * @return void
         */
        markStylesAsSaved: function() {
            var styles = this._getLayerStyles();
            this._lastSavedStylesString = JSON.stringify(styles);
        },

        /**
         * preloadDrawingImage
         * 
         * @access protected
         * @return void
         */
        preloadDrawingImage: function() {
            if (JSON.valid(this._data.settings.styles) === true) {
                var styles = JSON.parse(this._data.settings.styles),
                    dimensions = Canvases.Preview.getRenderedDimensions(),
                    percentage = styles.width.toFloat() / 100,
                    pixels = (dimensions.width * percentage).round(4);
                pixels = pixels.round(0);
                var ratio = window.devicePixelRatio || 1,
                    key = this._data.key;
                pixels *= ratio;
                if (
                    Stencil.get('config').defaults.roundCloudinaryRequests === true
                ) {
                    var url = Images.cloudinary(key, {
                        type: 'scale',
                        width: pixels.round(0).roundToNext10()
                    });
                } else {
                    var url = Images.cloudinary(key, {
                        type: 'scale',
                        width: pixels.round(0)
                    });
                }
                new Image().src = url;
            } else {
                StencilBooter.log('JSON parse error (W:pDI)');
            }
        },

        /**
         * removeFromCanvas
         * 
         * @access protected
         * @return void
         */
        removeFromCanvas: function() {
            this._layer.triggerHandler('delete');
        },

        /**
         * saveFilters
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access public
         * @return void
         */
        saveFilters: function() {
            if (this.deleted() === false) {
                var filters = this._getLayerFilters(),
                    filtersString = JSON.stringify(filters);
                if (filtersString !== this._lastSavedFiltersString) {
                    this.save(['settings.filters']);
                    this.markFiltersAsSaved();
                }
            }
        },

        /**
         * saveStyles
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access public
         * @return void
         */
        saveStyles: function() {
            if (this.deleted() === false) {
                var styles = this._getLayerStyles(),
                    stylesString = JSON.stringify(styles);
                if (stylesString !== this._lastSavedStylesString) {
                    this.save(['settings.styles']);
                    this.markStylesAsSaved();
                }
            }
        },

        /**
         * setDefaultSettings
         * 
         * @todo!  Handle case where watermark is really tall
         * @access public
         * @return void
         */
        setDefaultSettings: function() {
            var styles = this._getDefaultStyles();
            this.set({
                'settings.filters': JSON.stringify([]),
                'settings.styles': JSON.stringify(styles)
            });
            this.save(['settings.filters', 'settings.styles']);
        },

        /**
         * setFilters
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerFilters>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access public
         * @return void
         */
        setFilters: function() {
            var filters = this._getLayerFilters(),
                delay = Stencil.getSaveDelay('watermark');
            this.set({
                'settings.filters': JSON.stringify(filters)
            });
            Stencil.account().draft().setConfiguration();
            this.clearSaveFiltersTimeout();
            this._saveFiltersTimeout = this.saveFilters.delay(delay, this);
        },

        /**
         * setLayer
         * 
         * @access public
         * @param  WatermarkBitmapLayer layer
         * @return void
         */
        setLayer: function(layer) {
            this._layer = layer;
        },

        /**
         * setStyles
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerStyles>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access public
         * @return void
         */
        setStyles: function() {
            var styles = this._getLayerStyles(),
                delay = Stencil.getSaveDelay('watermark');
            this.set({
                'settings.styles': JSON.stringify(styles)
            });
            Stencil.account().draft().setConfiguration();
            this.clearSaveStylesTimeout();
            this._saveStylesTimeout = this.saveStyles.delay(delay, this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'BackgroundFeatureModel'], function() {

    /**
     * BackgroundFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.BackgroundFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('BackgroundFeature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundFeaturesCollection')
         */
        _string: 'BackgroundFeaturesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = (this._model._base) + '/sort';
            Stencil.ajax({
                signature: {file: 'BackgroundFeatures', line: 56},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('id').toInt(),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'bf73-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'BackgroundResourceModel'], function() {

    /**
     * BackgroundResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.BackgroundResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('BackgroundResource'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundResourcesCollection')
         */
        _string: 'BackgroundResourcesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['StarsCollection', 'BackgroundStarModel'], function() {

    /**
     * BackgroundStarsCollection
     * 
     * @extends StarsCollection
     */
    window.BackgroundStarsCollection = StarsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('BackgroundStar'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundStarsCollection')
         */
        _string: 'BackgroundStarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadsCollection', 'BackgroundUploadModel'], function() {

    /**
     * BackgroundUploadsCollection
     * 
     * @extends UploadsCollection
     */
    window.BackgroundUploadsCollection = UploadsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('BackgroundUpload'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundUploadsCollection')
         */
        _string: 'BackgroundUploadsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CategoryModel'], function() {

    /**
     * CategoriesCollection
     * 
     * @extends Collection
     */
    window.CategoriesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CategoriesCollection')
         */
        _string: 'CategoriesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * backgrounds
         * 
         * @access public
         * @return Array
         */
        backgrounds: function() {
            return this.filter(function(index, category) {
                return category.get('type') === 'background';
            });
        },

        /**
         * graphics
         * 
         * @access public
         * @return Array
         */
        graphics: function() {
            return this.filter(function(index, category) {
                return category.get('type') === 'graphic';
            });
        },

        /**
         * quotes
         * 
         * @access public
         * @return Array
         */
        quotes: function() {
            return this.filter(function(index, category) {
                return category.get('type') === 'quote';
            });
        },

        /**
         * templates
         * 
         * @access public
         * @return Array
         */
        templates: function() {
            return this.filter(function(index, category) {
                return category.get('type') === 'template';
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * Collection
     * 
     * @events  add
     *          remove
     *          update
     *          list
     * @extends Simple
     */
    window.Collection = Simple.extend({

        /**
         * _accessors
         * 
         * @access protected
         * @var    Array
         */
        _accessors: [],

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'collection')
         */
        _handlerType: 'collection',

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _model
         * 
         * @access protected
         * @var    Model (default: null)
         */
        _model: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'Collection')
         */
        _string: 'Collection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
            this._accessors = [];
        },

        /**
         * add
         * 
         * @example Collection.add(Accessor)
         *          Collection.add([Accessor])
         * @note    <within> call below ensures Accessor knows which collections
         *          it's part of, so that it can properly remove itself from
         *          them when it's deleted.
         * @note    <add> event triggered passes in the position within the
         *          collection so that the UI drawn is appropriate (eg. at the
         *          beginning or at the end).
         * @access  public
         * @param   Array|Accessor accessors
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  void
         */
        add: function(accessors, push) {
            var _this = this,
                added = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                ++added;
                if (push === true) {
                    _this._accessors.push(accessor);
                } else {
                    _this._accessors.unshift(accessor);
                }
                accessor.within(_this);
                _this.triggerHandler('add',
                    [accessor, _this._accessors.indexOf(accessor)]
                );
            });
            if (added > 0) {
                this.triggerHandler('update');
            }
        },

        /**
         * all
         * 
         * @access public
         * @return Array
         */
        all: function() {
            return this._accessors;
        },

        /**
         * each
         * 
         * @access public
         * @param  Function iterator
         * @return void
         */
        each: function(iterator) {
            jQuery.each(this._accessors, function(index, accessor) {
                iterator(index, accessor);
            });
        },

        /**
         * empty
         * 
         * @access public
         * @return void
         */
        empty: function() {
            this.remove(this._accessors.slice());
            this.triggerHandler('empty');
        },

        /**
         * filter
         * 
         * @access public
         * @param  Function filter
         * @return Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._accessors, function(index, accessor) {
                if (filter(index, accessor) === true) {
                    matching.push(accessor);
                }
            });
            return matching;
        },

        /**
         * find
         * 
         * @access public
         * @param  String key
         * @return false|Accessor
         */
        find: function(key) {
            var matching = this.filter(function(index, accessor) {
                return accessor.get('key') === key;
            });
            if (matching.length === 0) {
                return false;
            }
            return matching[0];
        },

        /**
         * first
         * 
         * @access public
         * @return Object
         */
        first: function() {
            return this._accessors[0];
        },

        /**
         * last
         * 
         * @access public
         * @return Object
         */
        last: function() {
            var position = this._accessors.length - 1;
            return this._accessors[position];
        },

        /**
         * length
         * 
         * @access public
         * @return Number
         */
        length: function() {
            return this._accessors.length;
        },

        /**
         * list
         * 
         * @note   I check for a "timeout" <textStatus> here (as opposed to
         *         other ajax calls) because there is a higher possibility that
         *         a request times out, since some of the list calls against a
         *         collection will be for Pixabay/The Noun Project, which have
         *         been known to timeout. I've checked the backend, and it looks
         *         like Collection.list calls are currently the only ones that
         *         actually attempt to make a connection to these 3rd parties.
         *         /save, /star and /feature don't, since they depend on passed
         *         in URLs.
         * @todo   Currently, a timeout will result in the same UI as empty
         *         search results. Update it so that it communicates that the
         *         user needs to try again.
         * @access public
         * @param  Object data
         * @param  Function callback
         * @return void
         */
        list: function(data, callback) {
            var _this = this,
                path = this._model.getBase(),
                signature = {file: 'Collection', line: 217};
            Stencil.ajax({
                signature: signature,
                url: path,
                type: 'GET',
                data: data,
                error: function(jqXHR, textStatus, errorThrown) {

                    // Console logging
                    App.log('jQuery AJAX error', true);
                    App.log(signature, true);
                    App.log(arguments, true);

                    // Timeouts are more common with resource collections
                    if (textStatus === 'timeout') {
                        _this.map([], true);
                        callback && callback({
                            data: {
                                more: false
                            }
                        });
                        _this.triggerHandler('list');
                    } else {

                        // Segment tracking
                        Track.event('Ajax Error (Collection)', {
                            _code: signature.line,
                            _reference: signature.file,
                            _data: JSON.stringify(data),
                            _url: path,
                            _textStatus: textStatus
                        });

                        // Connection check
                        Stencil.alive(function() {
                            var code = signature.line,
                                reference = signature.file;
                            Stencil.error(code, reference);
                        });
                    }
                },
                success: function(response) {
                    if (response.success === true) {
                        _this.map(response.data.objects, true);
                        callback && callback(response);
                        _this.triggerHandler('list');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'c247-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * map
         * 
         * Maps raw data to it's associated accessors, and then pushes them into
         * the collection.
         * 
         * @example Collection.map(Object, true)
         *          Collection.map([Object], false)
         * @access  public
         * @param   Array|Object objects
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  Array
         */
        map: function(objects, push) {
            var _this = this,
                accessors = [];
            if (jQuery.isArray(objects) === false) {
                objects = [objects];
            }
            jQuery.each(objects, function(index, obj) {
                accessors.push(_this._model.setAccessor(obj));
            });
            this.add(accessors, push);
            return accessors;
        },

        /**
         * move
         * 
         * @see    http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
         * @access public
         * @param  Accessor accessor
         * @param  Number position
         * @return void
         */
        move: function(accessor, position) {
            var original = this._accessors.indexOf(accessor);
            this._accessors.splice(
                position,
                0,
                this._accessors.splice(original, 1)[0]
            );
            this.triggerHandler('move');
        },

        /**
         * remove
         * 
         * @example Collection.remove(Accessor)
         *          Collection.remove([Accessor])
         * @access  public
         * @param   Array|Accessor accessors
         * @return  Number
         */
        remove: function(accessors) {
            var _this = this,
                removed = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                index = _this._accessors.indexOf(accessor);
                if (index !== -1) {
                    ++removed;
                    _this._accessors.splice(index, 1);
                    _this.triggerHandler('remove', [accessor]);
                }
            });
            if (removed > 0) {
                this.triggerHandler('update');
            }
            return removed;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ConnectionModel'], function() {

    /**
     * ConnectionsCollection
     * 
     * @extends Collection
     */
    window.ConnectionsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConnectionsCollection')
         */
        _string: 'ConnectionsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function() {
            //         Track.user();
            //     }
            // });
        },

        /**
         * facebook
         * 
         * @access public
         * @return Array
         */
        facebook: function() {
            return this.network('facebook');
        },

        /**
         * network
         * 
         * @access public
         * @param  String network
         * @return Array
         */
        network: function(network) {
            return this.filter(function(index, connection) {
                return connection.get('network') === network;
            });
        },

        /**
         * twitter
         * 
         * @access public
         * @return Array
         */
        twitter: function() {
            return this.network('twitter');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CouponModel'], function() {

    /**
     * CouponsCollection
     * 
     * @extends Collection
     */
    window.CouponsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CouponsCollection')
         */
        _string: 'CouponsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CustomerModel'], function() {

    /**
     * CustomersCollection
     * 
     * @extends Collection
     */
    window.CustomersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CustomersCollection')
         */
        _string: 'CustomersCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FeatureModel'], function() {

    /**
     * FeaturesCollection
     * 
     * @extends Collection
     */
    window.FeaturesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FeaturesCollection')
         */
        _string: 'FeaturesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FontModel'], function() {

    /**
     * FontsCollection
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/all/normal
     * @extends Collection
     */
    window.FontsCollection = Collection.extend({

        /**
         * _loaded
         * 
         * Keeps track of fonts that have been loaded using familyName:n4
         * notation. This ensures that there aren't race-conditions between
         * loading the normal versions of fonts, and the full versions (which
         * may include bold, italic and/or bold + italic versions).
         * 
         * @access protected
         * @var    Array (default: [])
         */
        _loaded: [],

        /**
         * _loading
         * 
         * @access protected
         * @var    Array (default: [])
         */
        _loading: [],

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FontsCollection')
         */
        _string: 'FontsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * findByFamilyName
         * 
         * @access public
         * @param  String familyName
         * @return false|FontAccessor
         */
        findByFamilyName: function(familyName) {
            var fonts = this.filter(function(index, font) {
                return font.get('familyName') === familyName;
            });
            if (fonts.length === 0) {
                return false;
            }
            return fonts.shift();
        },

        /**
         * getDefaults
         * 
         * @access public
         * @return Array
         */
        getDefaults: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 0;
            });
        },

        /**
         * getLoaded
         * 
         * @access public
         * @return Array
         */
        getLoaded: function() {
            return this._loaded;
        },

        /**
         * getLoading
         * 
         * @access public
         * @return Array
         */
        getLoading: function() {
            return this._loading;
        },

        /**
         * getUploaded
         * 
         * @access public
         * @return Array
         */
        getUploaded: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 1
                    && font.get('hasRegularAccess').toInt() === 1;
            });
        },

        /**
         * loadAllNormal
         * 
         * @access public
         * @param  Array fontsToExclude
         * @return void
         */
        loadAllNormal: function(fontsToExclude) {

            /**
             * Group fonts to load by whether they were uploaded or not
             * (excluding native and intentionally-excluded fonts).
             */
            var googleFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('isLegacyFont') === false
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 0;
                }),
                customFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 1;
                });

            // Reformat the arrays for WebFont compatibility, and track them
            var googleFontFamiliesToLoad = (function(googleFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in googleFontsToLoad) {
                        familyName = googleFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName)
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [googleFontsToLoad]),
                customFontFamiliesToLoad = (function(customFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in customFontsToLoad) {
                        familyName = customFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName)
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: replaceFontColons(customFontFamiliesToLoad)
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                google: {
                    families: replaceFontColons(googleFontFamiliesToLoad)
                },
                timeout: 5000
            });
        },

        /**
         * loadUploadedNormal
         * 
         * @access public
         * @return void
         */
        loadUploadedNormal: function() {

            // Get the uploaded FontAccessor's
            var customFontsToLoad = this.filter(function(index, font) {
                var familyName = font.get('familyName');
                return font.get('native').toInt() === 0
                    && font.get('uploaded').toInt() === 1;
            });

            // Reformat the fonts for WebFont compatibility, and track them
            var customFontFamiliesToLoad = (function(customFontsToLoad) {
                var familyNames = [], index, familyName;
                for (index in customFontsToLoad) {
                    familyName = customFontsToLoad[index].get('familyName');
                    familyName += ':n4';
                    this._loading.push(familyName)
                    familyNames.push(familyName);
                }
                return familyNames;
            }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: customFontFamiliesToLoad
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                timeout: 5000
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FrameModel'], function() {

    /**
     * FramesCollection
     * 
     * @extends Collection
     */
    window.FramesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FramesCollection')
         */
        _string: 'FramesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function() {
            //         Track.user();
            //     }
            // });
        },

        /**
         * custom
         * 
         * @access public
         * @return Array
         */
        custom: function() {
            return this.filter(function(index, frame) {
                return frame.get('type') === 'custom';
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'GoogleFontModel'], function() {

    /**
     * GoogleFontsCollection
     * 
     * @extends Collection
     */
    window.GoogleFontsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GoogleFontsCollection')
         */
        _string: 'GoogleFontsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'GraphicFeatureModel'], function() {

    /**
     * GraphicFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.GraphicFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GraphicFeature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicFeaturesCollection')
         */
        _string: 'GraphicFeaturesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = (this._model._base) + '/sort';
            Stencil.ajax({
                signature: {file: 'GraphicFeatures', line: 55},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('id').toInt(),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'gf66-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'GraphicResourceModel'], function() {

    /**
     * GraphicResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.GraphicResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GraphicResource'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicResourcesCollection')
         */
        _string: 'GraphicResourcesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['StarsCollection', 'GraphicStarModel'], function() {

    /**
     * GraphicStarsCollection
     * 
     * @extends StarsCollection
     */
    window.GraphicStarsCollection = StarsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GraphicStar'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicStarsCollection')
         */
        _string: 'GraphicStarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadsCollection', 'GraphicUploadModel'], function() {

    /**
     * GraphicUploadsCollection
     * 
     * @extends UploadsCollection
     */
    window.GraphicUploadsCollection = UploadsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('GraphicUpload'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicUploadsCollection')
         */
        _string: 'GraphicUploadsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ImageModel'], function() {

    /**
     * ImagesCollection
     * 
     * @extends Collection
     */
    window.ImagesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImagesCollection')
         */
        _string: 'ImagesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['StarsCollection', 'ImageStarModel'], function() {

    /**
     * ImageStarsCollection
     * 
     * @extends StarsCollection
     */
    window.ImageStarsCollection = StarsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('ImageStar'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageStarsCollection')
         */
        _string: 'ImageStarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'PromoSetModel'], function() {

    /**
     * PromoSetsCollection
     * 
     * @extends Collection
     */
    window.PromoSetsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoSetsCollection')
         */
        _string: 'PromoSetsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'QuoteFeatureModel'], function() {

    /**
     * QuoteFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.QuoteFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('QuoteFeature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteFeaturesCollection')
         */
        _string: 'QuoteFeaturesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = (this._model._base) + '/sort';
            Stencil.ajax({
                signature: {file: 'QuoteFeatures', line: 54},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('id').toInt(),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'bf73-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'QuoteResourceModel'], function() {

    /**
     * QuoteResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.QuoteResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('QuoteResource'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteResourcesCollection')
         */
        _string: 'QuoteResourcesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['StarsCollection', 'QuoteStarModel'], function() {

    /**
     * QuoteStarsCollection
     * 
     * @extends StarsCollection
     */
    window.QuoteStarsCollection = StarsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('QuoteStar'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteStarsCollection')
         */
        _string: 'QuoteStarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ResourceModel'], function() {

    /**
     * ResourcesCollection
     * 
     * @extends Collection
     */
    window.ResourcesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ResourcesCollection')
         */
        _string: 'ResourcesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'StarModel'], function() {

    /**
     * StarsCollection
     * 
     * @extends Collection
     */
    window.StarsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Star'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StarsCollection')
         */
        _string: 'StarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'TemplateFeatureModel'], function() {

    /**
     * TemplateFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.TemplateFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('TemplateFeature'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateFeaturesCollection')
         */
        _string: 'TemplateFeaturesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access public
         * @param  CategoryAccessor category
         * @return void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = (this._model._base) + '/sort';
            Stencil.ajax({
                signature: {file: 'TemplateFeatures', line: 56},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('id').toInt(),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'tf73-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'TemplateModel'], function() {

    /**
     * TemplatesCollection
     * 
     * @extends Collection
     */
    window.TemplatesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Template'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplatesCollection')
         */
        _string: 'TemplatesCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['StarsCollection', 'TemplateStarModel'], function() {

    /**
     * TemplateStarsCollection
     * 
     * @extends StarsCollection
     */
    window.TemplateStarsCollection = StarsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('TemplateStar'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateStarsCollection')
         */
        _string: 'TemplateStarsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'UploadModel'], function() {

    /**
     * UploadsCollection
     * 
     * @extends Collection
     */
    window.UploadsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UploadsCollection')
         */
        _string: 'UploadsCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'UserModel'], function() {

    /**
     * UsersCollection
     * 
     * @extends Collection
     */
    window.UsersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UsersCollection')
         */
        _string: 'UsersCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadsCollection', 'UploadModel'], function() {

    /**
     * WatermarksCollection
     * 
     * @extends UploadsCollection
     */
    window.WatermarksCollection = UploadsCollection.extend({

        /**
         * _model
         * 
         * @access protected
         * @var    Model
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarksCollection')
         */
        _string: 'WatermarksCollection',

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * usable
         * 
         * @access public
         * @return Array
         */
        usable: function() {
            return this.filter(function(index, accessor) {
                return accessor.get('usable').toInt() === 1;
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * AccountsController
     * 
     * @extends AppController
     */
    window.AccountsController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * checkout
         * 
         * @access public
         * @param  String plan
         * @param  Object params
         * @return void
         */
        checkout: function(plan, params) {
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan);
                if (type === 'curtain') {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (
                    Account.upgraded() === true
                    || User.admin() === true
                ) {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/free');
                } else {
                    this.track.event({
                        _plan: plan,
                        _type: type
                    });
                    this.track.page();
                    Modals.closeExcept(['Checkout']);
                    Modals.get('Checkout') || Modals.showCheckout(plan, type);
                    App.unrestrict();
                }
            }
        },

        /**
         * connections
         * 
         * @access public
         * @param  String network
         * @param  Object params
         * @return void
         */
        connections: function(type, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/settings/' + (type) + '/connected';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('social').show();
                Modals.showConnections(type);
                App.unrestrict();
            }
        },

        /**
         * countdown
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        countdown: function(params) {
            if (
                (
                    Account.upgraded() === true
                    && Stencil.account().get('monthlyMaxImages').toInt() === 0
                )
                || User.admin() === true
            ) {
                Stencil.navigate('/app/not/upgraded');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showCountdown(params.onboard !== undefined);
                App.unrestrict();
            }
        },

        /**
         * plan
         * 
         * @access public
         * @var    Object
         */
        plan: {

            /**
             * switch
             * 
             * @access public
             * @param  String plan
             * @param  Object params
             * @return void
             */
            switch: function(plan, params) {
                this.track.event();
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('plan').show();
                Modals.showPlanSwitch(plan);
                App.unrestrict();
            },

            /**
             * switched
             * 
             * @access public
             * @param  String plan
             * @param  Object data
             * @param  Object params
             * @return void
             */
            switched: function(plan, data, params) {
                this.track.event();
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('plan').show();
                Modals.showPlanSwitched(plan, data);
                App.unrestrict();
            }
        },

        /**
         * plans
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        plans: function(params) {
            // if (
            //     (
            //         Account.upgraded() === true
            //         && Account.plan('unlimited') === true
            //     )
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showPlans({
                    curtain: params.curtain !== undefined
                });
                App.unrestrict();
            }
        },

        /**
         * upgrade
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String plan
         * @param  String reason
         * @param  Object params
         * @return void
         */
        upgrade: function(plan, reason, params) {
            // if (
            //     Account.upgraded() === true
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event({
                    _plan: plan,
                    _reason: reason
                });
                this.track.page();
                if (params.additive === undefined) {
                    Modals.close();
                }
                Modals.showUpgrade(plan, reason);
                App.unrestrict();
            }
        },

        /**
         * upgraded
         * 
         * @access public
         * @param  String plan
         * @param  Object params
         * @return void
         */
        upgraded: function(plan, params) {
            if (Account.upgraded() === false) {
            // if (false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event({
                    _plan: plan
                });
                this.track.page();
                Modals.closeExcept(['Upgraded']);
                Modals.get('Upgraded') || Modals.showUpgraded(plan);
                App.unrestrict();
            }
        },

        /**
         * welcomeTour
         * 
         * @access public
         * @param  String step
         * @param  Object params
         * @return void
         */
        welcomeTour: function(step, params) {
            if (params === undefined) {
                params = step;
                step = 1;
            }
            this.track.event({
                _step: step
            });
            this.track.page();
            Modals.closeExcept(['WelcomeTour']);
            var modal = Modals.get('WelcomeTour') || Modals.showWelcomeTour();
            modal.step(step);
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * AdminController
     * 
     * @extends AppController
     */
    window.AdminController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * cacheRefresh
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        cacheRefresh: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/' + (section);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    Modals.showCacheRefresh();
                    App.unrestrict();
                }
            }
        },

        /**
         * section
         * 
         * @access public
         * @param  String section
         * @param  Object params
         * @return void
         */
        section: function(section, params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/' + (section);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event({
                        _section: section
                    });
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection(section).show();
                    App.unrestrict();
                }
            }
        },

        /**
         * images
         * 
         * @access public
         * @var    Object
         */
        images: {

            /**
             * results
             * 
             * @access public
             * @param  String query
             * @param  Object params
             * @return void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/images';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin();
                        modal.getSection('images').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            }
        },

        /**
         * users
         * 
         * @access public
         * @var    Object
         */
        users: {

            /**
             * results
             * 
             * @access public
             * @param  String query
             * @param  Object params
             * @return void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users';
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin();
                        modal.getSection('users').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            },

            /**
             * search
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            search: function(params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/' + (section);
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin(),
                            section = modal.getSection('users'),
                            query = section.getQuery();
                        section.show(query);
                        Modals.showSearchUsers(section);
                        App.unrestrict();
                    }
                }
            },

            /**
             * update
             * 
             * @access public
             * @param  String key
             * @param  Object params
             * @return void
             */
            update: function(key, params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/' + (section);
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin(),
                            section = modal.getSection('users'),
                            query = section.getQuery();
                        section.show(query || '');
                        Modals.showUpdateUser(key, section);
                        App.unrestrict();
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Controller', function() {

    /**
     * AppController
     * 
     * @extends Controller
     */
    window.AppController = Controller.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * _getRouter
         * 
         * @access protected
         * @return Router
         */
        _getRouter: function() {
            return Stencil.getRouter();
        },

        /**
         * _store
         * 
         * Stores the path currently being experienced.
         * 
         * @access protected
         * @return void
         */
        _store: function() {
            var path = '/' + (this._getRouter().current().fragment);
            this._getRouter().setPrevious(path);
        },

        /**
         * alert
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String code
         * @param  Object params
         * @return void
         */
        alert: function(code, params) {
            if (Stencil.get('alive') === true) {
                this.track.event({
                    _code: code
                });
                this.track.page();
            }
            Alerts.show(code);
            App.unrestrict();
        },

        /**
         * browser
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        browser: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.show('Browser');
            App.unrestrict();
        },

        /**
         * chromeSuccess
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        chromeSuccess: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showChromeExtensionInstalled();
            App.unrestrict();
        },

        /**
         * cookies
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        cookies: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.show('Cookies');
            App.unrestrict();
        },

        /**
         * error
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String code
         * @param  String reference
         * @param  Object params
         * @return void
         */
        error: function(code, reference, params) {
            Stencil.queue.pause();
            this.track.event({
                _code: code,
                _reference: reference
            });
            this.track.page();
            Modals.close();
            Modals.show('Error', {
                code: code,
                reference: reference
            });
            App.unrestrict();
        },

        /**
         * extras
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        extras: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showExtras();
            App.unrestrict();
        },

        /**
         * googleFonts
         * 
         * @access public
         * @return void
         */
        googleFonts: function() {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showGoogleFonts().show();
            App.unrestrict();
        },

        /**
         * legacy
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        legacy: function(params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.show('Legacy');
                App.unrestrict();
            }
        },

        /**
         * orientation
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        orientation: function(params) {
            this.track.event();
            this.track.page();
            Modals.show('Orientation');
            App.unrestrict();
        },

        /**
         * track
         * 
         * @access public
         * @var    Object
         */
        track: {

            /**
             * event
             * 
             * Tracks an event relative to the current controller/action.
             * 
             * @access protected
             * @param  Object|undefined properties
             * @return void
             */
            event: function(properties) {
                var name = String(Stencil.getRouter().current().route);
                Track.event(name, properties || {});
            },

            /**
             * page
             * 
             * Tracks an page relative to the current controller/action.
             * 
             * @access protected
             * @param  String|undefined path
             * @return void
             */
            page: function(path) {
                var path = Backbone.history.fragment;
                Track.page('/' + path);
            }
        },

        /**
         * tutorials
         * 
         * @access public
         * @param  String slug
         * @param  Object params
         * @return void
         */
        tutorials: function(slug, params) {
            var tutorials = Stencil.get('config').defaults.tutorials,
                valid = function(slug) {
                    for (var index in tutorials) {
                        if (slug === tutorials[index].slug) {
                            return true;
                        }
                    }
                    return false;
                };
            if (valid(slug) === false) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _slug: slug
                });
                this.track.page();
                Modals.close();
                Modals.closeExcept(['Tutorials']);
                var modal = Modals.get('Tutorials') || Modals.showTutorials();
                modal.getTutorials(slug).show();
                App.unrestrict();
            }
        },

        /**
         * wildcard
         * 
         * @access public
         * @param  String fragment
         * @param  Object params
         * @return void
         */
        wildcard: function(fragment, params) {
            var redirects = Stencil.getRouter().getRedirects(),
                index,
                regEx,
                path = '/app';
            for (index in redirects) {
                regEx = new RegExp(index, 'i');
                if (regEx.test(fragment) === true) {
                    path = '/' + (fragment.replace(regEx, redirects[index]));
                }
            }
            Backbone.history.navigate(
                path,
                {
                    trigger: true,
                    replace: true
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * BackgroundsController
     * 
     * @extends AppController
     */
    window.BackgroundsController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * categories
         * 
         * @access public
         * @param  String slug
         * @param  Object params
         * @return void
         */
        categories: function(slug, params) {
            var categories = Stencil.get('categories').filter(
                function(index, category) {
                    return category.get('type') === 'background'
                        && category.get('slug') === slug;
                }
            );
            if (categories.length === 0) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                App.getEditor().getArea('backgrounds').getChild('search').getChild('categories').getChild(slug).show();
                Modals.close();
                App.unrestrict();
            }
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('backgrounds').getChild('search').getChild('categories').getChild('featured').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Object params
         * @return void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('backgrounds').getChild('search').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * stars
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        stars: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('backgrounds').getChild('stars').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * uploads
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        uploads: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('backgrounds').getChild('uploads').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * CategoriesController
     * 
     * @extends AppController
     */
    window.CategoriesController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/categories/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('categories').show();
                    Modals.showAddCategory();
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Class', function() {

    /**
     * Controller
     * 
     * @extends Class
     */
    window.Controller = Class.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * CouponsController
     * 
     * @extends AppController
     */
    window.CouponsController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        add: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/coupons/add';
                redirect =  encodeURIComponent(redirect);
                path += '?redirect' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('coupons').show();
                    Modals.showAddCoupon();
                    App.unrestrict();
                }
            }
        },

        /**
         * apply
         * 
         * @access public
         * @param  String plan
         * @param  String code
         * @param  Object params
         * @return void
         */
        apply: function(plan, code, params) {
            if (typeof code === 'object') {
                params = code;
                code = false;
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan) + '/coupon';
                if (code !== false) {
                    redirect += '/' + (code);
                }
                if (location.href.match(/curtain/) !== null) {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (Account.upgraded() === true) {
                    Stencil.navigate('/app/only/free');
                } else {
                    // this._store();
                    if (code === false) {
                        // params = code;
                        // code = false;
                        this.track.event({
                            _plan: plan
                        });
                    } else {
                        this.track.event({
                            _plan: plan,
                            _code: code
                        });
                    }
                    this.track.page();
                    Modals.closeExcept(['Checkout']);

                    // Grab checkout modal or open a new one
                    var type = 'direct';
                    if (params.curtain) {
                        type = 'curtain';
                    }
                    var modal = Modals.get('Checkout') || Modals.showCheckout(plan, type);

                    // Throw in the code if it's defined
                    if (code) {
                        Modals.showApplyCoupon(modal, code);
                    } else {
                        Modals.showApplyCoupon(modal);
                    }

                    // Ensure the app is not blocked with the busy modal
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * GraphicsController
     * 
     * @extends AppController
     */
    window.GraphicsController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * categories
         * 
         * @access public
         * @param  String slug
         * @param  Object params
         * @return void
         */
        categories: function(slug, params) {
            var categories = Stencil.get('categories').filter(
                function(index, category) {
                    return category.get('type') === 'graphic'
                        && category.get('slug') === slug;
                }
            );
            if (categories.length === 0) {
                var path = '/app/icons';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                App.getEditor().getArea('graphics').getChild('search').getChild('categories').getChild(slug).show();
                Modals.close();
                App.unrestrict();
            }
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('graphics').getChild('search').getChild('categories').getChild('featured').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Object params
         * @return void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('graphics').getChild('search').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * stars
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        stars: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('graphics').getChild('stars').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * uploads
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        uploads: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('graphics').getChild('uploads').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * ImagesController
     * 
     * @extends AppController
     */
    window.ImagesController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('images').getChild('all').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * error
         * 
         * @note   Only accessed via ?clean=1
         * @note   Action logic isn't wrapped in record-lookup since this can
         *         currently only be accessed from within the app and a
         *         conventional flow. If this page needed to be accessed
         *         statically, then I'd need a lookup (for when it's accessed
         *         directly).
         * @access public
         * @param  String key
         * @param  String connection
         * @param  Object params
         * @return void
         */
        error: function(key, connection, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key,
                    _connection: connection
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    connection = Stencil.getAccessor(connection),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                Modals.showShareError(modal, image, connection);
                App.unrestrict();
            }
        },

        /**
         * normalize
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String key
         * @param  Object params
         * @return void
         */
        normalize: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.close();
                Modals.showLegacyImageNormalize(key);
                App.unrestrict();
            }
        },

        /**
         * sent
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String key
         * @param  Object params
         * @return void
         */
        sent: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork('instagram').show();
                Modals.showSent(modal, image);
                App.unrestrict();
            }
        },

        /**
         * share
         * 
         * @access public
         * @param  String key
         * @param  String network
         * @param  Object params
         * @return void
         */
        share: function(key, network, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/images/' + (key) + '/share/' + (network);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                var show = function(image) {
                    var modal = Modals.get('Share') || Modals.showShare(image);
                    modal.getNetwork(network).show();
                    App.unrestrict();
                };
                this.track.event({
                    _key: key,
                    _network: network
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key);
                if (image === false) {
                    App.getBusy().show();
                    var model = Stencil.getModel('Image');
                    model.read(key, function(data) {
                        App.getBusy().hide();
                        var image = model.setAccessor(data.object);
                        show(image);
                    });
                } else {
                    show(image);
                }
            }
        },

        /**
         * stars
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        stars: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('images').getChild('stars').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * PromoSetsController
     * 
     * @extends AppController
     */
    window.PromoSetsController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/promoSets/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('promoSets').show();
                    Modals.showAddPromoSet();
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * QuotesController
     * 
     * @extends AppController
     */
    window.QuotesController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * categories
         * 
         * @access public
         * @param  String slug
         * @param  Object params
         * @return void
         */
        categories: function(slug, params) {
            var categories = Stencil.get('categories').filter(
                function(index, category) {
                    return category.get('type') === 'quote'
                        && category.get('slug') === slug;
                }
            );
            if (categories.length === 0) {
                var path = '/app/quotes';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                App.getEditor().getArea('quotes').getChild('search').getChild('categories').getChild(slug).show();
                Modals.close();
                App.unrestrict();
            }
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('quotes').getChild('search').getChild('categories').getChild('featured').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Object params
         * @return void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('quotes').getChild('search').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * stars
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        stars: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('quotes').getChild('stars').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * SharesController
     * 
     * @extends AppController
     */
    window.SharesController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * success
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  String key
         * @param  Object params
         * @return void
         */
        success: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var share = Stencil.getAccessor(key),
                    connection = share.reference('connection'),
                    image = share.reference('image'),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                Modals.showShareSuccess(modal, share);
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * TemplatesController
     * 
     * @extends AppController
     */
    window.TemplatesController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * categories
         * 
         * @access public
         * @param  String slug
         * @param  Object params
         * @return void
         */
        categories: function(slug, params) {
            var categories = Stencil.get('categories').filter(
                function(index, category) {
                    return category.get('type') === 'template'
                        && category.get('slug') === slug;
                }
            );
            if (categories.length === 0) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                App.getEditor().getArea('templates').getChild('search').getChild('categories').getChild(slug).show();
                Modals.close();
                App.unrestrict();
            }
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('templates').getChild('search').getChild('categories').getChild('all').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * saved
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        saved: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('templates').getChild('saved').show();
            Modals.close();
            App.unrestrict();
        },

        /**
         * stars
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        stars: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('templates').getChild('stars').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * UsersController
     * 
     * @extends AppController
     */
    window.UsersController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * delinquent
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        delinquent: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.show('Delinquent');
                App.unrestrict();
            }
        },

        /**
         * login
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        login: function(params) {
            if (User.exists() === true) {
                if (params.redirect) {
                    Stencil.navigate(params.redirect);
                } else {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/guests');
                }
            } else {
                Stencil.queue.pause();
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showLogin(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * onboard
         * 
         * @note   Only accessed via ?clean=1
         * @access public
         * @param  Object params
         * @return void
         */
        onboard: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/users');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showOnboard();
                App.unrestrict();
            }
        },

        /**
         * password
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        password: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showPassword(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * promo
         * 
         * @access public
         * @param  String|undefined partner
         * @param  Object params
         * @return void
         */
        promo: function(partner, params) {
            if (typeof partner === 'object') {
                params = partner;
                partner = false;
            }
            Stencil.queue.pause();
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            this.track.event({
                _type: type
            });
            this.track.page();
            Modals.close();
            Modals.showPromo(partner, type, params.redirect || false);
            App.unrestrict();
        },

        /**
         * settings
         * 
         * @access public
         * @var    Object
         */
        settings: {

            /**
             * notifications
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            notifications: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/notifications';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('notifications').show();
                    App.unrestrict();
                }
            },

            /**
             * plan
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            plan: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/plan';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('plan').show();
                    App.unrestrict();
                }
            },

            /**
             * profile
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            profile: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/profile';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('profile').show();
                    App.unrestrict();
                }
            },

            /**
             * social
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            social: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/social';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('social').show();
                    App.unrestrict();
                }
            },

            /**
             * password
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            password: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/password';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('password').show();
                    App.unrestrict();
                }
            },

            /**
             * payment
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            payment: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/payment';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            Modals.closeExcept(['Settings']);
                            var modal = Modals.get('Settings') || Modals.showSettings();
                            modal.getSettings('payment').show();
                            App.unrestrict();
                        }
                    }
                }
            },

            /**
             * referral
             * 
             * @access public
             * @param  Object params
             * @return void
             */
            referral: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/referral';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            Modals.closeExcept(['Settings']);
                            var modal = Modals.get('Settings') || Modals.showSettings();
                            modal.getSettings('referral').show();
                            App.unrestrict();
                        }
                    }
                }
            }
        },

        /**
         * signup
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        signup: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                Stencil.queue.pause();
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showSignup(type, params.redirect || false);
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * WatermarksController
     * 
     * @extends AppController
     */
    window.WatermarksController = AppController.extend({

        /**
         * init
         * 
         * @access public
         * @return void
         */
        init: function() {
            this._super();
        },

        /**
         * index
         * 
         * @access public
         * @param  Object params
         * @return void
         */
        index: function(params) {
            this._store();
            this.track.event();
            this.track.page();
            App.getEditor().getArea('watermarks').getChild('all').show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminCategoriesView
     * 
     * @extends AdminSectionView
     */
    window.AdminCategoriesView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    CategoriesCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'categories')
         */
        _section: 'categories',

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminCategoriesView')
         */
        _string: 'AdminCategoriesView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawCategory
         * 
         * @access protected
         * @param  CategoryAccessor category
         * @param  Number position
         * @return void
         */
        _drawCategory: function(category, position) {
            var $row = Stencil.render('AdminCategoryRow', {
                category: category
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminCategoryRowView($row, category);
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CategoriesCollection();
            this._collection.on({
                'add': function(event, category, position) {
                    _this._drawCategory(category, position);
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this;
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: Stencil.get('config').defaults.objectsPerPage.admin.categories,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminCategoryRowView
     * 
     * @extends View
     */
    window.AdminCategoryRowView = View.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminCategoryRowView')
         */
        _string: 'AdminCategoryRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, category) {
            this._super(element);
            this._category = category;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._category.on({
                'delete': function() {
                    // var collection = Modals.get('Admin').getSection('categories')._collection;
                    _this._element.remove();
                    // _this.clean();
                    // collection.remove(_this._category);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @return void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this category?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function() {
                    _this._category.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminCouponRowView
     * 
     * @extends View
     */
    window.AdminCouponRowView = View.extend({

        /**
         * _coupon
         * 
         * @access protected
         * @var    CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $checkbox
                     * @return void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked');
                        if (checked === true) {
                            this._coupon.set({
                                'active': 1
                            });
                        } else {
                            this._coupon.set({
                                'active': 0
                            });
                        }
                        this._coupon.save(['active']);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminCouponRowView')
         */
        _string: 'AdminCouponRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  CouponAccessor coupon
         * @return void
         */
        init: function(element, coupon) {
            this._super(element);
            this._coupon = coupon;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._coupon.on({
                'delete': function() {
                    // var collection = Modals.get('Admin').getSection('coupons')._collection;
                    _this._element.remove();
                    // _this.clean();
                    // collection.remove(_this._coupon);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @return void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this coupon?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function() {
                    _this._coupon.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminCouponsView
     * 
     * @extends AdminSectionView
     */
    window.AdminCouponsView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    CouponsCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'coupons')
         */
        _section: 'coupons',

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminCouponsView')
         */
        _string: 'AdminCouponsView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawCoupon
         * 
         * @access protected
         * @param  CouponAccessor coupon
         * @param  Number position
         * @return void
         */
        _drawCoupon: function(coupon, position) {
            var $row = Stencil.render('AdminCouponRow', {
                coupon: coupon
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminCouponRowView($row, coupon);
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CouponsCollection();
            this._collection.on({
                'add': function(event, coupon, position) {
                    _this._drawCoupon(coupon, position);
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this;
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: Stencil.get('config').defaults.objectsPerPage.admin.coupons,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminDashboardView
     * 
     * @extends AdminSectionView
     */
    window.AdminDashboardView = AdminSectionView.extend({

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'dashboard')
         */
        _section: 'dashboard',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminDashboardView')
         */
        _string: 'AdminDashboardView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminImageRowView
     * 
     * @extends View
     */
    window.AdminImageRowView = View.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminImageRowView')
         */
        _string: 'AdminImageRowView',

        /**
         * _image
         * 
         * @access protected
         * @var    Object (default: null)
         */
        _image: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  Object image
         * @return void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this.on({
                'open': function(event) {
                    var url = Images.s3(this._image.get('key'));
                    window.open(url);
                    // window.open(this._image.url('original'));
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminImagesView
     * 
     * @extends AdminSectionView
     */
    window.AdminImagesView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _more: false,

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'images')
         */
        _section: 'images',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminImagesView')
         */
        _string: 'AdminImagesView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 500)
         */
        _threshold: 500,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawImage
         * 
         * @access protected
         * @param  ImageAccessor image
         * @param  Number position
         * @return void
         */
        _drawImage: function(image, position) {
            var $row = Stencil.render('AdminImageRow', {
                image: image
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminImageRowView($row, image);
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new ImagesCollection();
            this._collection.on({
                'add': function(event, image, position) {
                    _this._drawImage(image, position);
                },
                'empty': function(event) {
                    _this.find('div.image').remove();
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            // if (this._query === false || this._query === '') {
                return '/app/admin/images';
            // }
            // var encoded = encodeURIComponent(this._query);
            // return '/app/admin/images/search/' + (encoded);
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this;
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                all: 1,
                limit: Stencil.get('config').defaults.objectsPerPage.admin.images,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
            // if (this._query !== query) {
                this.unload();
                // this._query = query;
                this.load();
            }
        },

        /**
         * unload
         * 
         * @access public
         * @return void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminPromoSetRowView
     * 
     * @extends View
     */
    window.AdminPromoSetRowView = View.extend({

        /**
         * _promoSet
         * 
         * @access protected
         * @var    PromoSetAccessor (default: null)
         */
        _promoSet: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminPromoSetRowView')
         */
        _string: 'AdminPromoSetRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  PromoSetAccessor promoSet
         * @return void
         */
        init: function(element, promoSet) {
            this._super(element);
            this._promoSet = promoSet;
            this._setupTooltips();
            this.on({
                'download': function(event) {
                    var path = '/promoSets/' + (promoSet.get('key')) +
                        '/download';
                    window.open(path);
                },
                'downloadUnused': function(event) {
                    var path = '/promoSets/' + (promoSet.get('key')) +
                        '/download?unused=1';
                    window.open(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminPromoSetsView
     * 
     * @extends AdminSectionView
     */
    window.AdminPromoSetsView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    PromoSetsCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'promoSets')
         */
        _section: 'promoSets',

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminPromoSetsView')
         */
        _string: 'AdminPromoSetsView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawPromoSet
         * 
         * @access protected
         * @param  PromoSetAccessor promoSet
         * @param  Number position
         * @return void
         */
        _drawPromoSet: function(promoSet, position) {
            var $row = Stencil.render('AdminPromoSetRow', {
                promoSet: promoSet
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminPromoSetRowView($row, promoSet);
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new PromoSetsCollection();
            this._collection.on({
                'add': function(event, promoSet, position) {
                    _this._drawPromoSet(promoSet, position);
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this;
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: Stencil.get('config').defaults.objectsPerPage.admin.promoSets,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminSectionView
     * 
     * @extends View
     */
    window.AdminSectionView = View.extend({

        /**
         * _modal
         * 
         * @access protected
         * @var    AdminModalView (default: null)
         */
        _modal: null,

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: null)
         */
        _section: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminSectionView')
         */
        _string: 'AdminSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AdminModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[section="' + (this._section) + '"]');
            $anchor.siblings('[section]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            Browser.tablet() === false && this._element.focusable().focus();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminUserRowView
     * 
     * @extends View
     */
    window.AdminUserRowView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $checkbox
                     * @return void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        // event.preventDefault();
                        this._user.active().upgradeToPlan('unlimited');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminUserRowView')
         */
        _string: 'AdminUserRowView',

        /**
         * _user
         * 
         * @access protected
         * @var    Object (default: null)
         */
        _user: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  Object user
         * @return void
         */
        init: function(element, user) {
            this._super(element);
            this._user = user;
            this._setupTooltips();
            this.on({
                'cancel': function(event) {
                    var active = this._user.active();
                    Modals.showCancelAccount(active);
                },
                'impersonate': function(event) {
                    var _this = this;
                    User.logout(function() {
                        var path = '/app?impersonate=1&secret=' +
                            _this._user.get('secret');
                        window.location.assign(path);
                    });
                },
                'show/update': function(event) {
                    var path = '/app/admin/users/' + (this._user.get('key'));
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
        // ,

        // /**
        //  * render
        //  * 
        //  * @access public
        //  * @return void
        //  */
        // render: function() {
        //     var $row = Stencil.render('AdminUserRow', {
        //         user: this._user
        //     });
        //     this._element.replaceWith($row);
        //     this._element = $row;
        //     this._setupListeners();
        // }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminUsersView
     * 
     * @extends AdminSectionView
     */
    window.AdminUsersView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    UsersCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access protected
         * @var    String|false (default: false)
         */
        _query: false,

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load(this._query);
                        }
                    }
                }
            }
        },

        /**
         * _section
         * 
         * @access protected
         * @var    String (default: 'users')
         */
        _section: 'users',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminUsersView')
         */
        _string: 'AdminUsersView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawUser
         * 
         * @access protected
         * @param  UserAccessor user
         * @param  Number position
         * @return void
         */
        _drawUser: function(user, position) {
            var $row = Stencil.render('AdminUserRow', {
                user: user
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminUserRowView($row, user);
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new UsersCollection();
            this._collection.on({
                'add': function(event, user, position) {
                    _this._drawUser(user, position);
                },
                'empty': function(event) {
                    _this.find('div.user').remove();
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            if (this._query === false || this._query === '') {
                return '/app/admin/users';
            }
            var encoded = encodeURIComponent(this._query);
            return '/app/admin/users/search/' + (encoded);
        },

        /**
         * getQuery
         * 
         * @access public
         * @return String
         */
        getQuery: function() {
            return this._query;
        },

        /**
         * load
         * 
         * @access public
         * @param  String query
         * @return void
         */
        load: function(query) {
            var _this = this;
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: Stencil.get('config').defaults.objectsPerPage.admin.users,
                offset: this._collection.all().length,
                query: query
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access public
         * @param  String query
         * @return void
         */
        show: function(query) {
            this._super();
            if (this._query !== query) {
                this.unload();
                this._query = query;
                this.load(query);
            }
        },

        /**
         * unload
         * 
         * @access public
         * @return void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ConnectionRowView
     * 
     * @todo    After all connections have been deleted, close the modal
     * @events  confirm/delete
     * @extends View
     */
    window.ConnectionRowView = View.extend({

        /**
         * _connection
         * 
         * @access protected
         * @var    ConnectionAccessor (default: null)
         */
        _connection: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConnectionRowView')
         */
        _string: 'ConnectionRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ConnectionAccessor connection
         * @return void
         */
        init: function(element, connection) {
            this._super(element);
            this._connection = connection;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    App.tooltips.hide();
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._connection.on({
                'delete': function() {
                    _this._element.remove();
                    // _this.clean();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @return void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this connection?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function() {
                    _this._connection.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FrameView', function() {

    /**
     * CustomFrameView
     * 
     * @events  confirm/delete
     * @extends FrameView
     */
    window.CustomFrameView = FrameView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CustomFrameView')
         */
        _string: 'CustomFrameView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  FramerView framer
         * @param  FrameAccessor frame
         * @return void
         */
        init: function(element, framer, frame) {
            this._super(element, framer, frame);
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._frame.on({
                'delete': function() {
                    _this._element.remove();
                    // _this.clean();
                    // Track.user();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * Confirms that a user wants to delete a frame. If they attempt to
         * delete the frame that their draft is currently using, simply switch
         * them to the orphan frame so that the word "Custom" shows up. To
         * ensure that the orphan has thsame width and height, I set it right
         * before switching to it.
         * 
         * @access protected
         * @return void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this custom size?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function() {
                    var key = _this._frame.get('key'),
                        account = Stencil.account(),
                        draft = account.draft();
                    if (key === draft.get('frame')) {
                        var orphan = account.orphanFrame();
                        orphan.set({
                            width: _this._frame.get('width'),
                            height: _this._frame.get('height')
                        });
                        orphan.select();
                        orphan.setToPreviewCanvas();
                    }
                    _this._frame.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * DropzoneView
     * 
     * @events  complete
     *          start
     * @extends View
     */
    window.DropzoneView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            var $file = this.find('input[type="file"]');
                            !this._uploading && $file.trigger('click');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[lookup="again"]': function(event, $element) {
                        event.preventDefault();
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            var $file = this.find('input[type="file"]');
                            !this._uploading && $file.trigger('click');
                        }
                    }
                },
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input[type="file"]': function(event, $input) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            if (this._uploading === false) {
                                var files = jQuery.makeArray(
                                    $input.prop('files')
                                );
                                this.receive(files);
                            }
                        }
                    }
                },

                // Drag events
                dragover: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                        $div.addClass('hovering');
                    }
                },
                dragenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                        $div.addClass('hovering');
                    }
                },
                dragleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                        $div.removeClass('hovering');
                    }
                },
                drop: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        $div.removeClass('hovering');
                        if (event.originalEvent.dataTransfer) {
                            if (event.originalEvent.dataTransfer.files.length) {
                                event.preventDefault();
                                event.stopPropagation();
                                if (Services.check('aws') === false) {
                                    Stencil.alert('service.aws');
                                } else {
                                    var files = event.originalEvent.dataTransfer.files;
                                    if (this._uploading === false) {
                                        this.receive(jQuery.makeArray(files));
                                    }
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * _max
         * 
         * Object defining the maximum filesize and count for uploads. It is set
         * when the view is initiated, as it's pulled dynamically from the
         * Stencil config settings.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _max: {},

        /**
         * _models
         * 
         * Defines the models that different types of DropzoneView's ought to
         * use when creating and referencing an accessor.
         * 
         * @access protected
         * @var    Object
         */
        _models: {
            background: 'Upload',
            font: 'Upload',
            graphic: 'Upload',
            watermark: 'Watermark'
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'DropzoneView')
         */
        _string: 'DropzoneView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: '')
         */
        _type: '',

        /**
         * _managedUpload
         * 
         * @access protected
         * @var    AWS.S3.ManagedUpload (default: null)
         */
        _managedUpload: null,

        /**
         * _uploading
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _uploading: false,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @return void
         */
        init: function(element, type) {
            this._type = type;
            this._super(element);
            this._setMax();
            Scripts.load('aws');
            this.on({
                'cancel': function(event) {
                    this._managedUpload.abort();
                },
                'show/pad': function(event) {
                    this.show('prompt');
                }
            });
        },

        /**
         * _setMax
         * 
         * Defines the maximum files that can be uploaded at once, as well as
         * the maximum filesize for each file.
         * 
         * Note that the filesize limitation is defined in bytes.
         * 
         * @access public
         * @return void
         */
        _setMax: function() {
            this._max = {
                fonts: {
                    count: Stencil.get('config').defaults.fontUploadMaxFiles.toInt(),
                    size: Stencil.get('config').defaults.fontUploadMaxBytes.toInt()
                },
                images: {
                    count: Stencil.get('config').defaults.imageUploadMaxFiles.toInt(),
                    size: Stencil.get('config').defaults.imageUploadMaxBytes.toInt()
                }
            };
        },

        /**
         * _createUploadRecord
         * 
         * @see    http://stackoverflow.com/questions/12570834/how-to-preview-image-get-file-size-image-height-and-width-before-upload
         * @see    http://jsbin.com/oTAtIpA/3/edit?html,css,js,output
         * @access public
         * @param  File file
         * @param  Function callback
         * @return void
         */
        _createUploadRecord: function(file, callback) {
            var model = Stencil.getModel(this._models[this._type]);
            model.create({
                mime: file.type,
                name: file.name,
                size: file.size,
                type: this._type
            }, callback);
        },

        /**
         * receive
         * 
         * @access public
         * @param  Array files
         * @return Boolean
         */
        receive: function(files) {

            // Clear input value
            var $file = this.find('input[type="file"]');
            $file.val('');

            // Check count
            var max = this._max.images;
            if (this._type === 'font') {
                max = this._max.fonts;
            }
            if (files.length > max.count) {
                if (this._type === 'font') {
                    Stencil.alert('upload.font.max.count');
                } else {
                    Stencil.alert('upload.image.max.count');
                }
                return false;
            }

            // Check type
            var imageTypes = Stencil.get('config').defaults.imageUploadMimeTypes,
                fontTypes = Stencil.get('config').defaults.fontUploadMimeTypes;
            if (this._type === 'font') {
                for (var index in files) {
                    if (files[index].name.match(/\.zip$/i) !== null) {
                        Stencil.set('ignoreMouseDownLayerBlur', true);
                        Stencil.alert('upload.font.type');
                        Modals.open()[0].once({
                            'close leave': Stencil.set.proxy(
                                Stencil,
                                ['ignoreMouseDownLayerBlur', false]
                            )
                        });
                        return false;
                    }
                }
            } else {
                for (var index in files) {
                    if (jQuery.inArray(files[index].type, imageTypes) === -1) {
                        Stencil.alert('upload.image.type');
                        return false;
                    }
                }
            }

            // Check maximum filesize
            for (index in files) {
                if (files[index].size > max.size) {
                    // if (User.admin() === true) {
                    //     if (this._type === 'font') {
                    //         Stencil.alert('upload.font.max.filesize.admin');
                    //     } else {
                    //         Stencil.alert('upload.image.max.filesize.admin');
                    //     }
                    //     return false;
                    // }
                    if (this._type === 'font') {
                        Stencil.alert('upload.font.max.filesize');
                    } else {
                        Stencil.alert('upload.image.max.filesize');
                    }
                    return false;
                }
            }

            // Check minimum filesize
            for (index in files) {
                if (files[index].size < 10) {
                    var key = 'upload.singular.filesize.zero';
                    if (files.length > 1) {
                        key = 'upload.multiple.filesize.zero';
                    }
                    Stencil.alert(key);
                    return false;
                }
            }

            // Success
            this.triggerHandler('start');
            var total = files.length;
            this.find('.context').addClass('hidden');
            if (total > 1) {
                this.find('.context').removeClass('hidden');
                this.find('[lookup="total"]').text(total);
            }
            var next = (function() {
                var current = total - files.length + 1;
                this.find('[lookup="current"]').text(current);
                this.uploadFile(files.shift(), current, total, function() {
                    if (files.length > 0) {
                        next();
                    }
                });
            }).proxy(this);
            next();
        },

        /**
         * reset
         * 
         * @access public
         * @return void
         */
        reset: function() {
            this.find('.progress').addClass('off').css({
                width: '0%'
            }).removeClass('off');
            this.find('.percentage').text('0%');
        },

        /**
         * show
         * 
         * @access public
         * @param  String parent
         * @param  String child
         * @return void
         */
        show: function(parent, child) {

            // Parent
            this.find('.prompt').addClass('invisible');
            this.find('.status').addClass('invisible');
            this.find('.prompt').removeClass('visible');
            this.find('.status').removeClass('visible');
            this.find('.' + (parent)).removeClass('invisible');
            this.find('.' + (parent)).addClass('visible');

            // Child 
            if (child) {
                this.find('.status').removeClass('uploading');
                this.find('.status').removeClass('processing');
                this.find('.status').removeClass('complete');
                this.find('.status').removeClass('failed');
                this.find('.status').addClass(child);
            }
        },

        /**
         * uploadFile
         * 
         * @todo   Proper error handling for too large of a file
         * @todo   When upload reaches 100%, switch to Processing state right
         *         away. Do this because sometimes things freeze for a few
         *         seconds here, which is confusing since it says 100%.
         * @access public
         * @param  File file
         * @param  Number current
         * @param  Number total
         * @param  Function callback
         * @return void
         */
        uploadFile: function(file, current, total, callback) {

            // Cancel link
            this._uploading = true;
            var _this = this,
                $cta = this.find('div.status div.uploading div.cta');
            $cta.addClass('hidden');

            // UI
            this.show('status', 'uploading');
            this.reset();

            // Let's do this
            this._createUploadRecord(
                file,

                /**
                 * (anonymous)
                 * 
                 * @param  Object data
                 * @return void
                 */
                function(data) {

                    // Get reference to Upload or Watermark accessor
                    var model = Stencil.getModel(_this._models[_this._type]),
                        upload = model.setAccessor(data.object),
                        response;

                    model = Stencil.getModel('S3Upload');
                    response = model.uploadFile(
                        upload,
                        upload.get('key'),
                        file
                    );

                    // Successful attempt
                    if (response.success === true) {

                        // Move ahead
                        _this._managedUpload = response.response.managedUpload;

                        // Failed
                        upload.on('upload/error', function(event, err) {
                            _this.find('.context').addClass('hidden');
                            _this._uploading = false;
                            _this.show('status', 'failed');
                            Track.event('Dropzone upload fail', {
                                err: err
                            });
                        });

                        // Abort
                        upload.on(
                            'upload/abort', function(event, err) {
                                _this._uploading = false;
                                _this.show('prompt');
                            }
                        );

                        // Success
                        upload.on(
                            'upload/success',

                            /**
                             * (anonymous)
                             * 
                             * The point of preloading and have success/error
                             * callbacks is so that if there's a problem accessing
                             * the image's converted sizes, we can signal an error
                             * to the user and allow them to re-upload the file. An
                             * example of this would be if the user uploads a .zip
                             * file that was accidentally renamed .jpeg. This would
                             * get passed the checks (both drag/drop and click of
                             * the dropzone pad), but would fail when accessed via
                             * Cloudinary.
                             * 
                             * @todo   Ensure that the <upload.syncDimensions> call
                             *         is hooked up to the complete event here
                             * @param  Object event
                             * @param  Object response
                             * @return void
                             */
                            function(event, response) {
                                upload.set({
                                    'uploaded': 1
                                });
                                upload.save(['uploaded']);
                                _this._uploading = false;
                                _this.show('status', 'processing');
                                upload.once({
                                    'sync/complete': function(event, data) {
                                        if (_this._type === 'font') {
                                            var model = Stencil.getModel('Font');
                                            model.create({
                                                upload: this.get('key')
                                            }, function(response) {

                                                // 
                                                var model = Stencil.getModel('Font'),
                                                    font = model.setAccessor(response.object);
                                                _this.show('status', 'complete');
                                                _this.triggerHandler(
                                                    'complete',
                                                    [upload, font]
                                                );

                                                /**
                                                 * Delays here are intended to not
                                                 * jolt the user when the Dropzone
                                                 * prompt UI state is shown again.
                                                 */
                                                if (current === total) {
                                                    _this.show.delay(
                                                        2000,
                                                        _this,
                                                        ['prompt']
                                                    );
                                                } else {
                                                    (function() {
                                                        _this.show('prompt');
                                                        callback && callback();
                                                    }).delay(1000, _this);
                                                }
                                            }, function(response) {
                                                // console.log(response);
                                                Stencil.set('ignoreMouseDownLayerBlur', true);
                                                Stencil.alert('upload.font.failed');
                                                Modals.open()[0].once({
                                                    'close leave': Stencil.set.proxy(
                                                        Stencil,
                                                        ['ignoreMouseDownLayerBlur', false]
                                                    )
                                                });
                                                _this.show.delay(
                                                    0,
                                                    _this,
                                                    ['prompt']
                                                );
                                            });
                                        } else {
                                            upload.preload(
                                                function() {
                                                    _this.show('status', 'complete');
                                                    _this.triggerHandler(
                                                        'complete',
                                                        [upload]
                                                    );

                                                    /**
                                                     * Delays here are intended to not
                                                     * jolt the user when the Dropzone
                                                     * prompt UI state is shown again.
                                                     */
                                                    if (current === total) {
                                                        _this.show.delay(
                                                            2000,
                                                            _this,
                                                            ['prompt']
                                                        );
                                                    } else {
                                                        (function() {
                                                            _this.show('prompt');
                                                            callback && callback();
                                                        }).delay(1000, _this);
                                                    }
                                                },
                                                function() {
                                                    upload.delete();
                                                    _this.find('.context').addClass(
                                                        'hidden'
                                                    );
                                                    _this._uploading = false;
                                                    _this.show('status', 'failed');
                                                }
                                            );
                                        }
                                    }
                                });
                                upload.sync();
                            }
                        );

                        // Progress
                        upload.on(
                            'upload/progress',

                            /**
                             * (anonymous)
                             * 
                             * @param  Object event
                             * @param  Number loaded
                             * @param  Number total
                             * @return void
                             */
                            function(event, loaded, total) {

                                // Cancel link
                                var $cta = _this.find('div.status div.uploading div.cta');
                                $cta.addClass('hidden');
                                if (file.size > 5 * 1024 * 1024) {
                                    $cta.removeClass('hidden');
                                }

                                // Percentage
                                var percentage = Math.round(
                                    (loaded / total) * 100
                                );
                                if (percentage < 5) {
                                    percentage = 5;
                                }
                                _this.find('.progress').css({
                                    width: (percentage) + '%'
                                });
                                _this.find('.percentage').text(
                                    (percentage) + '%'
                                );
                            }
                        );

                        // Fake a progress event to ensure something is visible
                        upload.triggerHandler('upload/progress', [5, 100]);
                    }
                    // Upload failed; alert
                    else {
                        _this._uploading = false;
                        _this.show('prompt');
                        Stencil.alert(response.failedRules[0].key);
                    }
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FontsDropdownView
     * 
     * @events  hover
     *          close
     *          open
     *          toggle
     *          select
     * @extends View
     */
    window.FontsDropdownView = View.extend({

        /**
         * _fontsCollection
         * 
         * @access protected
         * @var    FontsCollection (default: null)
         */
        _fontsCollection: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'nav a[section]': function(event, $anchor) {
                        event.preventDefault();
                        var section = $anchor.attr('section');
                        this.showTab(section);
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'div.selected a': function(event, $anchor) {
                        event.preventDefault();
                        this.toggle();
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'li a.label': function(event, $anchor) {
                        event.preventDefault();
                        var value = $anchor.parent().attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        this.selectFont(font);
                        this.triggerHandler('select', font);
                        this.close();
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent(),
                            value = $li.attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        $li.siblings().removeClass('hover');
                        $li.addClass('hover');
                        this.triggerHandler('hover', font);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent();
                        $li.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _scrollbars
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _scrollbars: {},

        /**
         * _selectedFont
         * 
         * @access protected
         * @var    false|FontAccessor
         */
        _selectedFont: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FontsDropdownView')
         */
        _string: 'FontsDropdownView',

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        // _logEvents: false,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  FontsCollection fontsCollection
         * @return void
         */
        init: function(element, fontsCollection) {
            this._super(element);
            this._fontsCollection = fontsCollection;
            this._addHoverEvents();
            this._setupAuth();
            this._setupDropzone()
            this._setupImportClickEvent()
            this.on({
                'edit': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._edit(font);
                },
                'confirm/delete': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._confirmDelete(font);
                }
            });
            if (Stencil.scrollbars() === true) {
                this._setupScrollbars();
            }
            this.showAppropriateMessagingElements();
        },

        /**
         * _addEscapeEvent
         * 
         * @access protected
         * @return void
         */
        _addEscapeEvent: function() {
            var _this = this,
                callback = function(event) {
                    if (
                        event.keyCode === 27
                        && Stencil.get('ignoreMouseDownLayerBlur') !== true
                        && _this._element.hasClass('open') === true
                    ) {
                        event.preventDefault();
                        _this.close();
                        // $(this).unbind(event);
                    }
                };
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _addHoverEvents
         * 
         * @note   There is a bug where by if the page has a scrollbar and an
         *         element that is being hovered over exists outside of the
         *         scope of the page-scrollbar, the elementFromPoint can't seem
         *         to find it, resulting in the following error:
         *         https://i.imgur.com/SdBdmRf.png
         *         So to deal with this, I simply ensure the length of $el is
         *         greater than 0.
         * @access protected
         * @return void
         */
        _addHoverEvents: function() {
            this.find('div.list').scroll(function(event) {
                var el = document.elementFromPoint(App.getX(), App.getY()),
                    $el = $(el);
                if ($el.length > 0) {
                    if ($el.tag() === 'a') {
                        $el.trigger('mouseenter');
                    }
                }
            });
        },

        /**
         * _blur
         * 
         * @access protected
         * @param  jQuery event
         * @return void
         */
        _blur: function(event) {
            var $target = $(event.target);
            if (Stencil.get('ignoreMouseDownLayerBlur') !== true) {
                if ($target.closest('.fontsDropdown').length === 0) {
                    this.close();
                }
            }
        },

        /**
         * _focusOnSelectedFont
         * 
         * @access protected
         * @return void
         */
        _focusOnSelectedFont: function() {
            var uploaded = this._selectedFont.get('uploaded').toInt() === 1
                    && this._selectedFont.get('hasRegularAccess').toInt() === 1,
                sections = {
                    $default: this.find('section[section="default"]'),
                    $uploaded: this.find('section[section="uploaded"]')
                },
                lists = {
                    $default: this.find('[section="default"] div.list'),
                    $uploaded: this.find('[section="uploaded"] div.list')
                },
                $active = this.find('[section] li.active');
            if (Stencil.scrollbars() === true) {
                this._scrollbars.$default.data('jsp').scrollToY(0, false);
                this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                if (uploaded === false) {
                    this._scrollbars.$default.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                } else {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                }
            } else {
                sections.$default.removeClass('hidden');
                lists.$default.scrollTop(0)
                sections.$default.addClass('hidden');
                sections.$uploaded.removeClass('hidden');
                lists.$uploaded.scrollTop(0)
                sections.$uploaded.addClass('hidden');
                if (uploaded === false) {
                    sections.$default.removeClass('hidden');
                    lists.$default.scrollTop($active.position().top - 4);
                } else {
                    sections.$uploaded.removeClass('hidden');
                    lists.$uploaded.scrollTop($active.position().top - 4);
                }
            }
        },

        /**
         * _makeScrollable
         * 
         * @access protected
         * @param  jQuery $default
         * @param  jQuery $uploaded
         * @return void
         */
        _makeScrollable: function($default, $uploaded) {
            this._scrollbars.$default = $default;
            this._scrollbars.$uploaded = $uploaded;
            this._scrollbars.$default.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._scrollbars.$uploaded.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _revertTextLayersUsingFont
         * 
         * @access protected
         * @param  FontAccessor font
         * @return void
         */
        _revertTextLayersUsingFont: function(font) {
            var account = Stencil.account(),
                fontsCollection = this._fontsCollection,
                // appDefaultFontFamily = Stencil.get('config').defaults.font,
                appDefaultFontFamily = Stencil.account().setting('defaultFontFamily'),
                // appDefaultFontFamily = 'Times New Roman',
                backupFont = fontsCollection.findByFamilyName(appDefaultFontFamily),
                draftImageDocument = account.draft().getImageDocument(),
                textLayersWithSelectedFont = draftImageDocument.filter(function(index, layer) {
                    return layer.getStyle('fontFamily') === font.get('familyName');
                });
            if (textLayersWithSelectedFont.length > 0) {
                ChangeHistory.setOperationType('fonts // reset');
            }
            jQuery.each(textLayersWithSelectedFont, function(index, textLayer) {
                textLayer.triggerHandler('change/fontFamily', backupFont);
            });

            /**
             * Re-select the font for this selected layer, just incase it was
             * deleted. This ensures either the backup font is showing in the
             * dropdown if it ought to be.
             */
            var activeFontFamily = Canvases.Preview.getSelectedLayer().getStyle('fontFamily'),
                activeFont = fontsCollection.findByFamilyName(activeFontFamily);
            this.selectFont(activeFont);
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function() {
                    _this.showAppropriateMessagingElements();
                },
                'signup': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
        },

        /**
         * _setupDropzone
         * 
         * @access protected
         * @return void
         */
        _setupDropzone: function() {
            var collection = this._fontsCollection,
                $dropzone = this.find('.dropzone');
            this._dropzone = new FontsDropzoneView($dropzone, 'font');
            this._dropzone.on({
                'complete': function(event, upload, font) {
                    Track.event('Font uploaded');
                    collection.add(font);
                    font.loadFull(function() {
                        var fontsDropdown = Toolbars.text.getFontsDropdown();
                        fontsDropdown.addFont(font, false);
                        fontsDropdown.scrollToTop('uploaded');
                    });
                }
            });
        },

        /**
         * _setupImportClickEvent
         * 
         * @access protected
         * @return void
         */
        _setupImportClickEvent: function() {
            this.on({
                'import': function(event, $anchor) {
                    // if (Account.upgraded() === true || User.admin() === true) {
                        Stencil.navigate('/app/fonts/import');
                    // } else {
                    //     Stencil.navigate('/app/upgrade/pro/fontImports?clean=1');
                    // }
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access protected
         * @return void
         */
        _setupScrollbars: function() {
            var $default = this.find('section[section="default"] div.list'),
                $uploaded = this.find('section[section="uploaded"] div.list');
            $default.addClass('dark');
            $uploaded.addClass('dark');
            this._makeScrollable($default, $uploaded);
        },

        /**
         * _showTabForSelectedFont
         * 
         * @access protected
         * @return void
         */
        _showTabForSelectedFont: function() {
            var font = this._selectedFont,
                section = 'default';
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                section = 'uploaded';
            }
            this.showTab(section);
        },

        /**
         * addFont
         * 
         * @access public
         * @param  FontAccessor font
         * @param  Boolean sort
         * @return void
         */
        addFont: function(font, sort) {
            this.showAppropriateMessagingElements();
            var section = font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1 ? 'uploaded' : 'default';
            var $section = this.find('section[section="' + (section) + '"]'),
                $li = $('<li></li>'),
                $a = $('<a class="label" click="" trigger="null"></a>'),
                $editIcon = $('<a class="icon edit fa fa-pencil" click="" trigger="edit"></a>'),
                $deleteIcon = $('<a class="icon delete fa fa-trash" click="" trigger="confirm/delete"></a>')
            $li.attr('value', font.get('familyName'));
            $li.attr('style', 'font-family: ' + (font.get('familyName')) + ', monospace');
            $a.text(font.get('label'));
            $editIcon.attr('key', font.get('key'));
            $deleteIcon.attr('key', font.get('key'));
            $li.append($a);
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                $li.append($editIcon, $deleteIcon);
            }
            $section.find('ul').prepend($li);
            if (sort === true) {
                $section.find('ul')[0].orderAlphabeticallyByText();
            }
            this.refreshScrollbars(section);
        },

        /**
         * close
         * 
         * @access public
         * @return void
         */
        close: function() {
            this._element.removeClass('open');
            this.triggerHandler('close');
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @param  FontAccessor font
         * @return void
         */
        _confirmDelete: function(font) {
            var _this = this,
                question = 'Are you sure you want to delete this font?',
                // h2 = '<strong>WARNING:</strong> This cannot be undone. Any ' +
                //     'images you’ve saved using this font will revert to a ' +
                //     'default font.',
                // modal = Modals.showConfirmDelete(question, h2);
                modal = Modals.showConfirmDelete(question);
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.getElement().addClass('warning');
            modal.on({
                'close': function() {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'yes': function() {

                    // Revert any fonts being used to the app default
                    _this._revertTextLayersUsingFont(font);

                    /**
                     * Wait until the stack has ended (to ensure mouseup or
                     * keyup events have fired), and then go through the change
                     * history and swap out any text layers that were using that
                     * font with the app default. This is to prevent a bug when
                     * trying to revert to one of those older or future
                     * versions.
                     * 
                     * Without the 0-second delay (which effectively just moves
                     * the call to the end of the stack), no operation gets
                     * recorded, since previous operations would have had their
                     * font families reverted to the app default already, which
                     * means the ChangeHistory.track method wouldn't notice that
                     * anything's changed.
                     */
                    ChangeHistory.syncDeletedFont.delay(0, ChangeHistory, [font]);

                    // Overhead procedures
                    _this.removeFont(font);
                    font.delete();
                    _this.showAppropriateMessagingElements();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _edit
         * 
         * @access protected
         * @param  FontAccessor font
         * @return void
         */
        _edit: function(font) {
            var _this = this,
                // question = 'Are you sure you want to delete this font?',
                modal = Modals.showRename(font);
            modal.find('input').select();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.on({
                'close': function() {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'save': function(event, object) {
                    font.set({
                        label: object.label
                    });
                    var familyName = font.get('familyName'),
                        $li = _this.find('li[value="' + (familyName) + '"]'),
                        $label = $li.find('a.label');
                    $label.text(object.label);
                    this.triggerHandler.delay(500, this, ['close']);
                }
            });
        },

        /**
         * getFontsCollection
         * 
         * @access public
         * @return FontsCollection
         */
        getFontsCollection: function() {
            return this._fontsCollection;
        },

        /**
         * getSelectedFont
         * 
         * @access public
         * @return false|FontAccessor
         */
        getSelectedFont: function() {
            return this._selectedFont;
        },

        /**
         * open
         * 
         * @access public
         * @return void
         */
        open: function() {
            this._addEscapeEvent();
            var callback = this._blur.proxy(this);
            App.getElement().on({
                'click': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('click', callback);
                }
            })
            this._element.addClass('open');
            this._showTabForSelectedFont();
            this.refreshScrollbars();
            this._focusOnSelectedFont();
            this.triggerHandler('open');

            // 
            var callback = this._blur.proxy(this),
                cotton = Canvases.Preview.getCotton();
            cotton.on({
                'object:selected': callback
            });
            this.once({
                'close': function(event) {
                    cotton.off('object:selected', callback);
                }
            });
        },

        /**
         * refreshScrollbars
         *
         * @access public
         * @param  undefined|String section
         * @return void
         */
        refreshScrollbars: function(section) {
            if (Stencil.scrollbars() === true) {
                var sections = {
                        $default: this.find('section[section="default"]'),
                        $uploaded: this.find('section[section="uploaded"]')
                    },
                    lists = {
                        $default: this.find('[section="default"] div.list'),
                        $uploaded: this.find('[section="uploaded"] div.list')
                    };
                sections.$default.removeClass('hidden');
                sections.$uploaded.removeClass('hidden');
                this._scrollbars.$default.data('jsp').reinitialise();
                this._scrollbars.$uploaded.data('jsp').reinitialise();
                sections.$default.addClass('hidden');
                sections.$uploaded.addClass('hidden');
                if (section === undefined) {
                    var font = this._selectedFont;
                    if (
                        font.get('uploaded').toInt() === 1
                        && font.get('hasRegularAccess').toInt() === 1
                    ) {
                        sections.$uploaded.removeClass('hidden');
                    } else {
                        sections.$default.removeClass('hidden');
                    }
                } else {
                    if (section === 'default') {
                        sections.$default.removeClass('hidden');
                    } else {
                        sections.$uploaded.removeClass('hidden');
                    }
                }
            }
        },

        /**
         * removeFont
         *
         * @access public
         * @param  FontAccessor font
         * @return void
         */
        removeFont: function(font) {
            var familyName = font.get('familyName'),
                $li = this.find('li[value="' + (familyName) + '"]');
            $li.remove();
            this.refreshScrollbars('uploaded');
        },

        /**
         * scrollToTop
         *
         * @access public
         * @param  String section
         * @return void
         */
        scrollToTop: function(section) {
            if (Stencil.scrollbars() === true) {
                if (section === 'uploaded') {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                } else {
                    this._scrollbars.$default.data('jsp').scrollToY(0, false);
                }
            } else {
                this.find('[section="' + (section) + '"] div.list').scrollTop(0);
            }
        },

        /**
         * selectFont
         * 
         * Sets an internal reference to the passed in FontAccessor, and updates
         * the UI so that the .selected element has that corresponding label
         * and font-family set.
         * 
         * @note   I remove any possible "hidden" class from the list item to
         *         ensure that if the font is a legacy one, it can be seen. This
         *         is because legacy fonts are written to the DOM, but simply
         *         hidden (since they're only used when legacy images or
         *         templates are used).
         * @access public
         * @param  FontAccessor font
         * @return void
         */
        selectFont: function(font) {
            this._selectedFont = font;
            var familyName = font.get('familyName'),
                label = font.get('label'),
                $li = this.find('li[value="' + (familyName) + '"]'),
                $copy = this.find('div.selected a span.copy'),
                $items = this.find('section[section] div ul li');
            $li.removeClass('hidden');
            $items.removeClass('active');
            $li.addClass('active');
            $copy.css('font-family', familyName);
            $copy.text(label);
        },

        /**
         * showAppropriateMessagingElements
         * 
         * @access public
         * @return void
         */
        showAppropriateMessagingElements: function() {
            var $lists = this.find('section[section="uploaded"] div.list');
            $lists.removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (Account.upgraded() === true || User.admin() === true) {
                if (this._fontsCollection.getUploaded().length === 0) {
                    $lists.addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                $lists.addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        },

        /**
         * showTab
         * 
         * @access public
         * @param  String section
         * @return void
         */
        showTab: function(section) {
            this.find('nav a[section]').addClass('noAnimation').removeClass('active');
            this.find('nav a[section="' + (section) + '"]').addClass('active');
            this.find('nav a[section]').removeClass('noAnimation');
            this.find('section[section]').addClass('hidden');
            this.find('section[section="' + (section) + '"]').removeClass('hidden');
        },

        /**
         * toggle
         * 
         * Either closes or opens the dropdown by calling the helper <close> or
         * <open> methods. Also fires the <toggle> event.
         * 
         * @access public
         * @return void
         */
        toggle: function() {
            this.triggerHandler('toggle');
            if (this._element.hasClass('open') === true) {
                this.close();
            } else {
                this.open();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FrameView
     * 
     * @extends View
     */
    window.FrameView = View.extend({

        /**
         * _frame
         * 
         * @access protected
         * @var    null|FrameAccessor (default: null)
         */
        _frame: null,

        /**
         * _framer
         * 
         * @access protected
         * @var    null|FramerView (default: null)
         */
        _framer: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FrameView')
         */
        _string: 'FrameView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  FramerView framer
         * @param  FrameAccessor frame
         * @return void
         */
        init: function(element, framer, frame) {
            this._super(element);
            this._framer = framer;
            this._frame = frame;
            this._addSelectListener();
        },

        /**
         * _addSelectListener
         * 
         * Listens for a frame being selected in the UI, and when it is, first
         * tracks the position of the background image (relative to the
         * background image and frame-key combination) before changing to the
         * new frame. This is because it's possible that the user moves the
         * background position from it's default 50-50 position, and just wants
         * to see what, for example, a Pinterest frame looks like. By storing
         * this background position, it allows us to reposition the background
         * image if the user goes back to the previous frame. It is less
         * jarring.
         * 
         * After the select happens against the FrameAccessor, I then redraw the
         * image (via the setToPreviewCanvas method), and then restore the
         * background image (relative to the background image and the frame
         * being switched to), if any position details were stored (logic is
         * elsewhere for that).
         * 
         * Finally, I hide the Framer, and make a call to set the configuration
         * of the image to ensure, after the application-wide save-delay, the
         * image configuration details are saved.
         * 
         * @access protected
         * @return void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event) {
                    ChangeHistory.setOperationType('frame // changed');
                    var canvas = Canvases.Preview,
                        draft = Stencil.account().draft();
                    canvas.trackBackgroundImageLayerPosition();
                    this._frame.select();
                    this._frame.setToPreviewCanvas();
                    canvas.restoreFrameSpecificPosition();
                    this._framer.hide();
                    draft.setConfiguration();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * GoogleFontRowView
     * 
     * @extends View
     */
    window.GoogleFontRowView = View.extend({

        /**
         * _googleFont
         * 
         * @access protected
         * @var    GoogleFontAccessor (default: null)
         */
        _googleFont: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GoogleFontRowView')
         */
        _string: 'GoogleFontRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GoogleFontAccessor googleFont
         * @return void
         */
        init: function(element, googleFont) {
            this._super(element);
            this._googleFont = googleFont;
            // this._setupTooltips();
            this.on({
                'import': function(event, $anchor) {
                    if (Account.upgraded() === true || User.admin() === true) {

                        // Max has been reached
                        var fonts = Stencil.account().collection('fonts').getUploaded(),
                            max = Stencil.get('config').defaults.maxFontUploads;
                        if (fonts.length >= max) {
                            Stencil.alert('font.import.max');
                        }
                        // Good to go
                        else {
                            var modal = Modals.open()[0];
                            modal.pause();
                            $anchor.addClass('busy');
                            $anchor.attr('disabled', 'disabled');
                            // modal.find('a.button.tiny').attr('disabled', 'disabled');
                            this._googleFont.once({
                                'import': function(event, data) {

                                    // Button updates
                                    $anchor.removeClass('busy');
                                    $anchor.addClass('done');
                                    // modal.find('a.button.tiny:not(.done)').removeAttr('disabled');
                                    // $anchor.removeAttr('disabled');
                                    modal.unpause();

                                    // Collection updates
                                    var model = Stencil.getModel('Font'),
                                        font = model.setAccessor(data.object),
                                        fontsDropdown = Toolbars.text.getFontsDropdown(),
                                        collection = fontsDropdown.getFontsCollection();
                                    Track.event('Font imported');
                                    collection.add(font);
                                    font.loadFull(function() {
                                        fontsDropdown.addFont(font, false);
                                        fontsDropdown.scrollToTop('uploaded');
                                    });

                                    // Focus on the tab in the dropdown
                                    fontsDropdown.showTab('uploaded');
                                }
                            });
                            this._googleFont.import();
                        }
                    } else {
                        Modals.showUpgrade('pro', 'fontImports');
                        // Stencil.navigate('/app/upgrade/pro/fontImports');
                    }
                }
            });
        }
        //,

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        // _setupTooltips: function() {
        //     this._element.tooltip({
        //         html: true,
        //         selector: '[tooltip]',
        //         // container: App.getElement(),
        //         // container: this._element.closest('.modal'),
        //         placement: 'bottom'
        //     });
        // }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ResourcesSearchView
     * 
     * @events  clear
     *          submit
     * @extends View
     */
    window.ResourcesSearchView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input.search': function(event, $input) {
                        if(event.keyCode === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }
                    }
                }
            });
        },

        /**
         * _parent
         * 
         * @access protected
         * @var    SearchSectionView (default: null)
         */
        _parent: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ResourcesSearchView')
         */
        _string: 'ResourcesSearchView',

        /**
         * _threshold
         * 
         * The maximum number of queries that can be open at once before
         * garbage collection kicks in.
         * 
         * @access protected
         * @var    Number
         */
        _threshold: 10,

        /**
         * _oscar
         * 
         * Destroys QuerySectionView's once the limit has been reached (for
         * memory purposes).
         * 
         * @note   Named oscar after Oscar the Grouch
         * @note   Second length check needs to be made since the destroy
         *         handler changes the response from getChildren
         * @access protected
         * @param  String current the query currently being searched for
         * @return void
         */
        _oscar: function(current) {
            var children = this._parent.getChild('queries').getChildren();
            if (Object.keys(children).length >= this._threshold) {
                for (var query in children) {
                    if (query !== current) {
                        if (Object.keys(children).length >= this._threshold) {
                            children[query].triggerHandler('destroy');
                        }
                    }
                }
            }
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element);
            this._parent = parent;
            this.on({
                'clear': function(event) {
                    var categoryPath = this._parent.getChild('categories').getPath();
                    Stencil.navigate(categoryPath);
                },
                'submit': function(event) {
                    var $input = this.find('input.search'),
                        val = $input.val(),
                        children = this._parent.getChild('queries').getChildren();
                    if (children[val] !== undefined) {
                        this._parent.getChild('queries').getChild(val).triggerHandler(
                            'destroy'
                        );
                    }
                    this._oscar(val);
                    if (Browser.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this._parent.search(val, true);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * TutorialsView
     * 
     * @extends View
     */
    window.TutorialsView = View.extend({

        /**
         * _modal
         * 
         * @access protected
         * @var    TutorialsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TutorialsView')
         */
        _string: 'TutorialsView',

        /**
         * _slug
         * 
         * @access protected
         * @var    String (default: null)
         */
        _slug: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String slug
         * @param  TutorialsModalView modal
         * @return void
         */
        init: function(element, slug, modal) {
            this._super(element);
            this._slug = slug;
            this._modal = modal;
            this.on({
                'overlay': function(event, $div) {
                    var youTubeSlug = $div.attr('youTubeSlug'),
                        modal = Modals.showYouTubeVideo(youTubeSlug, {});
                    // modal.setFallback(this.getPath());
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return void
         */
        getPath: function() {
            return '/app/help/' + (this._slug);
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[tutorials="' + (this._slug) + '"]');
            $anchor.siblings('[tutorials]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AreaView
     * 
     * @extends View
     */
    window.AreaView = View.extend({

        /**
         * _children
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _children: {},

        /**
         * _pulse
         * 
         * This is a reference to the timeout of the current (if any) pulse
         * going on. This is needed to cancel any pulses before starting a new
         * one.
         * 
         * @access protected
         * @var    Number (default: false)
         */
        _pulse: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AreaView')
         */
        _string: 'AreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @note   Below <_children> is needed because of how inheritance works
         *         with the extend.js library
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._children = {};
            this._super(element);
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String type
         * @return SectionView
         */
        getChild: function(type) {
            return this._children[type];
        },

        /**
         * getNav
         * 
         * @access public
         * @return jQuery
         */
        getNav: function() {
            return this.find('> header > nav');
        },

        /**
         * getType
         * 
         * @access public
         * @return String
         */
        getType: function() {
            return this._type;
        },

        /**
         * pulse
         * 
         * @access protected
         * @return void
         */
        pulse: function() {
            var _this = this,
                $anchor = this.find('a[section="stars"]'),
                trigger = function() {
                    $anchor.addClass('pulse');
                },
                cleanup = function() {
                    this._pulse = false;
                    $anchor.removeClass('pulse');
                };
            if (this._pulse) {
                jQuery.timeoutPool.clear(this._pulse);
                $anchor.removeClass('pulse');
                trigger.delay(0);
                this._pulse = cleanup.delay(1200, this);
            } else {
                trigger.call();
                this._pulse = cleanup.delay(1200, this);
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            App.getEditor().setActive(this);
            var $nav = App.getSidebar().getNav(),
                $anchor = $nav.find('[area="' + (this._type) + '"]');
            $anchor.siblings('[area]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * BackgroundsAreaView
     * 
     * @extends AreaView
     */
    window.BackgroundsAreaView = AreaView.extend({

        /**
         * _dropzone
         * 
         * @access protected
         * @var    DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundsAreaView')
         */
        _string: 'BackgroundsAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'backgrounds')
         */
        _type: 'backgrounds',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupDropzone();
            // this._setupColors();
            this._setupSearch();
            this._setupStars();
            this._setupUploads();
        },

        /**
         * _setupDropzone
         * 
         * @access protected
         * @return void
         */
        _setupDropzone: function() {
            var _this = this,
                $dropzone = this.find('.dropzone');
            this._dropzone = new DropzoneView($dropzone, 'background');
            this._dropzone.on({
                'complete': function(event, upload) {
                    Track.event('Background uploaded');
                    var collection = _this.getChild('uploads')._collection;
                    collection.map(upload._data, false);
                    Stencil.navigate('/app/backgrounds/uploads');
                    Account.onboard('backgroundUploaded');
                }
            });
        },

        /**
         * _setupColors
         * 
         * @access protected
         * @return void
         */
        // _setupColors: function() {
        //     var $colors = this.find('section.colors');
        //     this._children.colors = new BackgroundColorsSectionView(
        //         $colors,
        //         this
        //     );
        // },

        /**
         * _setupSearch
         * 
         * @access protected
         * @return void
         */
        _setupSearch: function() {
            var $search = this.find('section.search');
            this._children.search = new BackgroundSearchSectionView(
                $search,
                this
            );
        },

        /**
         * _setupStars
         * 
         * @access protected
         * @return void
         */
        _setupStars: function() {
            var $stars = this.find('section.stars');
            this._children.stars = new BackgroundStarsSectionView($stars, this);
        },

        /**
         * _setupUploads
         * 
         * @access protected
         * @return void
         */
        _setupUploads: function() {
            var $uploads = this.find('section.uploads');
            this._children.uploads = new BackgroundUploadsSectionView(
                $uploads,
                this
            );
        },

        /**
         * getDropzone
         * 
         * @access public
         * @return DropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * GraphicsAreaView
     * 
     * @extends AreaView
     */
    window.GraphicsAreaView = AreaView.extend({

        /**
         * _dropzone
         * 
         * @access protected
         * @var    DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicsAreaView')
         */
        _string: 'GraphicsAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'graphics')
         */
        _type: 'graphics',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupSearch();
            this._setupStars();
            this._setupUploads();
            this._setupDropzone();
        },

        /**
         * _setupDropzone
         * 
         * @access protected
         * @return void
         */
        _setupDropzone: function() {
            var _this = this,
                $dropzone = this.find('.dropzone');
            this._dropzone = new DropzoneView($dropzone, 'graphic');
            this._dropzone.on({
                'complete': function(event, upload) {
                    Track.event('Graphic uploaded');
                    var collection = _this.getChild('uploads')._collection;
                    collection.map(upload._data, false);
                    Stencil.navigate('/app/icons/uploads');
                    Account.onboard('graphicUploaded');
                }
            });
        },

        /**
         * _setupSearch
         * 
         * @access protected
         * @return void
         */
        _setupSearch: function() {
            var $search = this.find('section.search');
            this._children.search = new GraphicSearchSectionView($search, this);
        },

        /**
         * _setupStars
         * 
         * @access protected
         * @return void
         */
        _setupStars: function() {
            var $stars = this.find('section.stars');
            this._children.stars = new GraphicStarsSectionView($stars, this);
        },

        /**
         * _setupUploads
         * 
         * @access protected
         * @return void
         */
        _setupUploads: function() {
            var $uploads = this.find('section.uploads');
            this._children.uploads = new GraphicUploadsSectionView(
                $uploads,
                this
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * ImagesAreaView
     * 
     * @extends AreaView
     */
    window.ImagesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImagesAreaView')
         */
        _string: 'ImagesAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'images')
         */
        _type: 'images',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupAll();
            this._setupStars();
        },

        /**
         * _setupAll
         * 
         * @access protected
         * @return void
         */
        _setupAll: function() {
            var $all = this.find('section.all');
            this._children.all = new AllImagesSectionView($all, this);
        },

        /**
         * _setupStars
         * 
         * @access protected
         * @return void
         */
        _setupStars: function() {
            var $stars = this.find('section.stars');
            this._children.stars = new ImageStarsSectionView($stars, this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * QuotesAreaView
     * 
     * @extends AreaView
     */
    window.QuotesAreaView = AreaView.extend({

        /**
         * _dragImage
         * 
         * @access protected
         * @var    Image (default: null)
         */
        _dragImage: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuotesAreaView')
         */
        _string: 'QuotesAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'quotes')
         */
        _type: 'quotes',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._preloadDragImage();
            this._setupSearch();
            this._setupStars();
        },

        /**
         * _preloadDragImage
         * 
         * @access protected
         * @return void
         */
        _preloadDragImage: function() {
            var url = window.STATIC + Stencil.get('config').defaults.quoteDragImagePath,
                image = new Image();
            image.onload = function() {
                image.width = this.width;
                image.height = this.height;
            };
            image.src = url;
            this._dragImage = image;
        },

        /**
         * _setupSearch
         * 
         * @access protected
         * @return void
         */
        _setupSearch: function() {
            var $search = this.find('section.search');
            this._children.search = new QuoteSearchSectionView($search, this);
        },

        /**
         * _setupStars
         * 
         * @access protected
         * @return void
         */
        _setupStars: function() {
            var $stars = this.find('section.stars');
            this._children.stars = new QuoteStarsSectionView($stars, this);
        },

        /**
         * getDragImage
         * 
         * @access public
         * @return Image
         */
        getDragImage: function() {
            return this._dragImage;
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            // var fontsCollection = Stencil.account().collection('fonts'),
            //     font = fontsCollection.findByFamilyName('Leckerli One');
            // font.loadFull();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResultsView', function() {

    /**
     * FeatureResultsView
     * 
     * @extends ResultsView
     */
    window.FeatureResultsView = ResultsView.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FeatureResultsView')
         */
        _string: 'FeatureResultsView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AllWatermarksSectionView parent
         * @param  Object thumb
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, thumb, category) {
            this._super(element, parent, thumb);
            this._category = category;
        },

        /**
         * draw
         * 
         * @access public
         * @param  Accessor accessor
         * @param  Number position
         * @return void
         */
        draw: function(accessor, position) {
            var $thumb = Stencil.render(this._thumb.template, {
                accessor: accessor,
                locked: this._locked(position),
                thumb: this._thumb.view
            });
            $thumb.data('accessor', accessor);
            $thumb.data('view', new window[this._thumb.view](
                $thumb,
                accessor,
                this._category
            ));
            if (position === 0) {
                this._element.find('div.inner').prepend($thumb);
            } else {
                this._element.find('div.inner').append($thumb);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ResultsView
     * 
     * @extends View
     */
    window.ResultsView = View.extend({

        /**
         * _parent
         * 
         * @access protected
         * @var    MediaSectionView (default: null)
         */
        _parent: null,

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    var parent = this._parent;
                    if (parent._more === true) {
                        if (parent._loading === false) {
                            parent.load();
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @access private
             * @param  jQuery event
             * @param  Number y
             * @param  Boolean top
             * @param  Boolean bottom
             * @return void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.inner');
                bottom = y > ($inner.outerHeight() - this._element.outerHeight() - this._threshold);
                if (bottom === true) {
                    var parent = this._parent;
                    if (parent._more === true) {
                        if (parent._loading === false) {
                            parent.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ResultsView')
         */
        _string: 'ResultsView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered
         * 
         * @access protected
         * @var    Number (default: 350)
         */
        _threshold: 350,

        /**
         * _thumb
         * 
         * Object defining the template and view that should be used when
         * rendering/building a thumb.
         * 
         * @access protected
         * @var    Object (default: null)
         */
        _thumb: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  MediaSectionView parent
         * @param  Object thumb
         * @return void
         */
        init: function(element, parent, thumb) {
            this._super(element);
            this._parent = parent;
            this._thumb = thumb;
            this._addInfiniteScrollEvents();
            this._setupAuth();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            if (Stencil.scrollbars() === true) {
                check = this._scroll.plugin.proxy(this);
                listener = 'jsp-scroll-y';
            }
            this._element.bind(listener, check);
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    if (User.admin() === true || Account.upgraded() === true) {
                        _this.find('.locked').removeClass('locked');
                    }
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.find('.locked').removeClass('locked');
                }
            });
        },

        /**
         * _locked
         * 
         * Returns whether or not a specific result should be locked, based on
         * the config settings for this section, and how many previous results
         * have been written.
         * 
         * @access protected
         * @param  Number position
         * @return Boolean
         */
        _locked: function(position) {
            if (User.admin() === true || Account.upgraded() === true) {
                return false;
            }
            var applicableSectionViews = [
                    'BackgroundSearchCategorySectionView',
                    'BackgroundSearchQuerySectionView',
                    'GraphicSearchCategorySectionView',
                    'GraphicSearchQuerySectionView'
                ],
                sectionViewType = String(this._parent);
            if (jQuery.inArray(sectionViewType, applicableSectionViews) !== -1) {
                var maxFree = Stencil.get('config').defaults.maxFree,
                    lookup = {
                        BackgroundSearchCategorySectionView: maxFree.backgroundFeatures,
                        BackgroundSearchQuerySectionView: maxFree.backgroundResources,
                        GraphicSearchCategorySectionView: maxFree.graphicFeatures,
                        GraphicSearchQuerySectionView: maxFree.graphicResources
                    };
                if ((position + 1) > lookup[sectionViewType]) {
                    return true;
                }
                return false;
            }
            return false;
        },

        /**
         * draw
         * 
         * @access public
         * @param  Accessor accessor
         * @param  Number position
         * @return void
         */
        draw: function(accessor, position) {
            var $thumb = Stencil.render(this._thumb.template, {
                accessor: accessor,
                locked: this._locked(position),
                thumb: this._thumb.view
            });
            $thumb.data('accessor', accessor);
            $thumb.data('view', new window[this._thumb.view]($thumb, accessor));
            if (position === 0) {
                this._element.find('div.inner').prepend($thumb);
            } else {
                this._element.find('div.inner').append($thumb);
            }
        },

        /**
         * lazy
         * 
         * @note   <loading> class used below to ensure no duplicate calls made
         *         to lazyload assets incase a collection <update> event fires
         *         twice. To reproduce this, comment out the <loading> class
         *         lines below, reload browser from Background filters tab,
         *         upload an image, and switch to the uploads tab.
         * @note   <waiting> class is used below in cases where there are
         *         hundreds of assets. In those cases, 50 will be drawn upon
         *         load, but the last X won't be loaded, because they're so far
         *         below the threshold value for preloading. Without the
         *         <waiting> class, an infinite-scroll could trigger an
         *         additional collection:update event, which could result in
         *         multiple lazy events beyond attached to the element. When
         *         that happens, things bust :(
         * @access protected
         * @return void
         */
        lazy: function() {
            var $elements = this.find(
                '.lazy:not(.loading):not(.loaded):not(.waiting)'
            );
            $elements.addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element,
                effect: 'fadeIn',
                appear: function(remaining, settings) {
                    $(this).addClass('loading');
                },
                load: function(remaining, settings, img) {
                    $(this).addClass('loaded');
                    $(this).removeClass('loading');
                    $(this).removeClass('waiting');
                    $(this).removeAttr('data-original');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResultsView', function() {

    /**
     * WatermarkResultsView
     * 
     * Child of ResultsView so that the lazy loading flow can be adjusted.
     * 
     * @extends ResultsView
     */
    window.WatermarkResultsView = ResultsView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkResultsView')
         */
        _string: 'WatermarkResultsView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AllWatermarksSectionView parent
         * @param  Object thumb
         * @return void
         */
        init: function(element, parent, thumb) {
            this._super(element, parent, thumb);
        },

        /**
         * draw
         * 
         * @access public
         * @param  WatermarkAccessor watermark
         * @param  Number position
         * @return void
         */
        // draw: function(watermark, position) {
        //     var $watermark = Stencil.render('Watermark', {
        //         accessor: watermark
        //     });
        //     new WatermarkView($watermark, watermark);
        //     if (position === 0) {
        //         this._element.find('div.inner').prepend($watermark);
        //     } else {
        //         this._element.find('div.inner').append($watermark);
        //     }
        // },

        /**
         * lazy
         * 
         * @note   <loading> class used below to ensure no duplicate calls made
         *         to lazyload assets incase a collection <update> event fires
         *         twice. To reproduce this, comment out the <loading> class
         *         lines below, reload browser from Background filters tab,
         *         upload an image, and switch to the uploads tab.
         * @note   <waiting> class is used below in cases where there are
         *         hundreds of assets. In those cases, 50 will be drawn upon
         *         load, but the last X won't be loaded, because they're so far
         *         below the threshold value for preloading. Without the
         *         <waiting> class, an infinite-scroll could trigger an
         *         additional collection:update event, which could result in
         *         multiple lazy events beyond attached to the element. When
         *         that happens, things bust :(
         * @access public
         * @return void
         */
        lazy: function() {
            var $elements = this.find(
                '.watermark:not(.loading):not(.loaded):not(.waiting) .lazy'
            );
            $elements.parent().addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element,
                effect: 'fadeIn',
                appear: function(remaining, settings) {
                    $(this).parent().addClass('loading');
                },
                load: function(remaining, settings) {
                    $(this).parent().addClass('loaded');
                    $(this).parent().removeClass('loading');
                    $(this).parent().removeClass('waiting');
                    $(this).removeAttr('data-original');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SearchSectionView', function() {

    /**
     * BackgroundSearchSectionView
     * 
     * @extends SearchSectionView
     */
    window.BackgroundSearchSectionView = SearchSectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundSearchSectionView')
         */
        _string: 'BackgroundSearchSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupCategories();
            this._setupResourcesSearch();
            this._setupQueries();
        },

        /**
         * _setupCategories
         * 
         * @access protected
         * @return void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._children.categories = new BackgroundSearchCategoriesSectionView(
                $categories,
                this
            );
        },

        /**
         * _setupResourcesSearch
         * 
         * @access protected
         * @return void
         */
        _setupResourcesSearch: function() {
            var total = Stencil.getPhotoPartnerImageCount().commas(),
                placeholder = 'Search from ' + (total) + '+ royalty-free ' +
                    'photos',
                $resourcesSearch = Stencil.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').append($resourcesSearch);
        },

        /**
         * _setupQueries
         * 
         * @access protected
         * @return void
         */
        _setupQueries: function() {
            var $queries = this.find('section.queries');
            this._children.queries = new BackgroundSearchQueriesSectionView(
                $queries,
                this
            );
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Boolean refresh
         * @return void
         */
        search: function(query, refresh) {
            query = encodeURIComponent(query);
            var path = '/app/backgrounds/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * BackgroundSearchCategoriesSectionView
     * 
     * @extends SectionView
     */
    window.BackgroundSearchCategoriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundSearchCategoriesSectionView')
         */
        _string: 'BackgroundSearchCategoriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String slug
         * @return void
         */
        _drawChild: function(slug) {
            var category = this._getCategory(slug),
                $results = Stencil.render('BackgroundCategorySection', {
                    category: category
                });
            this._element.append($results);
            this._children[slug] = new BackgroundSearchCategorySectionView(
                $results,
                this,
                category
            );
        },

        /**
         * _getCategory
         * 
         * @access protected
         * @param  String slug
         * @return CategoryAccessor
         */
        _getCategory: function(slug) {
            return Stencil.get('categories').filter(function(index, category) {
                return category.get('type') === 'background'
                    && category.get('slug') === slug;
            }).shift();
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String slug
         * @return BackgroundSearchCategorySectionView
         */
        getChild: function(slug) {
            if (this._super(slug) === undefined) {
                this._drawChild(slug);
            }
            return this._super(slug);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/backgrounds/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            if (this._active === null) {
                return this.getChild('featured').getPath();
            }
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').val('');
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().removeClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategorySectionView', function() {

    /**
     * BackgroundSearchCategorySectionView
     * 
     * @extends CategorySectionView
     */
    window.BackgroundSearchCategorySectionView = CategorySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundSearchCategorySectionView')
         */
        _string: 'BackgroundSearchCategorySectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'BackgroundThumb',
            view: 'BackgroundFeatureThumbView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundSearchQueriesSectionView parent
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, category) {
            this._super(element, parent, category);
            this._collection = new BackgroundFeaturesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.backgrounds.categories;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                category: this._category.get('id'),
                limit: limit,
                offset: results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            this._parent._parent.find('input.search').blur();
            if (this._category.get('slug') === 'featured') {
                Browser.tablet() === false
                    && Browser.ie() === false
                    && this._parent._parent.find('input.search').focus();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuerySectionView', function() {

    /**
     * BackgroundSearchQuerySectionView
     * 
     * @extends QuerySectionView
     */
    window.BackgroundSearchQuerySectionView = QuerySectionView.extend({

        /**
         * _lastLoadStats
         * 
         * @access protected
         * @var    false|Object (default: false)
         */
        _lastLoadStats: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundSearchQuerySectionView')
         */
        _string: 'BackgroundSearchQuerySectionView',

        /**
         * _threshold
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, Pixabay links
         * expire after 24 hours.
         * 
         * @see    https://pixabay.com/api/docs/
         * @see    https://i.imgur.com/484aa4c.png
         * @access protected
         * @var    Number
         */
        _threshold: (24 * 60 * 60) - 60,

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'BackgroundThumb',
            view: 'BackgroundResourceThumbView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundSearchQueriesSectionView parent
         * @param  String query
         * @return void
         */
        init: function(element, parent, query) {
            this._super(element, parent, query);
            this._collection = new BackgroundResourcesCollection();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            // return '/app/backgrounds/search/' + (this._query);
            return '/app/backgrounds/search/' + encodeURIComponent(this._query);
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.backgrounds.results;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;

            // Gateway check
            var backgroundSearchRange = Stencil.get('config').defaults.backgroundSearchRange.toLowerCase(),
                backgroundSearchGateway = Stencil.get('config').defaults.backgroundSearchGateway.toLowerCase();
            if (backgroundSearchRange === 'single' && Services.check(backgroundSearchGateway) === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    lastLoadStats: this._lastLoadStats,
                    limit: limit,
                    offset: results,
                    query: this._query,
                    type: 'background'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    _this._lastLoadStats = response.data.stats;
                    if (_this._more === false) {
                        _this.find('div.status.finished').removeClass('hidden');
                    }
                    // _this._detectEnd(limit);
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * BackgroundSearchQueriesSectionView
     * 
     * @extends SectionView
     */
    window.BackgroundSearchQueriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundSearchQueriesSectionView')
         */
        _string: 'BackgroundSearchQueriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String query
         * @return void
         */
        _drawChild: function(query) {
            var $results = Stencil.render('QuerySection', {
                cC0TooltipCopy: 'These photos are free to use for personal ' +
                    '&amp; commercial use under Creative Commons CC0',
                fallback: {
                    link: '/app/backgrounds/search/puppies',
                    copy: 'Puppies'
                },
                query: query
            });
            $results.attr('query', query);
            this._element.append($results);
            this._children[query] = new BackgroundSearchQuerySectionView(
                $results,
                this,
                query
            );
            var _this = this;
            this._children[query].on('destroy', function(event) {
                delete _this._children[query];
            });
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String query
         * @return BackgroundSearchQuerySectionView
         */
        getChild: function(query) {
            if (this._super(query) === undefined) {
                this._drawChild(query);
            }
            return this._super(query);
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().addClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * BackgroundStarsSectionView
     * 
     * @extends MediaSectionView
     */
    window.BackgroundStarsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    BackgroundStarsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'backgrounds',
            children: ['stars']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundStarsSectionView')
         */
        _string: 'BackgroundStarsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'BackgroundThumb',
            view: 'BackgroundStarThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'stars')
         */
        _type: 'stars',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new BackgroundStarsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._results.draw(accessor, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.backgrounds.stars;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'background'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * BackgroundUploadsSectionView
     * 
     * @extends MediaSectionView
     */
    window.BackgroundUploadsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    BackgroundUploadsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'backgrounds',
            children: ['uploads']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundUploadsSectionView')
         */
        _string: 'BackgroundUploadsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'BackgroundThumb',
            view: 'BackgroundUploadThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'uploads')
         */
        _type: 'uploads',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  BackgroundsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new BackgroundUploadsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, template, position) {
                    _this._results.draw(template, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.backgrounds.uploads;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'background'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * CategorySectionView
     * 
     * @extends MediaSectionView
     */
    window.CategorySectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    FeaturesCollection (default: null)
         */
        _collection: null,

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CategorySectionView')
         */
        _string: 'CategorySectionView',

        /**
         * _thumb
         * 
         * Defines the template and View that ought to be used when drawing a
         * thumb.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _thumb: {},

        /**
         * init
         * 
         * @note   Important for the category to be set before the parent
         *         constructor is called.
         * @access public
         * @param  jCategory element
         * @param  SectionView parent
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, category) {
            this._category = category;
            this._super(element, parent);
            this._setupCategoriesMenu();
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            if (User.admin() === true) {
                this._setupSort();
            }
            User.once({
                'login': function(event, user) {
                    if (User.admin() === true) {
                        _this._setupSort();
                    }
                }
            });
        },

        /**
         * _setupCategoriesMenu
         * 
         * @access protected
         * @return void
         */
        _setupCategoriesMenu: function() {
            this.on({
                'menu/close': function(event) {
                    this.find('div.filter').removeClass('expanded');
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('div.filter').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover').length === 0) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.keyCode === 27) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupResults
         * 
         * @access protected
         * @return void
         */
        _setupResults: function() {
            var $results = this.find('.results');
            if (Stencil.scrollbars() === true) {
                this._scrollable($results);
            } else {
                $results.scroll(function(event) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                });
            }
            this._results = new FeatureResultsView(
                $results,
                this,
                this._thumb,
                this._category
            );
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return this._category.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this.triggerHandler('menu/close');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this.refresh();
            if (this._loaded === false) {
                this.once({
                    'loaded': function() {
                        this._results.hourglass();
                    }
                });
                this._results.hourglass();
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SearchSectionView', function() {

    /**
     * GraphicSearchSectionView
     * 
     * @extends SearchSectionView
     */
    window.GraphicSearchSectionView = SearchSectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicSearchSectionView')
         */
        _string: 'GraphicSearchSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupCategories();
            this._setupResourcesSearch();
            this._setupQueries();
        },

        /**
         * _setupCategories
         * 
         * @access protected
         * @return void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._children.categories = new GraphicSearchCategoriesSectionView(
                $categories,
                this
            );
        },

        /**
         * _setupResourcesSearch
         * 
         * @access protected
         * @return void
         */
        _setupResourcesSearch: function() {
            var total = Stencil.get('config').theNounProject.total.commas(),
                placeholder = 'Search from ' + (total) + '+ royalty-free icons',
                $resourcesSearch = Stencil.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').append($resourcesSearch);
        },

        /**
         * _setupQueries
         * 
         * @access protected
         * @return void
         */
        _setupQueries: function() {
            var $queries = this.find('section.queries');
            this._children.queries = new GraphicSearchQueriesSectionView(
                $queries,
                this
            );
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Boolean refresh
         * @return void
         */
        search: function(query, refresh) {
            query = encodeURIComponent(query);
            var path = '/app/icons/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * GraphicSearchCategoriesSectionView
     * 
     * @extends SectionView
     */
    window.GraphicSearchCategoriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicSearchCategoriesSectionView')
         */
        _string: 'GraphicSearchCategoriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String slug
         * @return void
         */
        _drawChild: function(slug) {
            var category = this._getCategory(slug),
                $results = Stencil.render('GraphicCategorySection', {
                    category: category
                });
            this._element.append($results);
            this._children[slug] = new GraphicSearchCategorySectionView(
                $results,
                this,
                category
            );
        },

        /**
         * _getCategory
         * 
         * @access protected
         * @param  String slug
         * @return CategoryAccessor
         */
        _getCategory: function(slug) {
            return Stencil.get('categories').filter(function(index, category) {
                return category.get('type') === 'graphic'
                    && category.get('slug') === slug;
            }).shift();
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String slug
         * @return BackgroundSearchCategorySectionView
         */
        getChild: function(slug) {
            if (this._super(slug) === undefined) {
                this._drawChild(slug);
            }
            return this._super(slug);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/icons/search/shape
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            if (this._active === null) {
                return this.getChild('featured').getPath();
            }
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').val('');
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().removeClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategorySectionView', function() {

    /**
     * GraphicSearchCategorySectionView
     * 
     * @extends CategorySectionView
     */
    window.GraphicSearchCategorySectionView = CategorySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicSearchCategorySectionView')
         */
        _string: 'GraphicSearchCategorySectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'GraphicThumb',
            view: 'GraphicFeatureThumbView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicSearchQueriesSectionView parent
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, category) {
            this._super(element, parent, category);
            this._collection = new GraphicFeaturesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.graphics.categories;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                category: this._category.get('id'),
                limit: limit,
                offset: results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            this._parent._parent.find('input.search').blur();
            if (this._category.get('slug') === 'featured') {
                Browser.tablet() === false
                    && Browser.ie() === false
                    && this._parent._parent.find('input.search').focus();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuerySectionView', function() {

    /**
     * GraphicSearchQuerySectionView
     * 
     * @todo    It looks like The Noun Project sometimes caches responses of 
     *          searches. This is important, and has large implications, because
     *          if a search is done at 7:49PM EST, returned results have 1 hour
     *          before the SVG links expire. So, to accommodate this, you can
     *          see the <_threshold> valid below. But the problem with TNP
     *          caching requests is that if someone else comes along at 8:40PM
     *          EST, TNP might be returning links that expire 9 minutes later,
     *          contrasting that users relative <_threshold> value. So to deal
     *          with this, the <_threshold> value below should be used in
     *          conjunction with the lowest Expires value found in the SVGs that
     *          are returned. Here's a sample SVG link:
     *          https://d30y9cdsu7xlg0.cloudfront.net/noun-svg/215288.svg?Expires=1452645199&Signature=cGU10SmwvHMJc4drNz-eavJO2RQwqXPuursIR74nzdtTAo~LHmdsBgbq49dJfQbWzfn-0ee93gqvK8ZT9L7uwiL38jkDEEmuWIOGOFUIlu95EyhY1l-BnXcCB0TTKVFUGd8jfF9kYDo6iC27PoANo43-RuVWtIOoBtjwvYu9R3E_&Key-Pair-Id=APKAI5ZVHAXN65CHVU2Q
     *          So go through all icons in a collection during the interval
     *          check, and see if the Expires parameter has been passed, and if
     *          so, kill the QuerySectionView and go again.
     *          Note that maybe instead of going through the collection each
     *          interval-period, maybe just get the Math.min value from them
     *          each time the collection is grown, and use that in the interval.
     * @extends QuerySectionView
     */
    window.GraphicSearchQuerySectionView = QuerySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicSearchQuerySectionView')
         */
        _string: 'GraphicSearchQuerySectionView',

        /**
         * _threshold
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, The Noun
         * Project expires links after 1 hour, though their documentation states
         * 24 hours :/
         * 
         * @see    http://api.thenounproject.com/documentation.html
         * @see    https://i.imgur.com/mOrzOwT.png
         * @access protected
         * @var    Number
         */
        // _threshold: (24 * 60 * 60) - 60,
        _threshold: (1 * 60 * 60) - 60,
        // _threshold: 60,

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'GraphicThumb',
            view: 'GraphicResourceThumbView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicSearchQueriesSectionView parent
         * @param  String query
         * @return void
         */
        init: function(element, parent, query) {
            this._super(element, parent, query);
            this._collection = new GraphicResourcesCollection();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    var svg = resource.get('urls').svg,
                        expires;
                    if (svg.match(/Expires\=([0-9]+)/) !== null) {
                        expires = svg.match(/Expires\=([0-9]+)/).pop();
                        _this._expires = Math.min(_this._expires, expires);
                    }
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            // return '/app/icons/search/' + (this._query);
            return '/app/icons/search/' + encodeURIComponent(this._query);
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.graphics.results;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            if (Services.check('theNounProject') === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    limit: limit,
                    offset: results,
                    query: this._query,
                    type: 'graphic'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    if (_this._more === false) {
                        _this.find('div.status.finished').removeClass('hidden');
                    }
                    // _this._detectEnd(limit);
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * GraphicSearchQueriesSectionView
     * 
     * @extends SectionView
     */
    window.GraphicSearchQueriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicSearchQueriesSectionView')
         */
        _string: 'GraphicSearchQueriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String query
         * @return void
         */
        _drawChild: function(query) {
            var $results = Stencil.render('QuerySection', {
                cC0TooltipCopy: 'These icons &amp; graphics are free to use ' +
                    'for personal &amp; commercial use',
                fallback: {
                    link: '/app/icons/search/fruit',
                    copy: 'Fruit'
                },
                query: query
            });
            $results.attr('query', query);
            this._element.append($results);
            this._children[query] = new GraphicSearchQuerySectionView(
                $results,
                this,
                query
            );
            var _this = this;
            this._children[query].on('destroy', function(event) {
                delete _this._children[query];
            });
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String query
         * @return GraphicSearchQuerySectionView
         */
        getChild: function(query) {
            if (this._super(query) === undefined) {
                this._drawChild(query);
            }
            return this._super(query);
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().addClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * GraphicStarsSectionView
     * 
     * @extends MediaSectionView
     */
    window.GraphicStarsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    GraphicStarsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'graphics',
            children: ['stars']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicStarsSectionView')
         */
        _string: 'GraphicStarsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'GraphicThumb',
            view: 'GraphicStarThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'stars')
         */
        _type: 'stars',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new GraphicStarsCollection();
            this._setupAuth();
            this._setupTooltips();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._results.draw(accessor, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                limit = Stencil.get('config').defaults.objectsPerPage.graphics.stars,
                results = this.results();
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'graphic'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * GraphicUploadsSectionView
     * 
     * @extends MediaSectionView
     */
    window.GraphicUploadsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    GraphicUploadsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'graphics',
            children: ['uploads']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicUploadsSectionView')
         */
        _string: 'GraphicUploadsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'GraphicThumb',
            view: 'GraphicUploadThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'uploads')
         */
        _type: 'uploads',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  GraphicsAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new GraphicUploadsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, template, position) {
                    _this._results.draw(template, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.graphics.uploads;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'graphic'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * AllImagesSectionView
     * 
     * @extends MediaSectionView
     */
    window.AllImagesSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'images',
            children: ['all']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AllImagesSectionView')
         */
        _string: 'AllImagesSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'ImageThumb',
            view: 'ImageThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'all')
         */
        _type: 'all',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImagesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new ImagesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, image, position) {
                    _this._results.draw(image, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @note   I check whether there is only one accessor loaded into the
         *         collection to account for the case of when a user saves an
         *         image _before_ the collection has initially been loaded.
         *         The problem is that if the user saves an image (from a tab
         *         that is not the /app/saved tab), the app will add the draft
         *         accessor to the collection, and then fire off a /images call
         *         to get all the other ones for that user.
         *         When that happens, the offset value being sent to the server
         *         would normally be 1 (since there is one accessor in the
         *         collection already), but the problem there is that the
         *         associated image record doesn't have an <uploaded> value of
         *         <1> yet (since it's still uploading), which results in
         *         skipping the first image that has it's image record _truly_
         *         marked as uploaded. Ya, whacky, but this should work for now.
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.images.all;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results === 1 ? (results - 1) : results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * ImageStarsSectionView
     * 
     * @extends MediaSectionView
     */
    window.ImageStarsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    ImageStarsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'images',
            children: ['stars']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageStarsSectionView')
         */
        _string: 'ImageStarsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'ImageThumb',
            view: 'ImageStarThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'stars')
         */
        _type: 'stars',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImagesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new ImageStarsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, image, position) {
                    _this._results.draw(image, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.images.stars;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'image'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * MediaSectionView
     * 
     * @extends SectionView
     */
    window.MediaSectionView = SectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    Collection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _more: true,

        /**
         * _results
         * 
         * @access protected
         * @var    ResultsView (default: null)
         */
        _results: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'MediaSectionView')
         */
        _string: 'MediaSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupResults();
            if (this._signature) {
                var clone = jQuery.extend({}, this._signature);
                Stencil.queue.add(clone);
            }
        },

        /**
         * _detectEnd
         * 
         * Checks whether there are any more results, and if not, shows the
         * finished UI state for the results. The catch here is that it'll only
         * show that state if at least one infinite load has happened. I
         * interpret this by checking the number of accessors in the collection,
         * and compare it with the max that are shown per-load for this
         * MediaSectionView.
         * 
         * It's worth noting that this check is not done in QuerySectionView's
         * since in those ones, I never actually know if I've reached the end.
         * It always takes one more request to the server to determine if the
         * end has been reached. So for those kinds of experiences, I can't do a
         * check against the number of accessors in the collection, relative to
         * the limit for the view.
         * 
         * @access public
         * @param  Number limit
         * @return void
         */
        _detectEnd: function(limit) {
            if (this._more === false) {
                if (this.results() > limit) {
                    this.find('div.status.finished').removeClass('hidden');
                }
            }
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
        },

        /**
         * _setupSort
         * 
         * @see    https://github.com/RubaXa/Sortable
         * @access protected
         * @return void
         */
        _setupSort: function() {
            var _this = this,
                list = this.find('.inner')[0];
            Sortable.create(list, {
                scroll: true,
                handle: '.move',
                ghostClass: 'ghost',
                onUpdate: function(event) {
                    var accessor = $(event.item).data('accessor');
                    _this._collection.move(accessor, event.newIndex);

                    /**
                     * For some reason, after a sort has been perormed, the
                     * Sortable class seems to set the draggable attribute
                     * of the a.overlay (and all child-elements of the thumb,
                     * along with the div.thumb element itself) to false. So I
                     * simply reinstate this.
                     */
                    App.getEditor().getJoystick().find('a.overlay').attr(
                        'draggable',
                        'true'
                    );
                }//,
                // onMove: function(event) {
                //     _this.refresh();
                // }
            });
            var delay = Stencil.getSaveDelay('sort');
            this._collection.on({
                'move': _.debounce(
                    this._collection.sort.proxy(this._collection, [this._category]),
                    delay
                )
            });
        },

        /**
         * _setupResults
         * 
         * @access protected
         * @return void
         */
        _setupResults: function() {
            var $results = this.find('.results');
            if (Stencil.scrollbars() === true) {
                this._scrollable($results);
            } else {
                $results.scroll(function(event) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                });
            }
            this._results = new ResultsView($results, this, this._thumb);
        },

        /**
         * getCollection
         * 
         * @access public
         * @return Collection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * results
         * 
         * Returns the number of items in the MediaSectionView's collection.
         * 
         * @access public
         * @return Number
         */
        results: function() {
            return this._collection.all().length;
        },

        /**
         * scrollToTop
         * 
         * @access public
         * @return void
         */
        scrollToTop: function() {
            var $results = this.find('.results');
            if ($results.scrollTop() !== 0) {
                $results.animate({scrollTop: 0}, 'fast');
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                // if (this._signature) {
                //     Stencil.queue.remove(this._signature);
                // }

                // If there are no results, show the hourglass
                if (this.results() === 0) {
                    this.once({
                        'loaded': function() {
                            this._results.hourglass();
                        }
                    });
                    this._results.hourglass();
                }

                // Go forth and load
                this.load();
            }
        },

        /**
         * smart
         * 
         * Could not think of a good name for this method. It show/hides the
         * appropriate elements based on whether the collection contains any
         * objects or not.
         * 
         * @access public
         * @return void
         */
        smart: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty').addClass('hidden');
            if (this._collection.all().length === 0) {
                this.find('.results').addClass('hidden');
                this.find('.messaging,.empty').removeClass('hidden');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * QuerySectionView
     * 
     * @extends MediaSectionView
     */
    window.QuerySectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    ResourcesCollection (default: null)
         */
        _collection: null,

        /**
         * _expires
         * 
         * Records the timestamp in the future that the query results will
         * expire. For Pixabay, this is set to 24 hours, since that's how their
         * API is structure. The Noun Project is a bit more complicated.
         * 
         * They've communicate one hour in the past, though their documentation
         * states 24 hours. However sometimes, SVG links for icons come back
         * with expiry unix timestamps sooner than one hour. So this <_expires>
         * unix timestamp is either one hour in the future, or the soonest
         * expiring unix timestamp for one of the icons loaded.
         * 
         * @access protected
         * @var    Number (default: 0)
         */
        _expires: 0,

        /**
         * _maxNumberOfReloads
         * 
         * The maximum number of times a query can be reloaded (to prevent bug
         * whereby requests were coming in thousands of times from one machine).
         * 
         * @access protected
         * @var    Number (default: 10)
         */
        _maxNumberOfReloads: 10,

        /**
         * _numberOfTimesReloaded
         * 
         * Tracks the number of times the query has been reloaded (which
         * happens based on the expiry dates of the returned resources).
         * 
         * @access protected
         * @var    Number (default: 0)
         */
        _numberOfTimesReloaded: 0,

        /**
         * _query
         * 
         * @access protected
         * @var    String (default: null)
         */
        _query: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuerySectionView')
         */
        _string: 'QuerySectionView',

        /**
         * _threshold
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons).
         * 
         * @access protected
         * @var    Number
         */
        _threshold: (24 * 60 * 60) - 60,

        /**
         * _thumb
         * 
         * Defines the template and View that ought to be used when drawing a
         * thumb.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _thumb: {},

        /**
         * _timestamp
         * 
         * Records timestamp of the initial results load. Used to detect whether
         * it's been x minutes since the last interaction, to prevent
         * bugs/issues with someone doing a search, leaving for greater than the
         * lifetime of the link, and then coming back and attempting to interact
         * with a result.
         * 
         * Without this, the app will error out when they try to interact with a
         * result that is expired.
         * 
         * @note   No longer being used because of the need to have the _expires
         *         unix timestamp updated based on individual icons, and their
         *         respective <Expires> parameter value.
         * @access protected
         * @var    Number
         */
        // _timestamp: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SectionView parent
         * @param  String query
         * @return void
         */
        init: function(element, parent, query) {
            this._super(element, parent);
            this._expires = Math.floor(Date.now() / 1000) + this._threshold;
            this._query = query;
            // this._timestamp = Math.floor(Date.now() / 1000);
            this.on({
                'destroy': function(event) {
                    this.find('.joystick').detach();
                    this._element.remove();
                }
            });
            this._setupInterval();
        },

        /**
         * _setupInterval
         * 
         * @access protected
         * @return void
         */
        _setupInterval: function() {
            (function() {
                var now = Math.floor(Date.now() / 1000);
                // if (this._timestamp + this._threshold < now) {
                if (this._expires < now) {
                    this._numberOfTimesReloaded++;
                    if (
                        this._numberOfTimesReloaded > this._maxNumberOfReloads
                    ) {
                        Stencil.alert('search.bug')
                        Stencil.kill();
                    } else {
                        // this._timestamp = now;
                        this._expires = now + this._threshold;
                        this._collection.empty();
                        this.load();
                    }
                }
            }).interval(250, this);
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.getParent().find('input.search').val(this._query);
            this._parent.getParent().find('input.search').parent().addClass('queried');
            this._parent.setActive(this);
            this._parent.show();
            Browser.tablet() === false
                && Browser.ie() === false
                && this._parent._parent.find('input.search').focus();
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this.refresh();
            if (this._loaded === false) {
                this.once({
                    'loaded': function() {
                        this._results.hourglass();
                    }
                });
                this._results.hourglass();
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SearchSectionView', function() {

    /**
     * QuoteSearchSectionView
     * 
     * @extends SearchSectionView
     */
    window.QuoteSearchSectionView = SearchSectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteSearchSectionView')
         */
        _string: 'QuoteSearchSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuotesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupCategories();
            this._setupResourcesSearch();
            this._setupQueries();
        },

        /**
         * _setupCategories
         * 
         * @access protected
         * @return void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._children.categories = new QuoteSearchCategoriesSectionView(
                $categories,
                this
            );
        },

        /**
         * _setupResourcesSearch
         * 
         * @access protected
         * @return void
         */
        _setupResourcesSearch: function() {
            var total = Stencil.getQuotesCount().commas(),
                placeholder = 'Search from over ' + (total) + '+ quotes',
                $resourcesSearch = Stencil.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').append($resourcesSearch);
        },

        /**
         * _setupQueries
         * 
         * @access protected
         * @return void
         */
        _setupQueries: function() {
            var $queries = this.find('section.queries');
            this._children.queries = new QuoteSearchQueriesSectionView(
                $queries,
                this
            );
        },

        /**
         * search
         * 
         * @access public
         * @param  String query
         * @param  Boolean refresh
         * @return void
         */
        search: function(query, refresh) {
            query = encodeURIComponent(query);
            var path = '/app/quotes/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * QuoteSearchCategoriesSectionView
     * 
     * @extends SectionView
     */
    window.QuoteSearchCategoriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteSearchCategoriesSectionView')
         */
        _string: 'QuoteSearchCategoriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuoteSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String slug
         * @return void
         */
        _drawChild: function(slug) {
            var category = this._getCategory(slug),
                $results = Stencil.render('QuoteCategorySection', {
                    category: category
                });
            this._element.append($results);
            this._children[slug] = new QuoteSearchCategorySectionView(
                $results,
                this,
                category
            );
        },

        /**
         * _getCategory
         * 
         * @access protected
         * @param  String slug
         * @return CategoryAccessor
         */
        _getCategory: function(slug) {
            return Stencil.get('categories').filter(function(index, category) {
                return category.get('type') === 'quote'
                    && category.get('slug') === slug;
            }).shift();
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String slug
         * @return QuoteSearchCategorySectionView
         */
        getChild: function(slug) {
            if (this._super(slug) === undefined) {
                this._drawChild(slug);
            }
            return this._super(slug);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/quotes/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            if (this._active === null) {
                return this.getChild('featured').getPath();
            }
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').val('');
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().removeClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategorySectionView', function() {

    /**
     * QuoteSearchCategorySectionView
     * 
     * @extends CategorySectionView
     */
    window.QuoteSearchCategorySectionView = CategorySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteSearchCategorySectionView')
         */
        _string: 'QuoteSearchCategorySectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'QuoteRow',
            view: 'QuoteFeatureRowView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuoteSearchQueriesSectionView parent
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, category) {
            this._super(element, parent, category);
            this._collection = new QuoteFeaturesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.quote.row').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    // _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.quotes.categories;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                category: this._category.get('id'),
                limit: limit,
                offset: results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            this._parent._parent.find('input.search').blur();
            if (this._category.get('slug') === 'featured') {
                Browser.tablet() === false
                    && Browser.ie() === false
                    && this._parent._parent.find('input.search').focus();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuerySectionView', function() {

    /**
     * QuoteSearchQuerySectionView
     * 
     * @extends QuerySectionView
     */
    window.QuoteSearchQuerySectionView = QuerySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteSearchQuerySectionView')
         */
        _string: 'QuoteSearchQuerySectionView',

        /**
         * _threshold
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, Pixabay links
         * expire after 24 hours.
         * 
         * @see    https://pixabay.com/api/docs/
         * @see    https://i.imgur.com/484aa4c.png
         * @access protected
         * @var    Number
         */
        _threshold: (24 * 60 * 60) - 60,

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'QuoteRow',
            view: 'QuoteResourceRowView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuoteSearchQueriesSectionView parent
         * @param  String query
         * @return void
         */
        init: function(element, parent, query) {
            this._super(element, parent, query);
            this._collection = new QuoteResourcesCollection();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.quote.row').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    // _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return '/app/quotes/search/' + encodeURIComponent(this._query);
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.quotes.results;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;

            // Gateway check
            if (Services.check('quotes') === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    limit: limit,
                    offset: results,
                    query: this._query,
                    type: 'quote'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    if (_this._more === false) {
                        _this.find('div.status.finished').removeClass('hidden');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * QuoteSearchQueriesSectionView
     * 
     * @extends SectionView
     */
    window.QuoteSearchQueriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteSearchQueriesSectionView')
         */
        _string: 'QuoteSearchQueriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuoteSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String query
         * @return void
         */
        _drawChild: function(query) {
            var $results = Stencil.render('QuerySection', {
                // cC0TooltipCopy: 'These quotes are free to use for personal ' +
                //     '&amp; commercial use',
                cC0TooltipCopy: false,
                fallback: {
                    link: '/app/quotes/search/love',
                    copy: 'Love'
                },
                query: query
            });
            $results.attr('query', query);
            this._element.append($results);
            this._children[query] = new QuoteSearchQuerySectionView(
                $results,
                this,
                query
            );
            var _this = this;
            this._children[query].on('destroy', function(event) {
                delete _this._children[query];
            });
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String query
         * @return QuoteSearchQuerySectionView
         */
        getChild: function(query) {
            if (this._super(query) === undefined) {
                this._drawChild(query);
            }
            return this._super(query);
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._parent.find('input.search').parent().removeClass('active');
            this._parent.find('input.search').parent().addClass('queried');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * QuoteStarsSectionView
     * 
     * @extends MediaSectionView
     */
    window.QuoteStarsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    QuoteStarsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'quotes',
            children: ['stars']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteStarsSectionView')
         */
        _string: 'QuoteStarsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'QuoteRow',
            view: 'QuoteStarRowView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'stars')
         */
        _type: 'stars',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  QuotesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new QuoteStarsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._results.draw(accessor, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.quote.row').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    // _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.quotes.stars;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'quote'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * SearchSectionView
     * 
     * @extends SectionView
     */
    window.SearchSectionView = SectionView.extend({

        /**
         * _resourcesSearch
         * 
         * @access protected
         * @var    ResourcesSearch (default: null)
         */
        _resourcesSearch: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SearchSectionView')
         */
        _string: 'SearchSectionView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'search')
         */
        _type: 'search',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupTooltips();
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {

            // Needs to be done first
            this._super();

            // App sidebar navigation
            var path = this._active.getPath(),
                $sidebar = App.getSidebar(),
                $nav = $sidebar.getNav(),
                type = this._parent.getType();
            $nav.find('a[area="' + (type) + '"]').attr('href', path);

            // Area navigation
            var $nav = this._parent.getNav(),
                $anchor = $nav.find('[section="search"]');
            $anchor.attr('href', path);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SectionView
     * 
     * @events  destroy
     *          loaded
     * @extends View
     */
    window.SectionView = View.extend({

        /**
         * _$scrollable
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$scrollable: null,

        /**
         * _active
         * 
         * @access protected
         * @var    SectionView (default: null)
         */
        _active: null,

        /**
         * _children
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _children: {},

        /**
         * _parent
         * 
         * @access protected
         * @var    AreaView|SectionView (default: null)
         */
        _parent: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SectionView')
         */
        _string: 'SectionView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  View parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element);
            this._parent = parent;
            this._children = {};
            this._$scrollable = null;
        },

        /**
         * _scrollable
         * 
         * @see    http://jquery-custom-scrollbar.rocketmind.pl/
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        _scrollable: function($element) {
            this._$scrollable = $element;
            // this._$scrollable.on(
            //     'focus',
            //     'div,a,span',
            //     function() {
            //         $(this).blur();
            //     }
            // );
            this._$scrollable.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._$scrollable.bind(
                'jsp-scroll-y',
                function(event, y, top, bottom) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                }
            );

            // Resizing
            var resize = function() {
                $element.data('jsp').reinitialise();
            };
            $(window).resize(resize);
            this.on('destroy', function() {
                $(window).unbind('resize', resize);
            });
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String type
         * @return SectionView
         */
        getChild: function(type) {
            return this._children[type];
        },

        /**
         * getChildren
         * 
         * @access public
         * @return Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getParent
         * 
         * @access public
         * @return AreaView|SectionView
         */
        getParent: function() {
            return this._parent;
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            this._$scrollable && this._$scrollable.data('jsp').reinitialise();
        },

        /**
         * setActive
         * 
         * @access public
         * @param  SectionView section
         * @return void
         */
        setActive: function(section) {
            this._active = section;
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {

            // Area/parent-Section showing
            this._parent.show();

            // Nav highlighting / DOM switching
            var $nav = this._parent.getNav(),
                $anchor = $nav.find('[section="' + (this._type) + '"]');
            $anchor.siblings('[section]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');

            // App navigation
            var $sidebar = App.getSidebar();
            $nav = $sidebar.getNav();
            $nav.find('a[area="' + (this._parent.getType()) + '"]').attr(
                'href',
                $anchor.attr('href')
            );

            // Scrollbar refresh
            this.refresh();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SearchSectionView', function() {

    /**
     * TemplateSearchSectionView
     * 
     * @extends SearchSectionView
     */
    window.TemplateSearchSectionView = SearchSectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateSearchSectionView')
         */
        _string: 'TemplateSearchSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplatesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._setupCategories();
        },

        /**
         * _setupCategories
         * 
         * @access protected
         * @return void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._children.categories = new TemplateSearchCategoriesSectionView(
                $categories,
                this
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SectionView', function() {

    /**
     * TemplateSearchCategoriesSectionView
     * 
     * @extends SectionView
     */
    window.TemplateSearchCategoriesSectionView = SectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateSearchCategoriesSectionView')
         */
        _string: 'TemplateSearchCategoriesSectionView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplateSearchSectionView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
        },

        /**
         * _drawChild
         * 
         * @access protected
         * @param  String slug
         * @return void
         */
        _drawChild: function(slug) {
            var category = this._getCategory(slug),
                $results = Stencil.render('TemplateCategorySection', {
                    category: category
                });
            this._element.append($results);
            this._children[slug] = new TemplateSearchCategorySectionView(
                $results,
                this,
                category
            );
        },

        /**
         * _getCategory
         * 
         * @access protected
         * @param  String slug
         * @return CategoryAccessor
         */
        _getCategory: function(slug) {
            return Stencil.get('categories').filter(function(index, category) {
                return category.get('type') === 'template'
                    && category.get('slug') === slug;
            }).shift();
        },

        /**
         * getChild
         * 
         * @access public
         * @param  String slug
         * @return TemplateSearchCategorySectionView
         */
        getChild: function(slug) {
            if (this._super(slug) === undefined) {
                this._drawChild(slug);
            }
            return this._super(slug);
        },

        /**
         * getPath
         * 
         * @access public
         * @return String
         */
        getPath: function() {
            return this._active.getPath();
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._parent.setActive(this);
            this._parent.show();
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategorySectionView', function() {

    /**
     * TemplateSearchCategorySectionView
     * 
     * @extends CategorySectionView
     */
    window.TemplateSearchCategorySectionView = CategorySectionView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateSearchCategorySectionView')
         */
        _string: 'TemplateSearchCategorySectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'TemplateThumb',
            view: 'TemplateFeatureThumbView'
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplateSearchQueriesSectionView parent
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, parent, category) {
            this._super(element, parent, category);
            this._collection = new TemplateFeaturesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, resource, position) {
                    _this._results.draw(resource, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.templates.categories;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                category: this._category.get('id'),
                limit: limit,
                offset: results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * SavedTemplatesSectionView
     * 
     * @extends MediaSectionView
     */
    window.SavedTemplatesSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    TemplatesCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'templates',
            children: ['saved']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SavedTemplatesSectionView')
         */
        _string: 'SavedTemplatesSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'TemplateThumb',
            view: 'TemplateThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'saved')
         */
        _type: 'saved',

        /**
         * init
         * 
         * @note   Collection for saved templates does not listen for an empty
         *         event because at the moment, listening for that event is only
         *         useful for clearing out a collection when a user logs in.
         *         Since users need to be logged in to access their templates,
         *         there isn't a use for listening to that event at the moment.
         * @access public
         * @param  jQuery element
         * @param  TemplatesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new TemplatesCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, template, position) {
                    _this._results.draw(template, position);
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @note   I check whether there is only one accessor loaded into the
         *         collection to account for the case of when a user saves a
         *         template _before_ the collection has initially been loaded.
         *         The problem is that if the user saves a template (from a tab
         *         that is not the /app/templates/saved tab), the app will add
         *         the draft accessor to the collection, and then fire off a
         *         /templates call to get all the other ones for that user.
         *         When that happens, the offset value being sent to the server
         *         would normally be 1 (since there is one accessor in the
         *         collection already), but the problem there is that the
         *         associated image record doesn't have an <uploaded> value of
         *         <1> yet (since it's still uploading), which results in
         *         skipping the first template that has it's image record
         *         _truly_ marked as uploaded. Ya, whacky, but this should work
         *         for now.
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.templates.saved;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results === 1 ? (results - 1) : results
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * TemplateStarsSectionView
     * 
     * @extends MediaSectionView
     */
    window.TemplateStarsSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    TemplateStarsCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'templates',
            children: ['stars']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateStarsSectionView')
         */
        _string: 'TemplateStarsSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'TemplateThumb',
            view: 'TemplateStarThumbView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'stars')
         */
        _type: 'stars',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplatesAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new TemplateStarsCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, template, position) {
                    _this._results.draw(template, position);
                },
                'empty': function(event) {
                    _this.find('.joystick').detach();
                    _this.find('.thumb').remove();
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.templates.stars;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'template'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('MediaSectionView', function() {

    /**
     * AllWatermarksSectionView
     * 
     * @extends MediaSectionView
     */
    window.AllWatermarksSectionView = MediaSectionView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    WatermarksCollection (default: null)
         */
        _collection: null,

        /**
         * _signature
         * 
         * @access protected
         * @var    Object
         */
        _signature: {
            repeat: true,
            area: 'watermarks',
            children: ['all']
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AllWatermarksSectionView')
         */
        _string: 'AllWatermarksSectionView',

        /**
         * _thumb
         * 
         * @access protected
         * @var    Object
         */
        _thumb: {
            template: 'WatermarkThumb',
            view: 'WatermarkView'
        },

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'all')
         */
        _type: 'all',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  WatermarksAreaView parent
         * @return void
         */
        init: function(element, parent) {
            this._super(element, parent);
            this._collection = new WatermarksCollection();
            this._setupAuth();
            var _this = this;
            this._collection.on({
                'add': function(event, watermark, position) {
                    if (watermark.get('usable').toInt() === 1) {
                        _this._results.draw(watermark, position);
                    }
                },
                'list': function(event) {
                    _this.smart();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.smart();
                    _this._results.lazy();
                    _this.refresh();
                }
            });
        },

        /**
         * _setupAuth
         * 
         * Adds additional signup/upgrade events since watermarks are behind a
         * pay-wall. No other section has different UI states based on being a
         * guest, free user and upgaded user in the way that AllWatermarks does.
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            this._super();
            var _this = this;
            // User.on('login', function(event, user) {
            //     _this._loaded = false;
            //     _this._collection.empty();
            // });
            User.once({
                'signup': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
        },

        /**
         * _setupResults
         * 
         * @access protected
         * @return void
         */
        _setupResults: function() {
            var $results = this.find('.results');
            if (Stencil.scrollbars() === true) {
                this._scrollable($results);
            } else {
                $results.scroll(function(event) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                });
            }
            this._results = new WatermarkResultsView($results, this, this._thumb);
        },

        /**
         * load
         * 
         * @access public
         * @return void
         */
        load: function() {
            Stencil.queue.remove(this._signature);
            var _this = this,
                results = this.results(),
                limit = Stencil.get('config').defaults.objectsPerPage.watermarks.all;
            if (results !== 0) {
                this.find('div.status.loading').removeClass('hidden');
            }
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                limit: limit,
                offset: results,
                type: 'watermark'
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._detectEnd(limit);
            });
        },

        /**
         * smart
         * 
         * Could not think of a good name for this method. It show/hides the
         * appropriate elements based on whether the collection contains any
         * objects or not.
         * 
         * @access public
         * @return void
         */
        smart: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (
                Account.upgraded() === true
                || User.admin() === true
            ) {
                if (this._collection.usable().length === 0) {
                    this.find('.results').addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                this.find('.results').addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * TemplatesAreaView
     * 
     * @extends AreaView
     */
    window.TemplatesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplatesAreaView')
         */
        _string: 'TemplatesAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'templates')
         */
        _type: 'templates',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupSaved();
            this._setupSearch();
            this._setupStars();
        },

        /**
         * _setupSearch
         * 
         * @access protected
         * @return void
         */
        _setupSearch: function() {
            var $search = this.find('section.search');
            this._children.search = new TemplateSearchSectionView(
                $search,
                this
            );
        },

        /**
         * _setupSaved
         * 
         * @access protected
         * @return void
         */
        _setupSaved: function() {
            var $saved = this.find('section.saved');
            this._children.saved = new SavedTemplatesSectionView($saved, this);
        },

        /**
         * _setupStars
         * 
         * @access protected
         * @return void
         */
        _setupStars: function() {
            var $stars = this.find('section.stars');
            this._children.stars = new TemplateStarsSectionView($stars, this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * WatermarksAreaView
     * 
     * @extends AreaView
     */
    window.WatermarksAreaView = AreaView.extend({

        /**
         * _dropzone
         * 
         * @access protected
         * @var    DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarksAreaView')
         */
        _string: 'WatermarksAreaView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'watermarks')
         */
        _type: 'watermarks',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupAll();
            this._setupDropzone();
        },

        /**
         * _setupAll
         * 
         * @access protected
         * @return void
         */
        _setupAll: function() {
            var $all = this.find('section.all');
            this._children.all = new AllWatermarksSectionView($all, this);
        },

        /**
         * _setupDropzone
         * 
         * @note   Because the complete event does not get fired within the flow
         *         of a mouseup or keyup event, it's important to trigger the
         *         ChangeHistory.track method here, to ensure it's tracked at
         *         the right moment.
         * @access protected
         * @return void
         */
        _setupDropzone: function() {
            var _this = this,
                $dropzone = this.find('.dropzone');
            // this._dropzone = new DropzoneView($dropzone, 'watermark');
            this._dropzone = new WatermarksDropzoneView($dropzone, 'watermark');
            this._dropzone.on({
                'complete': function(event, watermark) {
                    watermark.setDefaultSettings();
                    watermark.addToCanvas(true);
                    App.triggerHandler('changeHistory/track');
                    Track.event('Watermark uploaded');
                    var collection = _this.getChild('all').getCollection();
                    collection.map(watermark._data, false);
                    collection = Stencil.account().collection('watermarks');
                    collection.map(watermark._data, false);
                    Stencil.navigate('/app/logos');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('DropzoneView', function() {

    /**
     * FontsDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.FontsDropzoneView = DropzoneView.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {

                        // Max has been reached
                        var fonts = Stencil.account().collection('fonts').getUploaded(),
                            max = Stencil.get('config').defaults.maxFontUploads;
                        if (fonts.length >= max) {
                            Stencil.set('ignoreMouseDownLayerBlur', true);
                            Stencil.alert('font.import.max');
                            Modals.open()[0].once({
                                'close leave': Stencil.set.proxy(
                                    Stencil,
                                    ['ignoreMouseDownLayerBlur', false]
                                )
                            });
                        }
                        // Good to go
                        else {
                            if (Services.check('fonts') === false) {
                                Stencil.alert('service.fonts.disabled');
                            } else {

                                // Pro user
                                if (
                                    Account.upgraded() === true
                                    || User.admin() === true
                                ) {
                                    var $file = this.find('input[type="file"]');
                                    !this._uploading && $file.trigger('click');
                                }
                                // Upsell
                                else {
                                    Stencil.navigate('/app/upgrade/pro/fonts?clean=1');
                                }
                            }
                        }
                    }
                },
                drop: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        $div.removeClass('hovering');
                        if (event.originalEvent.dataTransfer) {
                            if (event.originalEvent.dataTransfer.files.length) {
                                event.preventDefault();
                                event.stopPropagation();

                                // Max has been reached
                                var fonts = Stencil.account().collection('fonts').getUploaded(),
                                    max = Stencil.get('config').defaults.maxFontUploads;
                                if (fonts.length >= max) {
                                    Stencil.set('ignoreMouseDownLayerBlur', true);
                                    Stencil.alert('font.import.max');
                                    Modals.open()[0].once({
                                        'close leave': Stencil.set.proxy(
                                            Stencil,
                                            ['ignoreMouseDownLayerBlur', false]
                                        )
                                    });
                                }
                                // Good to go
                                else {
                                    if (Services.check('fonts') === false) {
                                        Stencil.alert('service.fonts.disabled');
                                    } else {
                                        // Pro user
                                        if (
                                            Account.upgraded() === true
                                            || User.admin() === true
                                        ) {
                                            var files = event.originalEvent.dataTransfer.files;
                                            !this._uploading && this.receive(
                                                jQuery.makeArray(files)
                                            );
                                        }
                                        // Upsell
                                        else {
                                            Stencil.navigate('/app/upgrade/pro/fonts?clean=1');
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FontsDropzoneView')
         */
        _string: 'FontsDropzoneView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @return void
         */
        init: function(element, type) {
            this._super(element, type);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * HourglassView
     * 
     * @extends View
     */
    window.HourglassView = View.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'HourglassView')
         */
        _string: 'HourglassView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * JoystickView
     * 
     * @events  delete
     *          download
     *          feature
     *          save
     *          select
     *          share
     *          star
     * @extends View
     */
    window.JoystickView = View.extend({

        /**
         * _listeners
         * 
         * @see    https://jsfiddle.net/Lg5QH/1/
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                dragend: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a.overlay': function(event, $anchor) {
                        $anchor.css({
                            backgroundImage: 'none'
                        });
                        App.getStage().getContent().getMessages().addClass('hidden');
                    }
                },
                dragstart: {

                    /**
                     * (anonymous)
                     * 
                     * @note   The defining below of the bypass string in the
                     *         encoded data is because Safari (at least) seemed
                     *         to pass along more information, perhaps for
                     *         security reasons. So I needed a way to tell which
                     *         types[] array position was indeed what I wanted.
                     * @see    http://bit.ly/1O8GfCS
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a.overlay': function(event, $anchor) {
                        var dataTransfer = event.originalEvent.dataTransfer,
                            $particle = $anchor.closest('.thumb, .particle'),
                            accessor = $particle.data('accessor'),
                            type = this._getType(),
                            encoded = JSON.stringify({
                                accessor: accessor.get('key'),
                                locked: $particle.hasClass('locked'),
                                type: type
                            });

                        // Preload of SVG
                        if (false) {
                            Stencil.ajax({
                                cache: true,
                                crossDomain: true,
                                url: accessor.url('svg'),
                                type: 'GET',
                                dataType: 'text'
                            });
                            var image = new Image();
                            image.crossOrigin = 'anonymous';
                            image.src = accessor.url('svg');
                        }

                        // Encoded the data and set it for the transfer
                        encoded = 'bypass' + (encoded);
                        dataTransfer.setData(encoded, '');
                        // $anchor.addClass('dragging');
                        if (type === 'quote') {
                            if (event.originalEvent.dataTransfer.setDragImage) {
                                var image = App.getEditor().getArea('quotes').getDragImage();
                                event.originalEvent.dataTransfer.setDragImage(
                                    image,
                                    (image.width / 2).round(0),
                                    (image.height / 2).round(0)
                                );
                            }
                        } else {
                            $anchor.css({
                                backgroundImage: $particle.css('background-image')
                                // ,
                                // borderRadius: '50%',
                            });
                        }

                        // Update the canvas message
                        App.getStage().getContent().getMessages().addClass('hidden');
                        App.getStage().getContent().getMessage(type).removeClass('hidden');
                    }
                },
                mousedown: {

                    /**
                     * (anonymous)
                     * 
                     * This is useful for clearing out any highlighted text for
                     * when a drag is started. Otherwise, weird cases like this
                     * can happen if the user (likely accidentally) highlighted
                     * parts of the page when they start the drag:
                     * https://i.imgur.com/pLzGLrz.jpg
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a.overlay': clearSelectedText
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    '[lookup="previewAndShare"]': function(event, $anchor) {
                        App.preloadShareModalStaticAssets();
                    },

                    /**
                     * (anonymous)
                     * 
                     * The logic below was intented to combat a bug that was
                     * randomly appearing. It was that every now and then,
                     * dragging an image resulted in the thumb not being visible
                     * in the "dragged" node. See screenshot:
                     * https://i.imgur.com/lIxw6DB.jpg
                     * 
                     * I believe this was happening because for whatever reason,
                     * the cache entry for the thumb was somehow getting
                     * invalidated (could be because I had the console open so
                     * much). So to deal with this, I devised the following
                     * logic that would simply preload the thumb (again) when
                     * the mouse entered the overlay. It worked, but I don't
                     * think it's neccessary, because with the console closed,
                     * I have no been able to reproduce it on dev.
                     * 
                     * UPDATE
                     * So I ran into this with the setDragImage logic above for
                     * quotes. In the case above, I was creating a new Image
                     * object and setting the src to the drag image I wanted to
                     * use. But what was happening was even if the image was in
                     * the browsers cache, it was possible a lookup would be
                     * done, which although it may only take 4ms, would result
                     * in the drag image not being set because the image needs
                     * to be available *immediately*.
                     * 
                     * So to get around this, I preload the drag image in the
                     * QuotesAreaView, and set a reference to it. Then I created
                     * a getter / lookup for that reference, and when setting
                     * the drag image above, I use that reference (since that's
                     * guarenteed not to perform any http request).
                     * 
                     * So if this bug does come up again, one way to deal with 
                     * it could be to create a reference to the image in each
                     * ThumbView, and use that reference as the drag image
                     * (instead of setting the background-image for the
                     * a.overlay node).
                     * 
                     * @see    http://stackoverflow.com/questions/8809876/can-i-get-divs-background-image-url
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a.overlay': function(event, $anchor) {
                        // var $particle = $anchor.closest('.thumb, .particle'),
                        //     url = $particle.css('background-image');
                        // url = url.replace('url(','').replace(')','').replace(/\"/gi, "");
                        // new Image().src = url;
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'JoystickView')
         */
        _string: 'JoystickView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupConfirmDeleteEvent();
            this._setupDownloadEvent();
            this._setupFeatureEvent();
            this._setupSaveEvent();
            this._setupSelectEvent();
            this._setupShareEvent();
            this._setupStarEvent();
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @param  Accessor accessor
         * @return void
         */
        _confirmDelete: function(accessor) {
            var _this = this,
                type = accessor.get('class'),
                question = 'Are you sure you want to delete this ' + (type) +
                    '?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function() {
                    accessor.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _getType
         * 
         * @note   Used by event handles to send type details to <star> and
         *         <feature> methods in some accessors.
         * @note   Not elegant, but works for now.
         * @access protected
         * @return String
         */
        _getType: function() {
            var area = App.getSidebar().getNav().find('.active').attr('area');
            if (area === 'graphics') {
                return 'graphic';
            } else if (area === 'templates') {
                return 'template';
            } else if (area === 'images') {
                return 'image';
            } else if (area === 'quotes') {
                return 'quote';
            }
            return 'background';
        },

        /**
         * _setupConfirmDeleteEvent
         * 
         * @access protected
         * @return void
         */
        _setupConfirmDeleteEvent: function() {
            this.on({
                'confirm/delete': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor');
                    this._confirmDelete(accessor);
                }
            });
        },

        /**
         * _setupDownloadEvent
         * 
         * @access protected
         * @return void
         */
        _setupDownloadEvent: function() {
            this.on({
                'download': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        mime = accessor.get('mime');
                    accessor.download(mime, false, false, true);
                }
            });
        },

        /**
         * _setupFeatureEvent
         * 
         * @access protected
         * @return void
         */
        _setupFeatureEvent: function() {
            this.on({
                'feature': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        type = this._getType();
                    Modals.showApplyCategories(type, accessor);
                }
            });
        },

        /**
         * _setupSaveEvent
         * 
         * @access protected
         * @return void
         */
        _setupSaveEvent: function() {
            this.on({
                'save': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        type = this._getType();
                    accessor[event.type].apply(accessor, [type]);
                }
            });
        },

        /**
         * _setupSelectEvent
         * 
         * @access protected
         * @return void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        type = this._getType(),
                        locked = $particle.hasClass('locked');
                    accessor.select.apply(
                        accessor,
                        [type, 'click', locked, {}]
                    );
                    if ($particle.data('view').showPreloadingSpinner) {
                        $particle.data('view').showPreloadingSpinner();
                    }
                }
            });
        },

        /**
         * _setupShareEvent
         * 
         * @access protected
         * @return void
         */
        _setupShareEvent: function() {
            this.on({
                'share': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        type = this._getType();
                    accessor[event.type].apply(accessor, [type]);
                }
            });
        },

        /**
         * _setupStarEvent
         * 
         * @access protected
         * @return void
         */
        _setupStarEvent: function() {
            this.on({
                'star': function(event, $anchor) {
                    var $particle = $anchor.closest('.thumb, .particle'),
                        accessor = $particle.data('accessor'),
                        type = this._getType();
                    if (Account.max.stars() === true && User.admin() === false) {
                        if (Account.plan('pro') === true) {
                            Stencil.navigate('/app/upgrade/unlimited/stars?clean=1');
                        } else {
                            Stencil.navigate('/app/upgrade/pro/stars?clean=1');
                        }
                    } else {
                        accessor.star.apply(accessor, [type]);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * QuoteRowView
     * 
     * @extends View
     */
    window.QuoteRowView = View.extend({

        /**
         * _accessor
         * 
         * @access protected
         * @var    Accessor (defaut: null)
         */
        _accessor: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteRowView')
         */
        _string: 'QuoteRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  Accessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._accessor = accessor;
            this._super(element);
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see    https://api.jquery.com/remove/
         * @see    https://api.jquery.com/detach/
         * @access public
         * @return void
         */
        remove: function() {
            var $joystick = this.find('.joystick');
            $joystick.detach();
            this._element.remove();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuoteRowView', function() {

    /**
     * QuoteFeatureRowView
     * 
     * @extends QuoteRowView
     */
    window.QuoteFeatureRowView = QuoteRowView.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteFeatureRowView')
         */
        _string: 'QuoteFeatureRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor accessor
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, accessor, category) {
            this._super(element, accessor);
            this._category = category;
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('quote', _this._accessor);
                },
                'unstar': function(event) {
                    _this._accessor.unstar('quote');
                }
            });
            this._accessor.on({
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (_this._category === category) {
                        _this.remove();
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'star': function(event) {
                        _this._element.addClass('star');
                    },
                    'star/ui': function(event) {
                        _this._element.addClass('star');
                    },
                    'unfeature': function(event, category) {
                        if (_this._category === category) {
                            _this.remove();
                            // _this.clean();
                        }
                    },
                    'unstar': function(event) {
                        _this._element.removeClass('star');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuoteRowView', function() {

    /**
     * QuoteResourceRowView
     * 
     * @extends QuoteRowView
     */
    window.QuoteResourceRowView = QuoteRowView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteResourceRowView')
         */
        _string: 'QuoteResourceRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ResourceAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('quote', _this._accessor);
                },
                'unstar': function(event) {
                    _this._accessor.unstar('quote');
                }
            });
            this._accessor.on({
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuoteRowView', function() {

    /**
     * QuoteStarRowView
     * 
     * @extends QuoteRowView
     */
    window.QuoteStarRowView = QuoteRowView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'QuoteStarRowView')
         */
        _string: 'QuoteStarRowView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('quote', _this._accessor);
                },
                'unstar': function(event) {
                    _this._accessor.unstar('quote');
                }
            });
            this._accessor.on({
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this.remove();
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'feature': function(event, category) {
                        _this._element.addClass('feature');
                    },
                    'unfeature': function(event, category) {
                        if (this.featuredInAnyCategory() === false) {
                            _this._element.removeClass('feature');
                        }
                    },
                    'unstar': function(event) {
                        _this.remove();
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ThumbView
     * 
     * @extends View
     */
    window.ThumbView = View.extend({

        /**
         * _accessor
         * 
         * @access protected
         * @var    Accessor (defaut: null)
         */
        _accessor: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ThumbView')
         */
        _string: 'ThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  Accessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._accessor = accessor;
            this._super(element);
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see    https://api.jquery.com/remove/
         * @see    https://api.jquery.com/detach/
         * @access public
         * @return void
         */
        remove: function() {
            var $joystick = this.find('.joystick');
            $joystick.detach();
            this._element.remove();
        },

        /**
         * showPreloadingSpinner
         * 
         * @todo   Include logic that the spinner only shows up if it takes at
         *         least 25ms. If that's the case, show the spinner for at least
         *         125ms (to prevent that flicker-experience).
         * @todo   Fix below note, and test by throttling
         * @note   There is a possible bug here for people with slow internet
         *         connections. Specifically, if they click on a thumbnail, and
         *         wait, but it takes too long, they may click on another. When
         *         that happens, they'll notice two different spinners visible.
         *         When the first one that was clicked finally comes back and
         *         triggers the <refresh> event on the background image drawing,
         *         it'll remove the the spinning class, and spinner element,
         *         from both thumbs. A way around this would be to remove the
         *         previous spinner UI (the class and element), if any, whenever
         *         a thumb is clicked. Don't think it's needed at the moment,
         *         though.
         * @note   This method isn't triggered by clicking on a logo, since
         *         logos don't make use of the Joystick view
         * @access public
         * @return void
         */
        showPreloadingSpinner: function() {

            /**
             * Draw the spinner inside the thumb, and add the class to the thumb
             * so that it can hide children that shouldn't be shown while the
             * associated image-url is being loaded into the canvas.
             */
            var _this = this,
                canvas = Canvases.Preview,
                $spinner = $('<div class="spinner">' +
                    '<div class="icon fa fa-refresh fa-spin"></div>' +
                    '</div>'
                );
            this._element.append($spinner);
            this._element.addClass('spinning');

            /**
             * If the graphics tab is focused, grab the last layer in the array,
             * and wait for it to be drawn before removing the spinner. This is
             * to detect a successful draw, at which point the spinner is
             * removed.
             * 
             * @todo Add in support for watermarks
             */
            if (App.getEditor().getActive()._type === 'graphics') {
                var layer = canvas.getImage().getImageDocument().getLayers(false).slice(
                    -1
                ).pop();
                layer.getDrawing().once({
                    'draw': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
            /**
             * If the backgrounds tab is focused, grab the background image
             * layer, and wait for it to be refreshed before removing the
             * spinner. I wait for a refresh rather than a draw here, since the
             * background image layer is always already drawn.
             */
            else if (App.getEditor().getActive()._type === 'backgrounds') {
                canvas.getBackgroundImageLayer().getDrawing().once({
                    'refresh': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
            /**
             * Otherwise likely images / templates tab
             */
            else {
                canvas.once({
                    'render': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * BackgroundFeatureThumbView
     * 
     * @extends ThumbView
     */
    window.BackgroundFeatureThumbView = ThumbView.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundFeatureThumbView')
         */
        _string: 'BackgroundFeatureThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor|UploadAccessor accessor
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, accessor, category) {
            this._super(element, accessor);
            this._category = category;
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('background', _this._accessor);
                    // _this._accessor.unfeature('background');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('background');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (_this._category === category) {
                        _this.remove();
                        // _this.clean();
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'star': function(event) {
                        _this._element.addClass('star');
                    },
                    'star/ui': function(event) {
                        _this._element.addClass('star');
                    },
                    'unfeature': function(event, category) {
                        if (_this._category === category) {
                            _this.remove();
                            // _this.clean();
                        }
                    },
                    'unstar': function(event) {
                        _this._element.removeClass('star');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * BackgroundResourceThumbView
     * 
     * @extends ThumbView
     */
    window.BackgroundResourceThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundResourceThumbView')
         */
        _string: 'BackgroundResourceThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ResourceAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('background', _this._accessor);
                    // _this._accessor.unfeature('background');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('background');
                }
            });
            this._accessor.on({
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * BackgroundStarThumbView
     * 
     * @extends ThumbView
     */
    window.BackgroundStarThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundStarThumbView')
         */
        _string: 'BackgroundStarThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor|UploadAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('background', _this._accessor);
                    // _this._accessor.unfeature('background');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('background');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this.remove();
                    // _this.clean();
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'feature': function(event, category) {
                        _this._element.addClass('feature');
                    },
                    'unfeature': function(event, category) {
                        if (this.featuredInAnyCategory() === false) {
                            _this._element.removeClass('feature');
                        }
                    },
                    'unstar': function(event) {
                        _this.remove();
                        // _this.clean();
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * BackgroundUploadThumbView
     * 
     * @extends ThumbView
     */
    window.BackgroundUploadThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundUploadThumbView')
         */
        _string: 'BackgroundUploadThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  UploadAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('background', _this._accessor);
                    // _this._accessor.unfeature('background');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('background');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * GraphicFeatureThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicFeatureThumbView = ThumbView.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicFeatureThumbView')
         */
        _string: 'GraphicFeatureThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor|UploadAccessor accessor
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, accessor, category) {
            this._super(element, accessor);
            this._category = category;
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('graphic', _this._accessor);
                    // _this._accessor.unfeature('graphic');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('graphic');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (_this._category === category) {
                        _this.remove();
                        // _this.clean();
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'star': function(event) {
                        _this._element.addClass('star');
                    },
                    'star/ui': function(event) {
                        _this._element.addClass('star');
                    },
                    'unfeature': function(event, category) {
                        if (_this._category === category) {
                            _this.remove();
                            // _this.clean();
                        }
                    },
                    'unstar': function(event) {
                        _this._element.removeClass('star');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * GraphicResourceThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicResourceThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicResourceThumbView')
         */
        _string: 'GraphicResourceThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ResourceAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('graphic', _this._accessor);
                    // _this._accessor.unfeature('graphic');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('graphic');
                }
            });
            this._accessor.on({
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * GraphicStarThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicStarThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicStarThumbView')
         */
        _string: 'GraphicStarThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AssetAccessor|ResourceAccessor|UploadAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('graphic', _this._accessor);
                    // _this._accessor.unfeature('graphic');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('graphic');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this.remove();
                    // _this.clean();
                }
            });
            if (this._accessor.get('class') === 'asset') {
                this._accessor.reference('resource').on({
                    'feature': function(event, category) {
                        _this._element.addClass('feature');
                    },
                    'unfeature': function(event, category) {
                        if (this.featuredInAnyCategory() === false) {
                            _this._element.removeClass('feature');
                        }
                    },
                    'unstar': function(event) {
                        _this.remove();
                        // _this.clean();
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * GraphicUploadThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicUploadThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GraphicUploadThumbView')
         */
        _string: 'GraphicUploadThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  UploadAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('graphic', _this._accessor);
                    // _this._accessor.unfeature('graphic');
                },
                'unstar': function(event) {
                    _this._accessor.unstar('graphic');
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * ImageStarThumbView
     * 
     * @extends ThumbView
     */
    window.ImageStarThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageStarThumbView')
         */
        _string: 'ImageStarThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImageAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unstar': function(event) {
                    _this._accessor.unstar();
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'unstar': function(event) {
                    _this.remove();
                    // _this.clean();
                }
            });
            this._accessor.once({
                'preload': function() {
                    element.css({
                        'background-image': 'url(' + this.url('thumb') + ')'
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * ImageThumbView
     * 
     * @extends ThumbView
     */
    window.ImageThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageThumbView')
         */
        _string: 'ImageThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImageAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unstar': function(event) {
                    _this._accessor.unstar();
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            this._accessor.once({
                'preload': function() {
                    element.css({
                        'background-image': 'url(' + this.url('thumb') + ')'
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * TemplateFeatureThumbView
     * 
     * @extends ThumbView
     */
    window.TemplateFeatureThumbView = ThumbView.extend({

        /**
         * _category
         * 
         * @access protected
         * @var    CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateFeatureThumbView')
         */
        _string: 'TemplateFeatureThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplateAccessor accessor
         * @param  CategoryAccessor category
         * @return void
         */
        init: function(element, accessor, category) {
            this._super(element, accessor);
            this._category = category;
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('template', _this._accessor);
                    // _this._accessor.unfeature();
                },
                'unstar': function(event) {
                    _this._accessor.unstar();
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'star/ui': function(event) {
                    _this._element.addClass('star');
                },
                'unfeature': function(event, category) {
                    if (_this._category === category) {
                        _this.remove();
                        // _this.clean();
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            this._accessor.reference('image').on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                    _this._accessor.removeAll();
                },
                'preload': function() {
                    element.css({
                        'background-image': 'url(' + this.url('thumb') + ')'
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * TemplateStarThumbView
     * 
     * @extends ThumbView
     */
    window.TemplateStarThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateStarThumbView')
         */
        _string: 'TemplateStarThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplateAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('template', _this._accessor);
                    // _this._accessor.unfeature();
                },
                'unstar': function(event) {
                    _this._accessor.unstar();
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this.remove();
                    // _this.clean();
                }
            });
            this._accessor.reference('image').on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                    _this._accessor.removeAll();
                },
                'preload': function() {
                    element.css({
                        'background-image': 'url(' + this.url('thumb') + ')'
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * TemplateThumbView
     * 
     * @extends ThumbView
     */
    window.TemplateThumbView = ThumbView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TemplateThumbView')
         */
        _string: 'TemplateThumbView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  TemplateAccessor accessor
         * @return void
         */
        init: function(element, accessor) {
            this._super(element, accessor);
            var _this = this;
            this.on({
                'unfeature': function(event, category) {
                    Modals.showApplyCategories('template', _this._accessor);
                    // _this._accessor.unfeature();
                },
                'unstar': function(event) {
                    _this._accessor.unstar();
                }
            });
            this._accessor.on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                },
                'feature': function(event, category) {
                    _this._element.addClass('feature');
                },
                'star': function(event) {
                    _this._element.addClass('star');
                    App.getEditor().getActive().pulse();
                },
                'unfeature': function(event, category) {
                    if (this.featuredInAnyCategory() === false) {
                        _this._element.removeClass('feature');
                    }
                },
                'unstar': function(event) {
                    _this._element.removeClass('star');
                }
            });
            this._accessor.reference('image').on({
                'delete': function(event) {
                    _this.remove();
                    // _this.clean();
                    _this._accessor.removeAll();
                },
                'preload': function() {
                    element.css({
                        'background-image': 'url(' + this.url('thumb') + ')'
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * WatermarkView
     * 
     * @extends View
     */
    window.WatermarkView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned on.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input[type="checkbox"]:checked': function(event, $input) {
                        this._watermark.set({
                            'settings.active': 1
                        });
                        this._watermark.save(['settings.active']);
                        this._watermark.addToCanvas(true);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned off.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        this._watermark.set({
                            'settings.active': 0
                        });
                        this._watermark.save(['settings.active']);
                        this._watermark.removeFromCanvas();
                    }
                },
                mouseover: {
                    'label': function(event, $label) {
                        this._watermark.preloadDrawingImage();
                    }
                }
            });
        },

        /**
         * _watermark
         * 
         * @access protected
         * @var    UploadAccessor (defaut: null)
         */
        _watermark: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkView')
         */
        _string: 'WatermarkView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  WatermarkAccessor watermark
         * @return void
         */
        init: function(element, watermark) {
            this._super(element);
            this._watermark = watermark;
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._watermark.on({
                'change/settings.active': function(event, active) {
                    _this.find('[type="checkbox"]').prop(
                        'checked',
                        active.toInt() === 1
                    );
                },
                'delete': function() {
                    _this._element.remove();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access protected
         * @return void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this watermark?',
                // h2 = '<strong>WARNING:</strong> This logo / watermark will ' +
                //     'be removed from any previously saved images. This ' +
                //     'cannot be undone. ',
                // modal = Modals.showConfirmDelete(question, h2);
                modal = Modals.showConfirmDelete(question);
            modal.getElement().addClass('warning');
            modal.on({
                'yes': function() {
                    _this._watermark.delete();
                    this.triggerHandler('leave');
                },
                'no': function() {
                    this.triggerHandler('leave');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('DropzoneView', function() {

    /**
     * WatermarksDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.WatermarksDropzoneView = DropzoneView.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {

                            // Pro user
                            if (
                                Account.upgraded() === true
                                || User.admin() === true
                            ) {
                                var $file = this.find('input[type="file"]');
                                !this._uploading && $file.trigger('click');
                            }
                            // Upsell
                            else {
                                Stencil.navigate('/app/upgrade/pro/logos?clean=1');
                            }
                        }
                    }
                },
                drop: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.prompt': function(event, $div) {
                        $div.removeClass('hovering');
                        if (event.originalEvent.dataTransfer) {
                            if (event.originalEvent.dataTransfer.files.length) {
                                event.preventDefault();
                                event.stopPropagation();
                                if (Services.check('aws') === false) {
                                    Stencil.alert('service.aws');
                                } else {
                                    // Pro user
                                    if (
                                        Account.upgraded() === true
                                        || User.admin() === true
                                    ) {
                                        var files = event.originalEvent.dataTransfer.files;
                                        !this._uploading && this.receive(
                                            jQuery.makeArray(files)
                                        );
                                    }
                                    // Upsell
                                    else {
                                        Stencil.navigate('/app/upgrade/pro/logos?clean=1');
                                    }
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarksDropzoneView')
         */
        _string: 'WatermarksDropzoneView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @return void
         */
        init: function(element, type) {
            this._super(element, type);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * EditorView
     * 
     * @extends View
     */
    window.EditorView = View.extend({

        /**
         * _active
         * 
         * @access protected
         * @var    AreaView (default: null)
         */
        _active: null,

        /**
         * _areas
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _areas: {},

        /**
         * _joystick
         * 
         * @access protected
         * @var    JoystickView (default: null)
         */
        _joystick: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $target
                     * @return void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.showParticle($target);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $target
                     * @return void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.hideParticle($target);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'EditorView')
         */
        _string: 'EditorView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._drawBackgrounds();
            this._drawJoystick();
            this._drawGraphics();
            this._drawImages();
            this._drawQuotes();
            this._drawWatermarks();
            this._drawTemplates();
            // this._setupTooltips();
            // this.find('> div.spinner').addClass('invisible');
        },

        /**
         * _drawBackgrounds
         * 
         * @access protected
         * @return void
         */
        _drawBackgrounds: function() {
            var $backgrounds = Stencil.render('BackgroundsArea', {
                accept: Stencil.get('config').defaults.imageUploadMimeTypes
            });
            this.find('> div.inner > div.wrapper').append($backgrounds);
            this._areas.backgrounds = new BackgroundsAreaView($backgrounds);
        },

        /**
         * _drawGraphics
         * 
         * @access protected
         * @return void
         */
        _drawGraphics: function() {
            var $graphics = Stencil.render('GraphicsArea', {
                accept: Stencil.get('config').defaults.imageUploadMimeTypes
            });
            this.find('> div.inner > div.wrapper').append($graphics);
            this._areas.graphics = new GraphicsAreaView($graphics);
        },

        /**
         * _drawImages
         * 
         * @access protected
         * @return void
         */
        _drawImages: function() {
            var $images = Stencil.render('ImagesArea');
            this.find('> div.inner > div.wrapper').append($images);
            this._areas.images = new ImagesAreaView($images);
        },

        /**
         * _drawJoystick
         * 
         * @access protected
         * @return void
         */
        _drawJoystick: function() {
            var $joystick = Stencil.render('Joystick');
            this.find('> div.inner > div.wrapper').append($joystick);
            this._joystick = new JoystickView($joystick);
        },

        /**
         * _drawQuotes
         * 
         * @access protected
         * @return void
         */
        _drawQuotes: function() {
            var $quotes = Stencil.render('QuotesArea');
            this.find('> div.inner > div.wrapper').append($quotes);
            this._areas.quotes = new QuotesAreaView($quotes);
        },

        /**
         * _drawTemplates
         * 
         * @access protected
         * @return void
         */
        _drawTemplates: function() {
            var $templates = Stencil.render('TemplatesArea');
            this.find('> div.inner > div.wrapper').append($templates);
            this._areas.templates = new TemplatesAreaView($templates);
        },

        /**
         * _drawWatermarks
         * 
         * @access protected
         * @return void
         */
        _drawWatermarks: function() {
            var $watermarks = Stencil.render('WatermarksArea', {
                accept: Stencil.get('config').defaults.imageUploadMimeTypes
            });
            this.find('> div.inner > div.wrapper').append($watermarks);
            this._areas.watermarks = new WatermarksAreaView($watermarks);
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        // _setupTooltips: function() {
        //     this._element.tooltip({
        //         selector: '[tooltip]',
        //         container: this._element,
        //         placement: 'bottom'
        //     });
        // },

        /**
         * getActive
         * 
         * @access public
         * @return AreaView
         */
        getActive: function() {
            return this._active;
        },

        /**
         * getArea
         * 
         * @access public
         * @param  String type
         * @return AreaView
         */
        getArea: function(type) {
            return this._areas[type];
        },

        /**
         * getJoystick
         * 
         * @access public
         * @return JoystickView
         */
        getJoystick: function() {
            return this._joystick;
        },

        /**
         * hideParticle
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        hideParticle: function($element) {
            $element.removeClass('hover');
        },

        /**
         * setActive
         * 
         * @access protected
         * @param  AreaView area
         * @return void
         */
        setActive: function(area) {
            this._active = area;
        },

        /**
         * showParticle
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        showParticle: function($element) {
            $element.siblings().removeClass('hover');
            $element.addClass('hover');
            $element.append(this._joystick.getElement());
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * EscapableView
     * 
     * @extends View
     */
    window.EscapableView = View.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'EscapableView')
         */
        _string: 'EscapableView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FormView', function() {

    /**
     * AppFormView
     * 
     * @extends FormView
     */
    window.AppFormView = FormView.extend({

        /**
         * _fallback
         * 
         * @access protected
         * @var    String (default: 'Something went wrong. Please try again.')
         */
        _fallback: 'Something went wrong. Please try again',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * This detects the client being focused on a submission
                     * element, and pressing either the enter key or space key
                     * to trigger submission.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AppFormView')
         */
        _string: 'AppFormView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').attr('disabled', 'disabled');
                },
                'returned': function(event) {
                    this.find('a.button').removeClass('busy');
                },
                'returned/failed': function(event, response) {
                    this.find('a.button').removeAttr('disabled');
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/shit': function(event, response) {
                    this.find('a.button').removeAttr('disabled');
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/succeeded': function(event, response) {
                    this.find('a.button').addClass('done');
                    (function() {
                        this.find('a.button').removeClass('done');
                        this.find('a.button').removeAttr('disabled');
                    }).delay(2000, this);
                    // }, this._timeout);
                }
            });
        },

        /**
         * setErrorMessage
         * 
         * @access protected
         * @param  String message
         * @return void
         */
        setErrorMessage: function(message) {
            var $callout = this.find('.callout.errors');
            $callout.find('p').html(message);
        },

        /**
         * showError
         * 
         * @access protected
         * @param  Object error
         * @return void
         */
        showError: function(error) {
            if (error.code) {
                Track.event('Form Error', {
                    _code: error.code
                });
            }
            this.setErrorMessage(error.message);
            var $callout = this.find('.callout.errors');
            $callout.removeClass('hidden');
            error.input && error.input.focus();
        },

        /**
         * clearErrors
         * 
         * @access public
         * @return void
         */
        clearErrors: function() {
            this.find('div.callout.errors').addClass('hidden');
        },

        /**
         * disable
         * 
         * @access public
         * @return void
         */
        disable: function() {
            this._super();
            this.find('select').attr('disabled', 'disabled');
            this.find('select').selectpicker('refresh');
        },

        /**
         * enable
         * 
         * @access public
         * @return void
         */
        enable: function() {
            this._super();
            this.find('select').removeAttr('disabled');
            this.find('select').selectpicker('refresh');
        },

        /**
         * getError
         * 
         * @access public
         * @param  Object response
         * @return void
         */
        getError: function(response) {
            var error = response && response.failedRules && response.failedRules[0]
                    && response.failedRules[0].error,
                message = this._fallback,
                input = this._element.focusable(),
                code = false;
            if (error) {
                message = error.message || message;
                code = error.code || false;
                if (error.input) {
                    input = this.find('[name="' + (error.input) + '"]');
                }
            }
            return {
                code: code,
                message: message,
                input: input
            };
        },

        /**
         * setFallback
         * 
         * @access public
         * @param  String message
         * @return void
         */
        setFallback: function(message) {
            this._fallback = message;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppFormView', function() {

    /**
     * CreditCardAppFormView
     * 
     * @see     https://stripe.com/docs/testing
     *          https://stripe.com/docs/stripe.js
     *          https://dashboard.stripe.com/fraud/rules
     * @events  card/submit
     *          card/submitted
     *          card/returned
     *          card/returned/failed
     *          card/returned/succeeded
     * @testing Visa 4242424242424242
     *          Visa 4012888888881881
     *          MasterCard 5555555555554444
     *          MasterCard 5105105105105100
     *          American Express 378282246310005
     *          American Express 371449635398431
     *          Discover 6011111111111117
     *          Discover 6011000990139424
     *          Diners Club 30569309025904
     *          Diners Club 38520000023237
     *          JCB 3530111333300000
     *          JCB 3566002020360505
     * @testing Fails 4000000000000341 (passes checks, but can't be charged)
     *          Fails 4000000000000002
     *          Fails 4000000000000119
     *          Fails 4000000000000101 (cvc)
     *          Fails 4000000000000127 (cvc)
     *          Fails 4000000000000036 (zip code)
     * @extends AppFormView
     */
    window.CreditCardAppFormView = AppFormView.extend({

        /**
         * _acceptable
         * 
         * @access protected
         * @var    Array
         */
        _acceptable: [
            'Visa',
            'MasterCard',
            'American Express',
            'Discover Card',
            'Diners Club',
            'JCB'
        ],

        /**
         * _listeners
         * 
         * Overrides the FormView parent listeners to trigger the card handlers
         * before the 'native' ones
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="card/submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $form
                     * @return void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('card/submit');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CreditCardAppFormView')
         */
        _string: 'CreditCardAppFormView',

        /**
         * _timeout
         * 
         * This is used for both the token posting and form posting.
         * 
         * @access protected
         * @var    Number (default: 1250)
         */
        _timeout: 1250,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);

            // Stripe
            Scripts.load('stripe');
            this._setInputRestrictions();

            // Logic
            this.on({
                'card/submit': function() {
                    var _this = this;
                    App.getBusy().show();
                    Scripts.load('stripe', function() {
                        App.getBusy().hide();
                        _this._getStripeToken();
                    });
                },
                'card/returned': this.enable
            });

            // UI
            this.on({
                'card/submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').attr('disabled', 'disabled');
                },
                'card/returned/failed': function(event, error) {
                    this.find('a.button').removeClass('busy');
                    this.find('a.button').removeAttr('disabled');
                    this.showError(error);
                },
                'card/returned/succeeded': function(event, response) {
                    this.find('input[name="data[token]"]').val(response.id);
                    this.triggerHandler('submit');
                },
                'returned/succeeded': function(event, response) {
                    this.find('[data-stripe]').val('');
                }
            });
        },

        /**
         * _setInputRestrictions
         * 
         * @access protected
         * @return void
         */
        _setInputRestrictions: function() {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $expiry = this.find('[data-stripe="expiry"]');
            $number.payment('formatCardNumber');
            $cvc.payment('formatCardCVC');
            $expiry.payment('formatCardExpiry');
        },

        /**
         * _getStripeToken
         * 
         * @access protected
         * @return void
         */
        _getStripeToken: function() {
            if (this._enabled === true) {
                this.disable();
                this.triggerHandler('card/submitted');
                var $number = this.find('[data-stripe="number"]'),
                    number = $number.val(),
                    $zip = this.find('[data-stripe="zip"]'),
                    zip = $zip.val()
                    $name = this.find('[data-stripe="name"]'),
                    name = $name.val();
                if (this._supportedCreditCard(number) === false) {
                    var message = 'Please enter a ';
                    message += this._acceptable.join(', ');
                    message = message.replace(/, ([^,]+)$/, ' or $1') + ' ';
                    message += 'credit card number';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $number
                        }]]
                    );
                } else if (name === '') {
                    var message = 'Please enter the name as it appears on ' +
                        'the card';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $name
                        }]]
                    );
                } else if (zip === '') {
                    var message = 'Please enter the zip or postal code ' +
                        'associated with this card';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $zip
                        }]]
                    );
                } else {
                    var $expiry = this.find('[data-stripe="expiry"]'),
                        expiry = $expiry.payment('cardExpiryVal'),
                        $cvc = this.find('[data-stripe="cvc"]'),
                        cvc = $cvc.val(),
                        $zip = this.find('[data-stripe="zip"]'),
                        zip = $zip.val(),
                        month = '',
                        year = '';
                    if (!isNaN(expiry.month)) {
                        month = expiry.month;
                    }
                    if (!isNaN(expiry.year)) {
                        year = expiry.year;
                    }
                    var _this = this;
                    Stripe.card.createToken({
                        number: number,
                        cvc: cvc,
                        exp_month: month,
                        exp_year: year,
                        name: name,
                        address_zip: zip
                    }, function(status, response) {
                        _this.triggerHandler.delay(
                            _this._timeout,
                            _this,
                            ['card/returned']
                        );
                        if (status === 200) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['card/returned/succeeded', [response]]
                            );
                        } else {
                            var error = _this.getStripeError(response);
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['card/returned/failed', [error]]
                            );
                        }
                    });
                }
            }
        },

        /**
         * getStripeError
         * 
         * @access protected
         * @param  Object response
         * @return Object
         */
        getStripeError: function(response) {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $zip = this.find('[data-stripe="zip"]'),
                $expiry = this.find('[data-stripe="expiry"]'),
                $input = $number;
            if (response.error.param === 'cvc') {
                $input = $cvc;
            } else if (response.error.param === 'address_zip') {
                $input = $zip;
            } else if (response.error.param === 'exp_month') {
                $input = $expiry;
            } else if (response.error.param === 'exp_year') {
                $input = $expiry;
            }
            return {
                message: response.error.message,
                input: $input
            };
        },

        /**
         * _supportedCreditCard
         * 
         * @access protected
         * @param  String number
         * @return Boolean
         */
        _supportedCreditCard: function(number) {
            var type = Stripe.card.cardType(number);
            if (jQuery.inArray(type, this._acceptable) === -1) {
                return false;
            }
            return true;
        },

        /**
         * setAcceptableCards
         * 
         * @access public
         * @param  Array cards
         * @return void
         */
        setAcceptableCards: function(cards) {
            this._acceptable = cards;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FormView
     * 
     * @events  submit
     *          submitted
     *          returned
     *          returned/shit
     *          returned/failed
     *          returned/succeeded
     * @extends View
     */
    window.FormView = View.extend({

        /**
         * _enabled
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _enabled: true,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $form
                     * @return void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FormView')
         */
        _string: 'FormView',

        /**
         * _timeout
         * 
         * @access protected
         * @var    Number (default: 2500)
         */
        _timeout: 1500,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submit': this._submit,
                'returned': this.enable
            });
        },

        /**
         * _submit
         * 
         * @note   I serialize the form object before disabling to ensure I can
         *         access any disabled inputs
         * @access protected
         * @return void
         */
        _submit: function() {
            if (this._enabled === true) {
                this.triggerHandler('submitted');
                if (this._enabled === true) {
                    var serialized = this._element.serializeObject(),
                        _this = this;
                    this.disable();
                    Stencil.ajax({
                        signature: {file: 'Form', line: 113},
                        url: this._element.attr('action'),
                        type: this._element.attr('method'),
                        data: function(csrf) {
                            serialized.csrf = csrf;
                            return serialized;
                        },
                        error: function(xhr, status, error) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned']
                            );
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned/shit']
                            );
                        },
                        success: function(response) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned']
                            );
                            var listener = 'returned/failed';
                            if (response.success === true) {
                                listener = 'returned/succeeded';
                            }
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                [listener, [response]]
                            );
                        }
                    });
                }
            }
        },

        /**
         * disable
         * 
         * @access public
         * @return void
         */
        disable: function() {
            this._enabled = false;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
        },

        /**
         * enable
         * 
         * @access public
         * @return void
         */
        enable: function() {
            this._enabled = true;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).attr('readonly', false);
        },

        /**
         * setTimeout
         * 
         * @access public
         * @param  Number milliseconds
         * @return void
         */
        setTimeout: function(milliseconds) {
            this._timeout = milliseconds;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CancelAccountModalView
     * 
     * @extends ModalView
     */
    window.CancelAccountModalView = ModalView.extend({

        /**
         * _account
         * 
         * @access protected
         * @var    AccountAccessor|null
         */
        _account: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CancelAccountModalView')
         */
        _string: 'CancelAccountModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AccountAccessor account
         * @return void
         */
        init: function(element, account) {
            this._super(element);
            this._account = account;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                var modal = Modals.get('Admin'),
                    section = modal.getSection('users'),
                    path = section.getPath();
                Stencil.navigate(path);
            });
            this.on({
                'later': function() {
                    var message = '15-second delay. Hungry Hungry Hippoes...';
                    App.getBusy().show(message);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        true,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(15 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                },
                'now': function() {
                    var message = '15-second delay. Hungry Hungry Hippoes...';
                    App.getBusy().show(message);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        false,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(15 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AdminModalView
     * 
     * @extends ModalView
     */
    window.AdminModalView = ModalView.extend({

        /**
         * _sections
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _sections: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AdminModalView')
         */
        _string: 'AdminModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupCoupons();
            this._setupDashboard();
            this._setupImages();
            this._setupPromoSets();
            this._setupUsers();
            this.on({
                'categories/add': function(event) {
                    Stencil.navigate('/app/admin/categories/add');
                },
                'coupons/add': function(event) {
                    Stencil.navigate('/app/admin/coupons/add');
                },
                'promoSets/add': function(event) {
                    Stencil.navigate('/app/admin/promoSets/add');
                },
                'users/search': function(event) {
                    Stencil.navigate('/app/admin/users/search');
                }
            });
        },

        /**
         * _setupCategories
         * 
         * @access protected
         * @return void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._sections.categories = new AdminCategoriesView(
                $categories,
                this
            );
        },

        /**
         * _setupCoupons
         * 
         * @access protected
         * @return void
         */
        _setupCoupons: function() {
            var $coupons = this.find('section.coupons');
            this._sections.coupons = new AdminCouponsView($coupons, this);
        },

        /**
         * _setupDashboard
         * 
         * @todo!  Do not have dashboard.html contain all links; have them be
         *         sent down from the server upon navigation.
         * @access public
         * @return void
         */
        _setupDashboard: function() {
            var $dashboard = this.find('section.dashboard');
            this._sections.dashboard = new AdminDashboardView($dashboard, this);
        },

        /**
         * _setupImages
         * 
         * @access protected
         * @return void
         */
        _setupImages: function() {
            var $images = this.find('section.images');
            this._sections.images = new AdminImagesView($images, this);
        },

        /**
         * _setupPromoSets
         * 
         * @access protected
         * @return void
         */
        _setupPromoSets: function() {
            var $promoSets = this.find('section.promoSets');
            this._sections.promoSets = new AdminPromoSetsView($promoSets, this);
        },

        /**
         * _setupUsers
         * 
         * @access protected
         * @return void
         */
        _setupUsers: function() {
            var $users = this.find('section.users');
            this._sections.users = new AdminUsersView($users, this);
        },

        /**
         * getSection
         * 
         * @access public
         * @param  String section
         * @return SectionView
         */
        getSection: function(section) {
            return this._sections[section];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AlertModalView
     * 
     * @extends ModalView
     */
    window.AlertModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AlertModalView')
         */
        _string: 'AlertModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  Object settings
         * @return void
         */
        init: function(element, settings) {
            this._super(element);
            this._settings = settings;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        },

        /**
         * getSettings
         * 
         * @access public
         * @return Object
         */
        getSettings: function() {
            return this._settings;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AuthModalView
     * 
     * @extends ModalView
     */
    window.AuthModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access protected
         * @var    false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AuthModalView')
         */
        _string: 'AuthModalView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  false|String redirect
         * @return void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
        },

        /**
         * _flow
         * 
         * Manages the flow after a user is authenticated (either via a login or
         * signup redemption modal).
         * 
         * Worth noting: throughout auth flows (including in Promo.js and
         * Checkout.js), I always trigger the modal's leave-event, rather than
         * close, because it ensures that the user is sent back to the
         * location-path they were on before.
         * 
         * The exception to this is below: when a redirect parameter is
         * available, I simply close the modal (by triggering it's close-event).
         * This prevents an extra navigation event from happening, which is
         * useful since it prevents an unnecessary navigational-record, and
         * if the user landed directly in the app (eg. getstencil.com/checkout,
         * which redirects to login / signup before going on to the Checkout
         * modal), it prevents loading /app until _after_ they have been
         * authenticated and upgraded. Preventing /app from loading is
         * desirable, since that fires off a request for featured images, which
         * would result in using a bunch of bandwidth (and memory) when it is
         * not yet needed.
         * 
         * @access public
         * @return void
         */
        _flow: function() {
            if (this._type === 'curtain') {
                if (this._redirect === false) {
                    this._element.addClass('transition');
                    (function() {
                        App.getElement().removeClass('curtain');
                        this.triggerHandler('leave');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        }
                    // }).delay(1800, this);
                    }).delay(0, this);
                } else {
                    // this.triggerHandler('leave');
                    this.triggerHandler('close');
                    var path = this._redirect;
                    // path += '?curtain';
                    Stencil.navigate(path);
                }
            } else {
                // this.triggerHandler('leave');
                if (this._redirect !== false) {
                    this.triggerHandler('close');
                    Stencil.navigate(this._redirect);
                } else {
                    this.triggerHandler('leave');
                    if (this._type === 'save') {
                        Footer.triggerHandler('save');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/onboard?clean=1');
                        }
                    } else if (this._type === 'checkout') {
                        Stencil.navigate('/app/checkout/unlimited');
                    } else if (this._type === 'upgrade') {
                        // Stencil.navigate('/app/checkout/unlimited');
                        Stencil.navigate('/app/plans');
                    } else {
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        } else {
                            Stencil.get('user').showLegacyWelcome();
                        }
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * BrowserModalView
     * 
     * @extends ModalView
     */
    window.BrowserModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BrowserModalView')
         */
        _string: 'BrowserModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * BusyModalView
     * 
     * @extends ModalView
     */
    window.BusyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BusyModalView')
         */
        _string: 'BusyModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * show
         * 
         * @access public
         * @param  undefined|String copy
         * @param  undefined|String exception
         * @return void
         */
        show: function(copy, exception) {
            if (copy === undefined) {
                this.find('div.copy').html('');
            } else {
                this.find('div.copy').html(copy);
            }
            if (exception === undefined) {
                this.find('div.exception').html('');
            } else {
                this.find('div.exception').html(exception);
            }
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CacheRefreshModalView
     * 
     * @extends ModalView
     */
    window.CacheRefreshModalView = ModalView.extend({

        /**
         * _fallback
         * 
         * @access protected
         * @var    String (default: '/app/admin/dashboard')
         */
        // _fallback: '/app/admin/dashboard',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CacheRefreshModalView')
         */
        _string: 'CacheRefreshModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupForm();
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                Stencil.navigate('/app/admin/dashboard');
            });
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on('returned/succeeded', function(event, response) {
                this.find('input').first().focus();
                this.find('input').first().select();
                StencilBooter.log(response.data.object);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddCategoryModalView
     * 
     * @extends ModalView
     */
    window.AddCategoryModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access protected
         * @var    SettingsModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AddCategoryModalView')
         */
        _string: 'AddCategoryModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AdminModalView adminModal
         * @return void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                Stencil.navigate('/app/admin/categories');
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupTooltips();
        },

        /**
         * _setupDropdowns
         * 
         * @access protected
         * @return void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker({
                dropupAuto: false
            });
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on('submitted', function() {
                _this._adminModal.pause();
                _this.pause();
            });
            this._form.on('returned', function() {
                _this._adminModal.unpause();
                _this.unpause();
            });
            this._form.on('returned/succeeded', function(event, response) {
                Track.event('Category added');
                var collection = _this._adminModal.getSection('categories')._collection;
                collection.map(response.data.object, false);
                Stencil.navigate('/app/admin/categories');
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ApplyCategoriesModalView
     * 
     * @extends ModalView
     */
    window.ApplyCategoriesModalView = ModalView.extend({

        /**
         * _accessor
         * 
         * @access protected
         * @var    Accessor (default: null)
         */
        _accessor: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ApplyCategoriesModalView')
         */
        _string: 'ApplyCategoriesModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  Accessor accessor
         * @return void
         */
        init: function(element, type, accessor) {
            this._super(element);
            this._type = type;
            this._accessor = accessor;
            this._setupCheckboxes();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.closeUponEscapeKey();
        },

        /**
         * _setupCheckboxes
         * 
         * @access protected
         * @return void
         */
        _setupCheckboxes: function() {
            var accessor = this._accessor,
                $checkboxes = this.find('input[type="checkbox"]');
            $checkboxes.on({
                'change': function(event) {
                    var key = $(this).attr('id'),
                        category = Stencil.getAccessor(key),
                        checked = $(this).is(':checked');
                    if (checked === true) {
                        if (accessor.get('class') === 'resource') {
                            Stencil.once({
                                'resource/feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        } else {
                            accessor.once({
                                'feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                        App.getBusy().show('Just a second Adam');
                        accessor.feature(category);
                    } else {
                        accessor.unfeature(category);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CheckoutModalView
     * 
     * @todo    Add in a tooltip/question-mark icon for when a coupon is added,
     *          but the coupon does not apply to both intervals (monthly and
     *          annually). Something so that when they toggle away, they get
     *          messaging informing them why the coupon they might be expecting
     *          isn't showing up.
     * @extends ModalView
     */
    window.CheckoutModalView = ModalView.extend({

        /**
         * _coupon
         * 
         * @access protected
         * @var    CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _events
         * 
         * @access protected
         * @var    Object
         */
        _events: {

            /**
             * detect
             * 
             * @access private
             * @param  jQuery event
             * @param  jQuery $input
             * @return void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access protected
         * @var    CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _interval
         * 
         * @access protected
         * @var    String (default: null)
         */
        _interval: 'monthly',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                },
                click: {
                    '.toggler:not([disabled])': function(event, $toggler) {
                        event.preventDefault();
                        if ($toggler.hasClass('monthly')) {
                            Track.event('Checkout interval switch', {
                                _interval: 'annually'
                            });
                            this.interval('annually');
                        } else {
                            Track.event('Checkout interval switch', {
                                _interval: 'monthly'
                            });
                            this.interval('monthly');
                        }
                    }
                }
            });
        },

        /**
         * _plan
         * 
         * @access protected
         * @var    String (default: null)
         */
        _plan: null,

        /**
         * _promotions
         * 
         * @access protected
         * @var    Array
         */
        _promotions: {
            monthly: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                }
            },
            annually: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                },
                auto: {
                    icon: 'fa-calendar',
                    copy: 'Yearly Discount ([rate]% off)'
                }
            }
        },

        /**
         * _rates
         * 
         * @access protected
         * @var    Object
         */
        _rates: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CheckoutModalView')
         */
        _string: 'CheckoutModalView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String plan
         * @param  String type
         * @return void
         */
        init: function(element, plan, type) {
            this._super(element);
            this._type = type;

            // Get the rates
            var rates = Account.rates.raw();
            this._rates = {
                pro: {
                    monthly: {
                        account: rates.monthly.pro,
                        current: rates.monthly.pro
                    },
                    annually: {
                        account: rates.annually.pro,
                        current: rates.annually.pro
                    }
                },
                unlimited: {
                    monthly: {
                        account: rates.monthly.unlimited,
                        current: rates.monthly.unlimited
                    },
                    annually: {
                        account: rates.annually.unlimited,
                        current: rates.annually.unlimited
                    }
                }
            };

            // Plan + create card form
            this._plan = plan;
            this._form = new CreditCardAppFormView(this.find('form'));
            this._form.setTimeout(0);
            this._form.setAcceptableCards([
                'Visa',
                'MasterCard',
                'American Express'
            ]);

            // Pausing/unpausing
            this._form.on({
                'card/submitted': this.pause.proxy(this),
                'card/returned': this.unpause.proxy(this),
                'submitted': this.pause.proxy(this),
                'returned': this.unpause.proxy(this),
                'coupon/remove': this.removeCoupon.proxy(this)
            });

            // Success
            var _this = this;
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    if (response.error && response.error.code) {
                        Track.event('Checkout failed', {
                            _errorCode: response.error.code
                        });
                    }
                    this.find('a.button').removeAttr('disabled');
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    var stripe = response.data.checkout.stripe;
                    User.upgrade(stripe);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });

            // Calculate yearly discount rate
            var rate = (1 - (this._rates[this._plan].annually.account /
                (this._rates[this._plan].monthly.account * 12)
            )) * 100;
            this._promotions.annually.auto.copy = 'Yearly Discount (' +
                Math.round(rate) + '% off)';

            // Tooltips
            this._setupTooltips();

            // Let's do this
            this.interval('annually');

            // Clean up (because of how extend.js works, need to clear vars)
            this.removeCoupon();
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * getPlan
         * 
         * @access public
         * @return String
         */
        getPlan: function() {
            return this._plan;
        },

        /**
         * getType
         * 
         * @access public
         * @return null|String
         */
        getType: function() {
            return this._type;
        },

        /**
         * interval
         * 
         * @access public
         * @param  String interval
         * @return void
         */
        interval: function(interval) {
            var $interval = this.find('input[name="data[interval]"]'),
                $coupon = this.find('input[name="data[coupon]"]');
            $interval.val(interval);
            $coupon.val('');
            this.find('.toggler').removeClass('monthly');
            this.find('.toggler').removeClass('annually');
            this.find('.toggler').addClass(interval);
            this._interval = interval;
            if (this._coupon) {
                if (this._coupon.get('interval') === 'both') {
                    $coupon.val(this._coupon.get('code'));
                } else {
                    if (this._coupon.get('interval') === interval) {
                        $coupon.val(this._coupon.get('code'));
                    }
                }
            }
            this.refresh();
        },

        /**
         * pause
         * 
         * @access public
         * @return void
         */
        pause: function() {
            this._super();
            this.find('div.toggler').disabled(true);
            this.find('section.actions a').disabled(true);
            this.find('section.actions').addClass('invisible');
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            this.update.button.call(this);
            this.update.explanation.call(this);
            this.update.promotions.call(this);
            this.update.rate.after.call(this);
            this.update.rate.before.call(this);
        },

        /**
         * removeCoupon
         * 
         * @access public
         * @return void
         */
        removeCoupon: function() {
            var $coupon = this.find('input[name="data[coupon]"]');
            $coupon.val('');
            this.find('aside section.actions .add').removeClass('hidden');
            this.find('aside section.actions .remove').addClass('hidden');
            this._coupon = null;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            this._rates[this._plan].monthly.current = this._rates[this._plan].monthly.account;
            this._rates[this._plan].annually.current = this._rates[this._plan].annually.account;
            this.refresh();
        },

        /**
         * setCoupon
         * 
         * @access public
         * @param  CouponAccessor coupon
         * @return void
         */
        setCoupon: function(coupon) {

            // UI
            // this.find('[name="data[coupon]"]').val(coupon.get('key'));
            this.find('aside section.actions .add').addClass('hidden');
            this.find('aside section.actions .remove').removeClass('hidden');

            // Data
            this._coupon = coupon;
            this.find('input[name="data[coupon]"]').val(coupon.get('code'));

            // Interval
            if (this._coupon.get('interval') !== 'both') {
                this.interval(this._coupon.get('interval'));
            }

            // Trial
            var promotion;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            if (this._coupon.get('trial').toInt() !== 0) {
                var days = this._coupon.get('trial');
                promotion = {
                    icon: 'fa-clock-o',
                    copy: (days) + ' Day Free Trial Applied',
                    tooltip: 'You will not be charged until your trial expires'
                };
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.trial = promotion;
                    this._promotions.annually.trial = promotion;
                } else {
                    this._promotions[this._coupon.get('interval')].trial = promotion;
                }
            }

            // Discount
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            if (
                this._coupon.get('amount').toInt() !== 0
                || this._coupon.get('percentage').toInt() !== 0
            ) {
                // Cleanup
                promotion = {};

                // Amount
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                ' Discount Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }
                // Percentage
                else {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: (this._coupon.get('percentage')) +'% Discount ' +
                                'Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }

                // Let's do this
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.discount = jQuery.extend({}, promotion);
                    this._promotions.monthly.discount.copy = this._promotions.monthly.discount.copy.replace(
                        '[interval]', 'month'
                    );
                    this._promotions.annually.discount = jQuery.extend({}, promotion);
                    this._promotions.annually.discount.copy = this._promotions.annually.discount.copy.replace(
                        '[interval]', 'year'
                    );
                } else {
                    var interval = this._coupon.get('interval');
                    this._promotions[interval].discount = jQuery.extend({}, promotion);
                    this._promotions[interval].discount.copy = this._promotions[interval].discount.copy.replace(
                        '[interval]',
                        (interval === 'monthly' ? 'month' : 'year')
                    );
                }

                // Discount data
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    }
                } else if (this._coupon.get('percentage').toInt() !== 0) {
                    var rate = 1 - (this._coupon.get('percentage').toInt() / 100);
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    }
                }
            }


            // Refresh UI
            this.refresh();
        },

        /**
         * unpause
         * 
         * @access public
         * @return void
         */
        unpause: function() {
            this._super();
            this.find('div.toggler').disabled(false);
            this.find('section.actions a').disabled(false);
            this.find('section.actions').removeClass('invisible');
        },

        /**
         * update
         * 
         * @access public
         * @var    Object
         */
        update: {

            /**
             * button
             * 
             * @access public
             * @return void
             */
            button: function() {
                var copy = 'Upgrade to PRO';
                if (this._plan === 'unlimited') {
                    copy = 'Upgrade to UNLIMITED';
                }
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        copy = 'Start free trial';
                    }
                }
                this.find('a.button .copy').text(copy);
            },

            /**
             * explanation
             * 
             * @access public
             * @return void
             */
            explanation: function() {

                /**
                 * Amount
                 * 
                 */

                // Charge amount + interval
                var plan = this._plan,
                    amount = this._rates[this._plan][this._interval].current,
                    explanation = 'You\'ll be charged [$' +
                        (amount.centsToDollars(true)) + '] ';
                if (this._interval === 'monthly') {
                    explanation += '[/mo]';
                } else if (this._interval === 'annually') {
                    explanation += '[/yr]';
                }

                /**
                 * Conditions
                 * 
                 */
                if (this._coupon && this._coupon.get('key')) {
                    if (
                        this._coupon.get('frequency') === 'limited'
                        && (
                            this._coupon.get('interval') === 'both' ||
                            this._coupon.get('interval') === this._interval
                        )
                    ) {
                        var shorter = this._interval === 'monthly'
                                ? 'mo'
                                : 'yr',
                            longer = shorter === 'mo' ? 'month' : 'year';
                        if (this._coupon.get('duration').toInt() === 1) {
                            explanation += ' ';
                            explanation += '(for the 1st ' + (longer) + '; ' +
                                '$X /' + (shorter) + ' after that)';
                        } else {
                            explanation += ' ';
                            explanation += '(for the first ' +
                                (this._coupon.get('duration')) + ' ' + (longer) +
                                's; $X /' + (shorter) + ' after that)';
                        }

                        // Amount
                        explanation = explanation.replace(
                            '$X',
                            '$'  + (this._rates[this._plan][this._interval].account.centsToDollars(true))
                        );
                    }
                }

                /**
                 * Trial
                 * 
                 */

                // Trial
                var when;
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        when = moment().add(this._coupon.get('trial'), 'days').format(
                            'MMMM Do, YYYY'
                        );
                        explanation += ' when your trial ends on [' + (when) + ']';
                    }
                }

                // Trailing period
                explanation += '[.]';

                /**
                 * Formatting
                 * 
                 */

                // Replacements
                explanation = explanation.replace(/\[/g, '<strong>');
                explanation = explanation.replace(/\]/g, '</strong>');

                /**
                 * DOM Update
                 * 
                 */

                // DOM
                this.find('div.explanation').html(explanation);
            },

            /**
             * promotions
             * 
             * @access public
             * @return void
             */
            promotions: function() {
                var _this = this;
                this._element.find('section.promotions').empty();
                jQuery.each(this._promotions[this._interval],
                    function(index, promotion) {
                        var $promotion = Stencil.render('CheckoutPromotion', {
                            icon: promotion.icon,
                            copy: promotion.copy,
                            tooltip: promotion.tooltip || false
                        });
                        _this._element.find('section.promotions').append(
                            $promotion
                        );
                    }
                );
            },

            /**
             * rate
             * 
             * @access public
             * @var    Object
             */
            rate: {

                /**
                 * after
                 * 
                 * @access public
                 * @return void
                 */
                after: function() {
                    var $before = this.find('section.pricing div.after'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (interval === 'monthly') {
                        breakdown = this._rates[this._plan].monthly.current;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    } else {
                        breakdown = Math.round(this._rates[this._plan].annually.current / 12);
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                },

                /**
                 * before
                 * 
                 * @note   This should always show pricing relative to monthly
                 *         rates
                 * @access public
                 * @return void
                 */
                before: function() {
                    var plan = this._plan,
                        $before = this.find('section.pricing div.before'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (
                        interval === 'monthly'
                        && this._rates[this._plan].monthly.account === this._rates[this._plan].monthly.current
                    ) {
                        $dollar.text('');
                        $cents.text('');
                        $interval.text('');
                    } else {
                        breakdown = this._rates[this._plan].monthly.account;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ChromeExtensionInstalledModalView
     * 
     * @extends ModalView
     */
    window.ChromeExtensionInstalledModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ChromeExtensionInstalledModalView')
         */
        _string: 'ChromeExtensionInstalledModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ConfirmModalView', function() {

    /**
     * ClearCanvasConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ConfirmModalView
     */
    window.ClearCanvasConfirmModalView = ConfirmModalView.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {
                    'input[type="checkbox"]:checked': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '1'
                        );
                    },
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '0'
                        );
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ClearCanvasConfirmModalView')
         */
        _string: 'ClearCanvasConfirmModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * clearWatermarks
         * 
         * Returns whether any drawn Watermark layers should be cleared from the
         * canvas.
         * 
         * @access public
         * @return Boolean
         */
        clearWatermarks: function() {
            var key = 'canvasClearWatermarks';
            return Stencil.account().userAccount() !== undefined
                && Stencil.account().userAccount().setting(key).toInt() === 1;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ModalView
     */
    window.ConfirmModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConfirmModalView')
         */
        _string: 'ConfirmModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
            this.closeUponEscapeKey();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ConnectionsModalView
     * 
     * @extends ModalView
     */
    window.ConnectionsModalView = ModalView.extend({

        /**
         * _$scrollable
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$scrollable: null,

        /**
         * _collection
         * 
         * @access protected
         * @var    Collection (default: null)
         */
        _collection: null,

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ConnectionsModalView')
         */
        _string: 'ConnectionsModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String network
         * @return void
         */
        init: function(element, network) {
            this._super(element);
            this._collection = Stencil.account().collection('connections');
            var _this = this;
            this._collection.on({
                'remove': function(event) {
                    _this.refresh();
                }
            });
            this._network = network;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                Stencil.navigate('/app/settings/social');
            });
            this._drawConnections();
            if (Stencil.scrollbars() === true) {
                this._setupScrollbars();
            }
        },

        /**
         * _drawConnection
         * 
         * @access protected
         * @param  ConnectionAccessor connection
         * @param  Number position
         * @return void
         */
        _drawConnection: function(connection, position) {
            var $list = this.find('div.list');
                $connection = Stencil.render('ConnectionRow', {
                    connection: connection
                });
            if (position === 0) {
                $list.prepend($connection);
            } else {
                $list.append($connection);
            }
            new ConnectionRowView($connection, connection);
        },

        /**
         * _drawConnections
         * 
         * @access protected
         * @return void
         */
        _drawConnections: function() {
            var _this = this,
                connections = this._collection.network(this._network);
            jQuery.each(connections, function(index, connection) {
                _this._drawConnection(connection, index);
            });
        },

        /**
         * _scrollable
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        _scrollable: function($element) {
            this._$scrollable = $element;
            this._$scrollable.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            // var resize = function() {
            //     $element.data('jsp').reinitialise();
            // };
            // $(window).resize(resize);
            // this.on('destroy', function() {
            //     $(window).unbind('resize', resize);
            // });
        },

        /**
         * _setupScrollbars
         * 
         * @access protected
         * @return void
         */
        _setupScrollbars: function() {
            var $list = this.find('div.list');
            this._scrollable($list);
        },

        /**
         * refresh
         *
         * @access public
         * @return void
         */
        refresh: function() {
            if (Stencil.scrollbars() === true) {
                this._$scrollable.data('jsp').reinitialise();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CookiesModalView
     * 
     * @extends ModalView
     */
    window.CookiesModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CookiesModalView')
         */
        _string: 'CookiesModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * CountdownModalView
     * 
     * @events  open/facebook/share
     * @extends StickyModalView
     */
    window.CountdownModalView = StickyModalView.extend({

        /**
         * _intervals
         * 
         * Keeps track of tweet/follow windows to prevent a bug whereby clicking
         * the tweet/follow link multiple times result in multiple intervals*
         * being created, which results in multiple callbacks firing (which,
         * resulted in 3, 6, 9, 12+ images being added as bonus to the user).
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _intervals: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CountdownModalView')
         */
        _string: 'CountdownModalView',

        /**
         * init
         * 
         * Width is set explicitly below when no <aside> tag can be found
         * because of issues with detecting the width of the modal. The modal
         * width can't be set since it's variable. But when that's the case, the
         * position method in the parent can't tell how wide the content is
         * _right_ after it's inserted into the DOM. Therefore I need to set it
         * explicitly.
         * 
         * @access public
         * @param  jQuery element
         * @param  String direction
         * @param  jQuery $relative
         * @param  jQuery $highlight
         * @return void
         */
        init: function(element, direction, $relative, $highlight) {
            if (element.find('aside').length === 0) {
                element.find('.content').first().css({
                    width: 335
                });
            }
            this._super(element, direction, $relative, $highlight);
            Scripts.load('facebook');
            this.on({
                'open/facebook/share': this._showFacebookShare,
                'open/tweet': this._showTweet,
                'open/follow': this._showFollow
            });
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
            this.closeUponEscapeKey();
        },

        /**
         * _getFacebookShareObject
         * 
         * @note   Specifying source attribute below shows slimmer preview:
         *         https://i.imgur.com/Ujfytbm.png
         * @see    http://stackoverflow.com/questions/20798314/using-facebooks-api-to-post-a-video-using-the-feed-dialog-fails
         * @access protected
         * @return Object
         */
        _getFacebookShareObject: function() {
            var share = Stencil.get('config').defaults.shares['countdown.facebook'];
            return {
                display: 'popup',
                method: 'feed',
                name: share.title,
                description: share.description,
                link: share.url,
                picture: share.picture
            };
        },

        /**
         * _getTweetUrl
         * 
         * @access protected
         * @return String
         */
        _getTweetUrl: function() {
            var share = Stencil.get('config').defaults.shares['countdown.twitter'],
                url = share.url,
                text = encodeURIComponent(share.message);
            return 'https://twitter.com/intent/tweet' +
                '?url=' + (url) +
                '&via=' + (share.via) +
                '&text=' + (text);
        },

        /**
         * _getTwitterFollowUrl
         * 
         * @access protected
         * @return String
         */
        _getTwitterFollowUrl: function() {
            return 'https://twitter.com/intent/follow?screen_name=getstencil';
        },

        /**
         * _listenForWindowClose
         * 
         * @note   Chrome/Safari handle parent existence checks different
                   Chrome has it set to null; Safari has it set to undefined
         * @access protected
         * @param  String type
         * @param  Object win
         * @param  Function callback
         * @return void
         */
        _listenForWindowClose: function (type, win, callback) {
            if (this._intervals[type] !== undefined) {
                jQuery.intervalPool.clear(this._intervals[type]);
                delete this._intervals[type];
            }
            var check = function() {
                // var parent = win.parent;
                // var parent = win.opener;
                if (win.closed === true) {
                // if (parent === null || parent === undefined) {
                    jQuery.intervalPool.clear(this._intervals[type]);
                    delete this._intervals[type];
                    callback();
                }
            };
            this._intervals[type] = check.interval(500, this);
        },

        /**
         * _showFacebookShare
         * 
         * @access protected
         * @return void
         */
        _showFacebookShare: function() {
            if (Scripts.loaded('facebook') === false) {
                App.waitFor('facebook');
            } else {
                var _this = this;
                FB.ui(
                    this._getFacebookShareObject(),
                    function(response) {
                        if (response && response.post_id) {
                            _this._successfulShare();
                        }
                    }
                );
            }
        },

        /**
         * _showFollow
         * 
         * @access protected
         * @return void
         */
        _showFollow: function() {
            var win = window.open(
                this._getTwitterFollowUrl(),
                'Follow',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'follow',
                win,
                this._successfulFollow.proxy(this)
            );
        },

        /**
         * _showTweet
         * 
         * @access protected
         * @return void
         */
        _showTweet: function() {
            var win = window.open(
                this._getTweetUrl(),
                'Tweet',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'tweet',
                win,
                this._successfulTweet.proxy(this)
            );
        },

        /**
         * _successfulFollow
         * 
         * @access protected
         * @param  Object obj
         * @return void
         */
        _successfulFollow: function(obj) {
            var account = Stencil.account();
            account.set({
                followBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['followBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulTweet
         * 
         * @access protected
         * @param  Object obj
         * @return void
         */
        _successfulTweet: function(obj) {
            var account = Stencil.account();
            account.set({
                tweetBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['tweetBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulShare
         * 
         * @access protected
         * @return void
         */
        _successfulShare: function() {
            var account = Stencil.account();
            account.set({
                shareBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['shareBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddCouponModalView
     * 
     * @extends ModalView
     */
    window.AddCouponModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access protected
         * @var    SettingsModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AddCouponModalView')
         */
        _string: 'AddCouponModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AdminModalView adminModal
         * @return void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                Stencil.navigate('/app/admin/coupons');
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupDatetimePicker();
            this._setupTooltips();
        },

        /**
         * _format
         * 
         * @access protected
         * @return void
         */
        _format: function() {

            // Format code
            this.find('[name="data[code]"]').val(
                this.find('[name="data[code]"]').val().toUpperCase()
            );

            // Format expiry
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );

            // Format discount
            var $discount = this.find('#discount'),
                discount = $discount.val(),
                $amount = this.find('[name="data[amount]"]'),
                $percentage = this.find('[name="data[percentage]"]');
            if (discount.indexOf('$') !== -1) {
                discount = discount.replace('$', '');
                discount = discount.toFloat() * 100;
                $amount.val(discount);
            } else if (discount.indexOf('%') !== -1) {
                discount = discount.replace('%', '').toFloat();
                $percentage.val(discount);
            }

            // Format duration
            var $frequency = this.find('[name="data[frequency]"]'),
                $duration = this.find('#duration');
            if ($frequency.val() === 'limited') {
                this.find('[name="data[duration]"]').val(
                    $duration.val()
                );
            }
        },

        /**
         * _setupDatetimePicker
         * 
         * @access protected
         * @return void
         */
        _setupDatetimePicker: function() {
            var current = new Date();
            current.setDate(current.getDate());
            this.find('#expiry').datetimepicker({
                // debug: true,
                format: 'MM/DD/YYYY h:mm A',
                minDate: current,
                // showTodayButton: true,
                showClose: true,
                showClear: true,
                icons: {
                    time: 'fa fa-clock-o',
                    date: 'fa fa-calendar',
                    up: 'fa fa-chevron-up',
                    down: 'fa fa-chevron-down',
                    previous: 'fa fa-chevron-left',
                    next: 'fa fa-chevron-right',
                    today: 'fa fa-calendar-check-o',
                    clear: 'fa fa-trash-o',
                    close: 'fa fa-close'
                }
            });
            this.find('#expiry').val('');
        },

        /**
         * _setupDropdowns
         * 
         * @access protected
         * @return void
         */
        _setupDropdowns: function() {
            var _this = this;
            this.find('select').selectpicker({
                dropupAuto: false
            });
            this.find('select[name="data[frequency]"]').change(
                function(event) {
                    var val = $(this).val(),
                        $duration = _this.find('#duration'),
                        $field = $duration.closest('div.field');
                    $field.addClass('hidden');
                    if (val === 'limited') {
                        $field.removeClass('hidden');
                    }
                }
            );
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on('submitted', this._format.proxy(this));
            this._form.on('submitted', function() {
                _this._adminModal.pause();
                _this.pause();
            });
            this._form.on('returned', function() {
                _this._adminModal.unpause();
                _this.unpause();
            });
            this._form.on('returned/succeeded', function(event, response) {
                Track.event('Coupon added');
                var collection = _this._adminModal.getSection('coupons')._collection;
                collection.map(response.data.object, false);
                Stencil.navigate('/app/admin/coupons');
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ApplyCouponModalView
     * 
     * @extends ModalView
     */
    window.ApplyCouponModalView = ModalView.extend({

        /**
         * _checkoutModal
         * 
         * @access protected
         * @var    CheckoutModalView (default: null)
         */
        _checkoutModal: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ApplyCouponModalView')
         */
        _string: 'ApplyCouponModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  CheckoutModalView checkoutModal
         * @return void
         */
        init: function(element, checkoutModal) {
            this._super(element);
            this._checkoutModal = checkoutModal;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                var path = '/app/checkout/' + (checkoutModal.getPlan());
                if (checkoutModal.getType() === 'curtain') {
                    path += '?curtain';
                }
                Stencil.navigate(path);
            });
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on('submitted', function() {
                _this._checkoutModal.pause();
                _this.pause();
            });
            this._form.on('returned', function() {
                _this._checkoutModal.unpause();
                _this.unpause();
            });
            this._form.on('returned/succeeded', function(event, response) {
                var model = Stencil.getModel('Coupon'),
                    coupon = model.setAccessor(response.data.coupon);
                Track.event('Coupon applied');
                _this._checkoutModal.setCoupon(coupon);
                this.find('input[name="data[code]"]').attr('readonly', true);
                _this.triggerHandler.delay(1000, _this, ['leave']);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * DelinquentModalView
     * 
     * @extends ModalView
     */
    window.DelinquentModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'DelinquentModalView')
         */
        _string: 'DelinquentModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * DownloadModalView
     * 
     * @see    https://github.com/eligrey/FileSaver.js/
     * @see    http://stackoverflow.com/questions/13752984/html5-file-api-downloading-file-from-server-and-saving-it-in-sandbox
     * @see    http://stackoverflow.com/questions/8126623/downloading-canvas-element-to-an-image
     * @see    http://jsfiddle.net/AbdiasSoftware/7PRNN/
     * @extends ModalView
     */
    window.DownloadModalView = ModalView.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input[type="radio"][name="data[mime]"]': function(event, $input) {
                        var $filename = this.find('[name="data[filename]"]'),
                            value = $filename.val().trim(),
                            mime = this._getMime(),
                            extension = mime === 'image/png' ? 'png' : 'jpg',
                            cleaned = value.replace(/\.[a-z]{3,4}$/i, '.' + extension);
                        $filename.val(cleaned);
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('download');
                        }
                    }
                }
            });
        },

        /**
         * _delays
         * 
         * @access protected
         * @var    Object
         */
        _delays: {

            /**
             * The duration in milliseconds to wait before triggering the
             * canvas export, to allow for the button transition to complete
             * properly.
             * 
             * This number should be greater than the button animation duration
             * (defined in buttons.scss), because in the browser, triggering
             * a canvas export is a data and memory heavy operation, causing
             * the css to freeze. So just wait a reasonable amount of time
             * before doing so.
             */
            animation: 175,

            /**
             * The duration in milliseconds to wait (at a minimum) before
             * pushing an exported file to the user. This is because sometimes
             * the canvas export is so fast (eg. 150ms) that it feels
             * disjointed, in that they click the button and while the button UI
             * changes to communication something, it stops right away and the
             * modal is hidden. This just ensures a minimum time so it doesn't
             * feel like things are jumping around.
             */
            download: 1500
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'DownloadModalView')
         */
        _string: 'DownloadModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
            this._setupDownload();
        },

        /**
         * _disable
         * 
         * @access protected
         * @return void
         */
        _disable: function() {
            this.pause();
            var selector = [
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
            this.find('a.button').addClass('busy').disable();
        },

        /**
         * _enable
         * 
         * @access protected
         * @return void
         */
        _enable: function() {
            this.unpause();
            this.find('a.button').removeClass('busy').disabled(false);
        },

        /**
         * _getFilename
         * 
         * @access protected
         * @return String
         */
        _getFilename: function() {
            var $filename = this.find('[name="data[filename]"]'),
                filename = $filename.val().trim(),
                $mime = this.find('[name="data[mime]"]:checked'),
                mime = $mime.val();
            if (mime === 'image/png') {
                if (filename === '') {
                    var filename = Stencil.account().draft().getDefaultFilename();
                    return filename.replace(/\.jpg$/, '.png');
                }
                if (filename.match(/\.png$/) === null) {
                    return (filename).replace(/\.jpg$/, '') + '.png';
                }
                return filename;
            }
            if (filename === '') {
                var filename = Stencil.account().draft().getDefaultFilename();
                return filename.replace(/\.png$/, '.jpg');
            }
            if (filename.match(/\.jpg$/) === null) {
                return (filename).replace(/\.png$/, '') + '.jpg';
            }
            return filename;
        },

        /**
         * _getMime
         * 
         * @access protected
         * @return String
         */
        _getMime: function() {
            return this.find('[name="data[mime]"]:checked').val();
        },

        /**
         * _getMultiplier
         * 
         * @access protected
         * @return String
         */
        _getMultiplier: function() {
            return this.find('[name="data[multiplier]"]:checked').val();
        },

        /**
         * _localDownloadAction
         * 
         * @access protected
         * @return void
         */
        _localDownloadAction: function() {
            var filename = this._getFilename(),
                mime = this._getMime(),
                multiplier = this._getMultiplier(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;

            /**
             * If the canvas contents have changed from the ImageAccessor that's
             * been loaded into the account draft, then ensure a traditional
             * save action goes on.
             */
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', mime, function(image, content) {

                        /**
                         * Now that the save has been initiated (but not yet
                         * fully completed), check if the multipler is 2x. This
                         * is because the content that comes into this callback
                         * is by default the 2x version. So if they match, go
                         * ahead and push the content to the browser right away.
                         */
                        if (multiplier === '2x') {
                            var blob = dataURItoBlob(content);
                            saveAs(blob, filename);
                            _this.triggerHandler('close');
                        }
                        /**
                         * Otherwise, the user is trying to download the 1x
                         * version. So in that case, I take the content, and
                         * route it through a resize helper function, and then
                         * push that to the browser.
                         */
                        else {
                            var width = Frame.get('width').toInt(),
                                height = Frame.get('height').toInt();
                            resizeDataURI(
                                content,
                                width,
                                height,
                                function(dataURI) {
                                    var blob = dataURItoBlob(dataURI);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                },
                                mime
                            );
                        }
                    });
                }).minDelay(start, this._delays.download);
            }
            /**
             * This is the case whereby the canvas contents are *not* different
             * from the account's draft (known by checking the JSON). In this
             * case, the image raw data either:
             * 1) Is currently being saved, specifically in the case of users
             *    who are Free or Pro, and need to click "Save" before the
             *    "Download" button becomes accessible.
             * 2) Is already stored in an S3 resource
             */
            else {
                var check = false;
                if (Canvases.Ghost.getImage() !== null) {
                    var json = {
                            draft: Stencil.account().draft().json(),
                            ghost: Canvases.Ghost.getImage().json()
                        };
                    check = JSON.stringify(json.draft) === JSON.stringify(json.ghost);
                }

                /**
                 * This is the case where the account draft and ghost canvas
                 * contents match. This happens when:
                 * 1) A save action was initiated *before* a download action,
                 */
                if (check === true) {
                    this._disable();
                    var start = new Date();
                    (function() {
                        if (Canvases.Ghost.get('saving') === true) {
                            Canvases.Ghost.once({
                                'export': function(event, content, mime) {
                                    if (multiplier === '2x') {
                                        var blob = dataURItoBlob(content);
                                        saveAs(blob, filename);
                                        _this.triggerHandler('close');
                                    } else {
                                        var width = Frame.get('width').toInt(),
                                            height = Frame.get('height').toInt();
                                        resizeDataURI(
                                            content,
                                            width,
                                            height,
                                            function(dataURI) {
                                                var blob = dataURItoBlob(dataURI);
                                                saveAs(blob, filename);
                                                _this.triggerHandler('close');
                                            },
                                            mime
                                        );
                                    }
                                }
                            });
                        } else {
                            Canvases.Ghost.once({
                                'export': function(event, content, mime) {
                                    var blob = dataURItoBlob(content);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                }
                            });
                            Canvases.Ghost.export(mime, multiplier === '2x');
                        }
                    }).minDelay(start, this._delays.download);
                }
                /**
                 * This is the case where the account draft and ghost canvas
                 * contents do not match. This happens when:
                 * 1) A previously saved image is loaded into the canvas, and as
                 *    a result, nothing is different from the previously saved
                 *    S3 resource.
                 * 2) The app is initially loaded and a previously saved image
                 *    is the draft (which means an S3 resource exists).
                 */
                else {
                    this._disable();
                    var start = new Date();
                    (function() {
                        var lastSavedImage = Footer.getLastSavedImage();
                        lastSavedImage.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        })
                        lastSavedImage.download(
                            mime,
                            filename,
                            multiplier === '2x',
                            false
                        );
                    }).minDelay(start, this._delays.download);
                }
            }
        },

        /**
         * _remoteDownloadAction
         * 
         * @access protected
         * @return void
         */
        _remoteDownloadAction: function() {
            var filename = this._getFilename(),
                mime = this._getMime(),
                multiplier = this._getMultiplier(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', mime, function(image, content) {
                        image.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        });
                        image.download(
                            mime,
                            filename,
                            multiplier === '2x',
                            false
                        );
                    });
                }).minDelay(start, this._delays.download);
            } else {
                this._disable();
                var start = new Date();
                (function() {
                    var lastSavedImage = Footer.getLastSavedImage();
                    lastSavedImage.once({
                        'download': function(event) {
                            _this.triggerHandler('close');
                        }
                    })
                    lastSavedImage.download(
                        mime,
                        filename,
                        multiplier === '2x',
                        false
                    );
                }).minDelay(start, this._delays.download);
            }
        },

        /**
         * _setupDownload
         * 
         * @access protected
         * @return void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {
                    if (Modernizr.adownload === true) {
                        this._localDownloadAction();
                    } else {
                        this._remoteDownloadAction();
                    }
                }
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function(copy) {
            this._super();
            var $input = this.find('input[type="text"]').first();
            (function() {
                $input.select();
            }).delay(0);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ErrorModalView
     * 
     * @extends ModalView
     */
    window.ErrorModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ErrorModalView')
         */
        _string: 'ErrorModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ExtrasModalView
     * 
     * @extends ModalView
     */
    window.ExtrasModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ExtrasModalView')
         */
        _string: 'ExtrasModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'install': function(event) {
                    if (Browser.bookmarklet() === true) {
                        Stencil.alert('extension.install.window');
                    } else if (Browser.extension() === true) {
                        Stencil.alert('extension.install.window');
                    } else if (Browser.chrome() === false) {
                        Stencil.alert('extension.install.chrome');
                    } else {
                        this.install();
                    }
                }
            });
        },

        /**
         * install
         * 
         * @access public
         * @return void
         */
        install: function() {
            var $link = $('link[rel="chrome-webstore-item"][class="extension"]');
            chrome.webstore.install(
                $link.attr('href'),
                function() {
                    Stencil.navigate('/app/extras/chrome/success');
                },
                function(message, code) {
                    console.log('Errored', message, code);
                    if (code === 'notPermitted') {

                    } else if (code === 'userCancelled') {

                    }
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * GoogleFontsModalView
     * 
     * @see     https://i.imgur.com/yaeZdcb.png
     * @extends ModalView
     */
    window.GoogleFontsModalView = ModalView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input.search': function(event, $input) {
                        if(event.keyCode === 13) {
                            var val = $input.val();
                            if (val === '') {
                                if (this._query !== '') {
                                    this.triggerHandler('clear');
                                }
                            } else {
                                this.triggerHandler('submit');
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.siblings().removeClass('hover');
                        $div.addClass('hover');
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _loaded
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access protected
         * @var    String (default: '')
         */
        _query: '',

        /**
         * _scroll
         * 
         * @access protected
         * @var    Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access private
             * @param  jQuery event
             * @return void
             */
            native: function(event) {
                var $inner = this._element.find('div.results > div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load(false);
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @note   It's important that the selector for $inner below does
             *         not look directly at the children of div.results since
             *         jScrollPane changes the relationship of the elements.
             * @access private
             * @param  jQuery event
             * @param  Number y
             * @param  Boolean top
             * @param  Boolean bottom
             * @return void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.results div.inner');
                bottom = y > ($inner.outerHeight() - this._element.find('div.results').outerHeight() - this._threshold);
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.load(false);
                        }
                    }
                }
            }
        },

        /**
         * _$scrollbar
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GoogleFontsModalView')
         */
        _string: 'GoogleFontsModalView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access protected
         * @var    Number (default: 200)
         */
        _threshold: 200,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._addHoverEvents();
            this._setupCollection();
            this.on({
                'close': function() {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'createFontPreviewImages': function(event, $anchor) {
                    this._createFontPreviewImages();
                },
                'leave': function() {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            this._setupScrollbar();
            this._addInfiniteScrollEvents();
            this._setupDropdowns();
            this._setupCheckboxes();
            this._setupSearch();
        },

        /**
         * _addHoverEvents
         * 
         * @access protected
         * @return void
         */
        _addHoverEvents: function() {
            this.find('div.results').scroll(function(event) {
                var element = document.elementFromPoint(App.getX(), App.getY()),
                    $element = $(element);
                if ($element.length > 0) {
                    $element.closest('.googleFontRow').trigger('mouseenter');
                }
            });
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access protected
         * @return void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            if (this._$scrollbar !== null) {
                check = this._scroll.plugin.proxy(this);
                listener = 'jsp-scroll-y';
            }
            this.find('div.results').first().bind(listener, check);
        },

        /**
         * _createFontPreviewImages
         * 
         * @note   After running this method (via the local anchor link), a zip
         *         file will be pushed at you. Unzip it, and copy the contents
         *         to both the /original/ and /compressed/ folders.
         *         
         *         Then, log into the VM and run the following code. It will
         *         navigate to the /compressed/ folder and compress all of them.
         *         
         *         Finally, once that's down, you'll have downloaded the new zip
         *         file. Unzip that, and replace all the files in the
         *         /compressed/ directory with the new (actually) compressed
         *         images.
         * 

cd /var/www/getstencil.com/TurtlePHP/application/webroot/app/static/images/fonts/google/compressed/ \
&& pngquant *.png -f --ext .png --quality=65-80 \
&& cd ../ \
&& zip -r compressed.zip compressed \
&& mv compressed.zip /var/www/getstencil.com/TurtlePHP/application/webroot/

         * 
         *         Then download from here:
         *         https://local.getstencil.com/compressed.zip
         *         
         *         ------
         *         
         *         If you do not want to do the entire library, you can instead
         *         unzip the file to:
         *         /var/www/getstencil.com/TurtlePHP/application/webroot/new/
         *         
         *         Then login into the VM and run the following:

cd /var/www/getstencil.com/TurtlePHP/application/webroot/new/ \
&& pngquant *.png -f --ext .png --quality=65-80 \
&& cd ../ \
&& zip -r compressed.zip new

         *         
         * @see    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
         * @access protected
         * @return void
         */
        _createFontPreviewImages: function() {
            var optimizeForRetina = true,
                drawCanvas = function(label, fontFamily) {
                    var canvas = document.createElement('canvas'),
                        context = canvas.getContext('2d'),
                        multiplier = optimizeForRetina === true ? window.devicePixelRatio : 1;
                    canvas.width = 800 * multiplier;
                    canvas.height = 300 * multiplier;
                    context.scale(multiplier, multiplier);
                    context.font = '48px "' + (fontFamily) + '"';
                    context.fillText(label, 10, 50);
                    return canvas;
                };
            var zip = new JSZip(),
                counter = 0,
                collection = this._collection;
            collection.each(function(index, googleFont) {
                if (googleFont.get('hasImage').toInt() === 0) {
                    googleFont.drawStyleSheet();

                    // Initiate the load
                    WebFont.load({
                        classes: false,
                        fontactive: function(familyName, fvd) {
                            ++counter;
                            var rawCanvas = drawCanvas(
                                    googleFont.get('family'),
                                    googleFont.get('id')
                                ),
                                trimDetails = rawCanvas.trim(),
                                resizedCanvas = document.createElement('canvas'),
                                resizedContext = resizedCanvas.getContext('2d'),
                                multiplier = optimizeForRetina === true ? window.devicePixelRatio : 1;
                            resizedCanvas.width = trimDetails.width / multiplier;
                            resizedCanvas.height = trimDetails.height / multiplier;
                            resizedContext.drawImage(
                                rawCanvas,
                                trimDetails.bounds.left,
                                trimDetails.bounds.top,
                                trimDetails.width,
                                trimDetails.height,
                                0,
                                0,
                                trimDetails.width / multiplier,
                                trimDetails.height / multiplier
                            );

                            // 
                            console.log('added to zip file #' + counter);
                            var name = (googleFont.get('id')) + '.' +
                                (googleFont.get('version')) + '.png';
                            zip.file(
                                name,
                                resizedCanvas.toDataURL('image/png').split(',')[1],
                                {
                                    base64: true
                                }
                            );

                            // 
                            var googleFontsWithoutImages = collection.filter(function(index, googleFont) {
                                return googleFont.get('hasImage').toInt() === 0;
                            });
                            if (counter === googleFontsWithoutImages.length) {
                                zip.generateAsync({type: 'blob'}).then(
                                    function(content) {
                                        saveAs(content, 'images.zip');
                                    }
                                );
                            }
                        },
                        fontinactive: function() {
                            console.log('bag');
                        },
                        custom: {
                            families: [googleFont.get('id')]
                        },
                        timeout: 5000
                    });
                }
            });
        },

        /**
         * _drawGoogleFont
         * 
         * @access protected
         * @param  GoogleFontAccessor googleFont
         * @param  Number position
         * @return void
         */
        _drawGoogleFont: function(googleFont, position) {
            var $element = Stencil.render('GoogleFontRow', {
                googleFont: googleFont
            });
            if (position === 0) {
                this.find('div.results div.inner').prepend($element);
            } else {
                this.find('div.results div.inner').append($element);
            }
            new GoogleFontRowView($element, googleFont);
        },

        /**
         * _getCategories
         * 
         * @note   ['empty'] array is returned when no categories, because
         *         otherwise, there's an error on the backend because JavaScript
         *         can't submit an empty array as a parameter via ajax.
         * @access protected
         * @return Array
         */
        _getCategories: function() {
            var $checked = this.find('input[type="checkbox"]:checked'),
                categories = [], index;
            jQuery.each($checked, function(index, $input) {
                categories.push(
                    $($input).val()
                );
            });
            if (categories.length === 0) {
                return ['empty'];
            }
            return categories;
        },

        /**
         * _getSubset
         * 
         * @access protected
         * @return String
         */
        _getSubset: function() {
            return this.find('[name="data[subset]"]').val();
        },

        /**
         * _getQuery
         * 
         * @access protected
         * @return String
         */
        _getQuery: function() {
            return this._query;
        },

        /**
         * _getWeight
         * 
         * @access protected
         * @return String
         */
        _getWeight: function() {
            return this.find('[name="data[weight]"]').val();
        },

        /**
         * _getSort
         * 
         * @access protected
         * @return String
         */
        _getSort: function() {
            return this.find('[name="data[sort]"]').val();
        },

        /**
         * _makeScrollable
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _setupCheckboxes
         * 
         * @access protected
         * @return void
         */
        _setupCheckboxes: function() {
            var _this = this;
            this.find('input[type="checkbox"]').on({
                'change': function(event) {
                    _this.pause();
                    _this.unload();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                }
            });
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new GoogleFontsCollection();
            this._collection.on({
                'add': function(event, googleFont, position) {
                    _this._drawGoogleFont(googleFont, position);
                },
                'list': function(event) {
                    _this.refreshScrollbar();
                },
                'empty': function(event) {
                    _this.find('.googleFontRow').remove();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _setupDropdowns
         * 
         * @access protected
         * @return void
         */
        _setupDropdowns: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.pause();
                    _this.unload();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                    _this.find('label').focus();
                }
            );
        },

        /**
         * _setupScrollbar
         * 
         * @access protected
         * @return void
         */
        _setupScrollbar: function() {
            if (Stencil.scrollbars() === true) {
                var $results = this.find('div.results');
                this._makeScrollable($results);
            }
        },

        /**
         * _setupSearch
         * 
         * @access protected
         * @return void
         */
        _setupSearch: function() {

            // Draw
            var total = Stencil.get('config').google.fonts.total.commas(),
                placeholder = 'Search for your font by name',
                $search = Stencil.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this.find('h1').after($search);

            // Events
            this.on({
                'clear': function(event) {
                    var $input = this.find('input.search');
                    $input.val('');
                    this.find('div.field').removeClass('queried');
                    this.find('div.field').addClass('active');
                    this._query = '';
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.load(true, function() {
                        _this.unpause();
                        if (Browser.tablet() === false) {
                            $input.focus();
                        }
                    });
                },
                'submit': function(event) {
                    var $input = this.find('input.search'),
                        val = $input.val();
                    if (Browser.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this.find('div.field').addClass('queried');
                    this.find('div.field').removeClass('active');
                    this._query = $input.val();
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.load(true, function() {
                        _this.unpause();
                        if (Browser.tablet() === false) {
                            $input.focus();
                        }
                    });
                }
            });
        },

        /**
         * getCollection
         * 
         * @access public
         * @return GoogleFontsCollection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * load
         * 
         * @access public
         * @param  Boolean delay
         * @param  undefined|Function callback
         * @return void
         */
        load: function(delay, callback) {
            var _this = this;
            this._element.find('.empty').addClass('hidden');
            this._element.addClass('loading');
            this._loaded = true;
            this._loading = true;
            this._collection.list({
                conditions: {
                    categories: this._getCategories(),
                    query: this._getQuery(),
                    subset: this._getSubset(),
                    weight: this._getWeight()
                },
                delay: delay === true ? 1 : 0,
                limit: Stencil.get('config').defaults.objectsPerPage.fonts.import,
                offset: this._collection.length(),
                sort: this._getSort()
            }, function(response) {
                _this._element.removeClass('loading');
                _this._loading = false;
                _this._more = response.data.more;
                _this.updateCount(
                    response.data.stats.found,
                    response.data.stats.total
                );
                if (_this._collection.length() === 0) {
                    _this._element.find('.empty').removeClass('hidden');
                }
                callback && callback();
            });
        },

        /**
         * pause
         * 
         * @access public
         * @return void
         */
        pause: function() {
            this._super();
            this.find('a.button.tiny').attr('disabled', 'disabled');
            this.find('div.field input').attr('disabled', 'disabled');
            this.find('aside').attr('disabled', 'disabled');
        },

        /**
         * refreshScrollbar
         *
         * @access public
         * @return void
         */
        refreshScrollbar: function() {
            if (this._$scrollbar !== null) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            if (Browser.tablet() === false) {
                this.find('input[type="text"]').focus();
            }
            if (this._loaded === false) {
            // if (this._query !== query) {
                // this.unload();
                // this._query = query;
                this.load(true);
            }
        },

        /**
         * unload
         * 
         * @access public
         * @return void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        },

        /**
         * unpause
         * 
         * @access public
         * @return void
         */
        unpause: function() {
            this._super();
            this.find('a.button.tiny:not(.done)').removeAttr('disabled');
            this.find('div.field input').removeAttr('disabled');
            this.find('aside').removeAttr('disabled');
        },

        /**
         * updateCount
         * 
         * @access public
         * @param  Number found
         * @param  Number total
         * @return void
         */
        updateCount: function(found, total) {
            var $counts = this.find('section footer div.counts'),
                $total = $counts.find('strong');
            $counts.removeClass('invisible');
            $total.text(total.commas());
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ImageSentModalView
     * 
     * @extends ModalView
     */
    window.ImageSentModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access protected
         * @var    ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ImageSentModalView')
         */
        _string: 'ImageSentModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ShareModalView shareModal
         * @param  ImageAccessor image
         * @return void
         */
        init: function(element, shareModal, image) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on('leave', function() {
                var path = image.getSharePath('instagram');
                this.triggerHandler('close');
                Stencil.navigate(path);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * LegacyModalView
     * 
     * @extends ModalView
     */
    window.LegacyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'LegacyModalView')
         */
        _string: 'LegacyModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * LegacyImageNormalizeModalView
     * 
     * @extends ModalView
     */
    window.LegacyImageNormalizeModalView = ModalView.extend({

        /**
         * _image
         * 
         * @access protected
         * @var    false|ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'LegacyImageNormalizeModalView')
         */
        _string: 'LegacyImageNormalizeModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImageAccessor image
         * @return void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
            this._addLeaveEvent();
        },

        /**
         * _addLeaveEvent
         * 
         * @access protected
         * @return void
         */
        _addLeaveEvent: function() {
            this.on('leave', function() {
                if (this._image.get('legacyNormalized').toInt() === 1) {
                    this._image.select('image', 'unknown', false, {});
                } else {
                    var start = new Date(),
                        key = 'image.legacy.normalizing',
                        msg =  Stencil.getMessage(key);
                    App.getBusy().show(msg);
                    this._image.once({
                        'normalize': function(event) {
                            (function() {
                                App.getBusy().hide();
                                this.select('image', 'unknown', false, {});
                            }).minDelay(start, 2500, this);
                        }
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

    /**
     * LoginModalView
     * 
     * @extends AuthModalView
     */
    window.LoginModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'LoginModalView')
         */
        _string: 'LoginModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  false|String redirect
         * @return void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function() {
                    _this.pause();
                },
                'returned': function() {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().swap(accountData);
                    var model = Stencil.getModel('User'),
                        user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.login();
                    _this._flow();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ModalView
     * 
     * @events  close
     *          leave
     * @extends View
     */
    window.ModalView = View.extend({

        /**
         * _fallback
         * 
         * The path that a modal should fallback to if it was directly accessed
         * and is subsequently closed (eg. linking a user to a share modal from
         * an email).
         * 
         * @access protected
         * @var    String (default: '/app')
         */
        _fallback: '/app',

        /**
         * _paused
         * 
         * Tracks whether the modal is paused. Used to prevent the user from
         * navigating away and interrupting the UX.
         * 
         * @access protected
         * @var    Boolean
         */
        _paused: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ModalView')
         */
        _string: 'ModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on('close', function() {
                var _this = this,
                    open = Modals.open();
                this.remove();
                // this.clean();
                $(open).each(
                    function(index, modal) {
                        if (modal === _this) {
                            open.splice(index, 1);
                        }
                    }
                );
            });
            this.on('hide', function() {
                this.hide();
            });
            // FastClick.attach(element.find('a.close').get(0));
            this.on('leave', function() {
                this.triggerHandler('close');
                // var open = Modals.open();
                // if (open.length === 0) {
                    var router = Stencil.getRouter(),
                        path = router.getPrevious() || this._fallback;
                    router.setPrevious(false);
                    Stencil.navigate(path);
                // }
            });
        },

        /**
         * closeUponEscapeKey
         * 
         * @access public
         * @return void
         */
        closeUponEscapeKey: function() {
            var check = (function(event) {
                if (event.keyCode === 27) {
                    this.triggerHandler('leave');
                }
            }).proxy(this);
            App.getElement().on({
                'keydown': check
            });
            this.on({
                'leave': function(event) {
                    App.getElement().unbind('keydown', check);
                }
            });
        },

        /**
         * find
         * 
         * Middleware method to prevent lookups from going into any submodals.
         * This was happening between the CheckoutModal and ApplyCouponModal.
         * 
         * @access public
         * @param  String selector
         * @return jQuery
         */
        find: function(selector) {
            var $matches = this._super(selector);
            if (this._element.parents('.modal').length === 0) {
                return $matches.filter(function() {
                    return $(this).parents('.modal').length === 1;
                });
            }
            return $matches;
        },

        /**
         * hide
         * 
         * @access public
         * @return void
         */
        hide: function() {
            this._element.addClass('hidden');
        },

        /**
         * pause
         * 
         * @access public
         * @return void
         */
        pause: function() {
            this._paused = true;
            this.find('> div.overlay').removeAttr('click');
            this.find('a.close').addClass('invisible');
        },

        /**
         * remove
         * 
         * @access public
         * @return void
         */
        remove: function() {
            this._element.remove();
        },

        /**
         * setFallback
         * 
         * @access public
         * @param  String fallback
         * @return void
         */
        // setFallback: function(fallback) {
        //     this._fallback = fallback;
        // },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._element.removeClass('hidden');
        },

        /**
         * unpause
         * 
         * @access public
         * @return void
         */
        unpause: function() {
            this._paused = false;
            this.find('> div.overlay').attr('click', 1);
            this.find('a.close').removeClass('invisible');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * OnboardModalView
     * 
     * @extends StickyModalView
     */
    window.OnboardModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'OnboardModalView')
         */
        _string: 'OnboardModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String point
         * @param  jQuery $relative
         * @param  jQuery $highlight
         * @return void
         */
        init: function(element, point, $relative, $highlight) {
            // StencilBooter.log($relative, $highlight);
            this._super(element, point, $relative, $highlight);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * OrientationModalView
     * 
     * @extends ModalView
     */
    window.OrientationModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'OrientationModalView')
         */
        _string: 'OrientationModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PasswordModalView
     * 
     * @extends ModalView
     */
    window.PasswordModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access protected
         * @var    false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PasswordModalView')
         */
        _string: 'PasswordModalView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  String redirect
         * @return void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on({
                'submitted': function() {
                    _this.pause();
                },
                'returned': function() {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password recovery email sent');
                    _this.find('.pre').addClass('hidden');
                    _this.find('.post').removeClass('hidden');
                    // _this.triggerHandler('leave');
                    // Stencil.alert('password.reset');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlanSwitchModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PlanSwitchModalView')
         */
        _string: 'PlanSwitchModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlanSwitchedModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchedModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PlanSwitchedModalView')
         */
        _string: 'PlanSwitchedModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlansModalView
     * 
     * @extends ModalView
     */
    window.PlansModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PlansModalView')
         */
        _string: 'PlansModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            // this.unbind('leave');
            // this.on('leave', function() {
            //     this.triggerHandler('close');
            // });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

    /**
     * PromoModalView
     * 
     * @extends AuthModalView
     */
    window.PromoModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PromoModalView')
         */
        _string: 'PromoModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  false|String redirect
         * @return void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function() {
                    _this.pause();
                },
                'returned': function() {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {

                    /**
                     * Login as well as promo redemption
                     * 
                     */
                    if (Stencil.get('user') === false) {
                        var model = Stencil.getModel('User'),
                            userData = response.data.user,
                            accountData = response.data.account,
                            user;
                        accountData = ChangeHistory.replaceAccountChangeHistory(
                            accountData
                        );
                        userData = ChangeHistory.replaceUserChangeHistory(
                            userData
                        );
                        user = model.setAccessor(userData);
                        Stencil.set('user', user);
                        User.signup();
                    }

                    /**
                     * Promo redemption for logged in account
                     * 
                     */
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    User.upgrade(false);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddPromoSetModalView
     * 
     * @extends ModalView
     */
    window.AddPromoSetModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access protected
         * @var    SettingsModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AddPromoSetModalView')
         */
        _string: 'AddPromoSetModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AdminModalView adminModal
         * @return void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
                Stencil.navigate('/app/admin/promoSets');
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupDatetimePicker();
            this._setupTooltips();
        },

        /**
         * _format
         * 
         * @access protected
         * @return void
         */
        _format: function() {

            // Format expiry
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );
        },

        /**
         * _setupDatetimePicker
         * 
         * @access protected
         * @return void
         */
        _setupDatetimePicker: function() {
            var current = new Date();
            current.setDate(current.getDate());
            this.find('#expiry').datetimepicker({
                // debug: true,
                format: 'MM/DD/YYYY h:mm A',
                minDate: current,
                // showTodayButton: true,
                showClose: true,
                showClear: true,
                icons: {
                    time: 'fa fa-clock-o',
                    date: 'fa fa-calendar',
                    up: 'fa fa-chevron-up',
                    down: 'fa fa-chevron-down',
                    previous: 'fa fa-chevron-left',
                    next: 'fa fa-chevron-right',
                    today: 'fa fa-calendar-check-o',
                    clear: 'fa fa-trash-o',
                    close: 'fa fa-close'
                }
            });
            this.find('#expiry').val('');
        },

        /**
         * _setupDropdowns
         * 
         * @access protected
         * @return void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker({
                dropupAuto: false
            });
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on('submitted', this._format.proxy(this));
            this._form.on('submitted', function() {
                _this._adminModal.pause();
                _this.pause();
            });
            this._form.on('returned', function() {
                _this._adminModal.unpause();
                _this.unpause();
            });
            this._form.on('returned/succeeded', function(event, response) {
                Track.event('Promo set added');
                var collection = _this._adminModal.getSection('promoSets')._collection;
                collection.map(response.data.object, false);
                Stencil.navigate('/app/admin/promoSets');
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                container: this._element,
                html: true,
                placement: 'bottom',
                selector: '[tooltip]'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * RenameModalView
     * 
     * @events  save
     * @extends ModalView
     */
    window.RenameModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'RenameModalView')
         */
        _string: 'RenameModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
            this.closeUponEscapeKey();
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function() {
                    _this.pause();
                },
                'returned/failed': function() {
                    _this.unpause();
                },
                'returned/shit': function() {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    _this.triggerHandler('save', [response.data.object]);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * RightClickModalView
     * 
     * @extends StickyModalView
     */
    window.RightClickModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'RightClickModalView')
         */
        _string: 'RightClickModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String direction
         * @param  jQuery $relative
         * @param  jQuery $highlight
         * @return void
         */
        init: function(element, direction, $relative, $highlight) {
            // StencilBooter.log($relative, $highlight);
            this._super(element, direction, $relative, $highlight);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * SettingsModalView
     * 
     * @extends ModalView
     */
    window.SettingsModalView = ModalView.extend({

        /**
         * _settings
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _settings: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SettingsModalView')
         */
        _string: 'SettingsModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupNotifications();
            this._setupPassword();
            this._setupPayment();
            this._setupPlan();
            this._setupProfile();
            this._setupReferral();
            this._setupSocial();
        },

        /**
         * _setupNotifications
         * 
         * @access protected
         * @return void
         */
        _setupNotifications: function() {
            var $notifications = this.find('section.notifications');
            this._settings.notifications = new NotificationsSettingsView(
                $notifications,
                this
            );
        },

        /**
         * _setupPassword
         * 
         * @access protected
         * @return void
         */
        _setupPassword: function() {
            var $password = this.find('section.password');
            this._settings.password = new PasswordSettingsView($password, this);
        },

        /**
         * _setupPayment
         * 
         * @access protected
         * @return void
         */
        _setupPayment: function() {
            var $payment = this.find('section.payment');
            this._settings.payment = new PaymentSettingsView($payment, this);
        },

        /**
         * _setupPlan
         * 
         * @access protected
         * @return void
         */
        _setupPlan: function() {
            var $plan = this.find('section.plan');
            this._settings.plan = new PlanSettingsView($plan, this);
        },

        /**
         * _setupProfile
         * 
         * @access protected
         * @return void
         */
        _setupProfile: function() {
            var $profile = this.find('section.profile');
            this._settings.profile = new ProfileSettingsView($profile, this);
        },

        /**
         * _setupReferral
         * 
         * @access protected
         * @return void
         */
        _setupReferral: function() {
            var $referral = this.find('section.referral');
            this._settings.referral = new ReferralSettingsView($referral, this);
        },

        /**
         * _setupSocial
         * 
         * @access protected
         * @return void
         */
        _setupSocial: function() {
            var $social = this.find('section.social');
            this._settings.social = new SocialSettingsView($social, this);
        },

        /**
         * getSettings
         * 
         * @access public
         * @param  String type
         * @return SettingsView
         */
        getSettings: function(type) {
            return this._settings[type];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareModalView
     * 
     * @todo    Preload connection profile/images, incase they change their
     *          desired connection.
     * @todo    Currently the 64 bit data encoded image is inserted into any
     *          share views that the user views, while the image is being
     *          uploaded
     *          For better quality, two things should happen:
     *          1. When the ghost is ready, switch that data encoded value in
     *          2. When the image has been uploaded, switch that src in
     * @extends ModalView
     */
    window.ShareModalView = ModalView.extend({

        /**
         * _fallback
         * 
         * See parent for documentation on this property.
         * 
         * @access protected
         * @var    String (default: '/app/saved')
         */
        _fallback: '/app/saved',

        /**
         * _image
         * 
         * @access protected
         * @var    ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _networks
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _networks: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ShareModalView')
         */
        _string: 'ShareModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ImageAccessor image
         * @return void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this._setupBuffer();
            this._setupFacebook();
            this._setupInstagram();
            this._setupLink();
            this._setupPinterest();
            this._setupTooltips();
            this._setupTwitter();
            // this._addHoverEvents();
        },

        // /**
        //  * _addHoverEvents
        //  * 
        //  * @access protected
        //  * @var    void
        //  */
        // _addHoverEvents: function() {
        //     var _this = this;
        //     this.find('a[network]:not([network="buffer"])').one({
        //         'mouseenter': function(event) {
        //             var $target = $(event.currentTarget),
        //                 network = $target.attr('network');
        //             _this._networks[network].drawImage('desktop');
        //         }
        //     });
        //     this.find('a[network="buffer"]').one({
        //         'mouseenter': function(event) {
        //             var $target = $(event.currentTarget),
        //                 network = $target.attr('network');
        //             _this._networks[network].drawImage();
        //         }
        //     });
        // },

        /**
         * _setupBuffer
         * 
         * @access protected
         * @return void
         */
        _setupBuffer: function() {
            var $buffer = this.find('section.buffer');
            this._networks.buffer = new BufferShareView($buffer, this);
        },

        /**
         * _setupFacebook
         * 
         * @access protected
         * @return void
         */
        _setupFacebook: function() {
            var $facebook = this.find('section.facebook');
            this._networks.facebook = new FacebookShareView($facebook, this);
        },

        /**
         * _setupInstagram
         * 
         * @access protected
         * @return void
         */
        _setupInstagram: function() {
            var $instagram = this.find('section.instagram');
            this._networks.instagram = new InstagramShareView($instagram, this);
        },

        /**
         * _setupLink
         * 
         * @access protected
         * @return void
         */
        _setupLink: function() {
            var $link = this.find('section.link');
            this._networks.link = new LinkShareView($link, this);
        },

        /**
         * _setupPinterest
         * 
         * @access protected
         * @return void
         */
        _setupPinterest: function() {
            var $pinterest = this.find('section.pinterest');
            this._networks.pinterest = new PinterestShareView($pinterest, this);
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            var account = Stencil.account();
            // if (account.createdBefore('2 weeks') === false) {
            if (false) {
                this._element.tooltip({
                    html: true,
                    selector: '[tooltip]',
                    container: this._element,
                    placement: 'left'
                });
            }
        },

        /**
         * _setupTwitter
         * 
         * @access protected
         * @return void
         */
        _setupTwitter: function() {
            var $twitter = this.find('section.twitter');
            this._networks.twitter = new TwitterShareView($twitter, this);
        },

        /**
         * getImage
         * 
         * @access public
         * @return ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getNetwork
         * 
         * @access public
         * @param  String network
         * @return NetworkView
         */
        getNetwork: function(network) {
            return this._networks[network];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareErrorModalView
     * 
     * @extends ModalView
     */
    window.ShareErrorModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access protected
         * @var    ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ShareSuccessModalView')
         */
        _string: 'ShareSuccessModalView',

        /**
         * init
         * 
         * @todo   Look into whether redirect below is needed; I don't think it
         *         is, since the success modal isn't a unique resource. Should
         *         be able to just close it.
         * @access public
         * @param  jQuery element
         * @param  ShareModalView shareModal
         * @param  ImageAccessor image
         * @param  ConnectionAccessor connection
         * @return void
         */
        init: function(element, shareModal, image, connection) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on('leave', function() {
                var network = connection.get('network'),
                    path = image.getSharePath(network);
                this.triggerHandler('close');
                Stencil.navigate(path);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareSuccessModalView
     * 
     * @extends ModalView
     */
    window.ShareSuccessModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access protected
         * @var    ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ShareSuccessModalView')
         */
        _string: 'ShareSuccessModalView',

        /**
         * init
         * 
         * @todo   Look into whether redirect below is needed; I don't think it
         *         is, since the success modal isn't a unique resource. Should
         *         be able to just close it.
         * @access public
         * @param  jQuery element
         * @param  ShareModalView shareModal
         * @param  ShareAccessor share
         * @return void
         */
        init: function(element, shareModal, share) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on('leave', function() {
                var network = share.reference('connection').get('network'),
                    path = share.reference('image').getSharePath(network);
                this.triggerHandler('close');
                Stencil.navigate(path);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

/*
Stencil.navigate('/app/signup');
Stencil.navigate('/app/signup?save');
Stencil.navigate('/app/signup?upgrade');
Stencil.navigate('/app/signup?checkout');
*/

    /**
     * SignupModalView
     * 
     * @extends AuthModalView
     */
    window.SignupModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SignupModalView')
         */
        _string: 'SignupModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String type
         * @param  String redirect
         * @return void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            this._form.setTimeout(0);
            var _this = this;
            this._form.on({
                'submitted': function() {
                    _this.pause();
                },
                'returned': function() {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('User'),
                        userData = response.data.user,
                        user;
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.signup();
                    _this._flow();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * StickyModalView
     * 
     * @extends ModalView
     */
    window.StickyModalView = ModalView.extend({

        /**
         * _$highlight
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$highlight: null,

        /**
         * _$relative
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$relative: null,

        /**
         * _direction
         * 
         * @access protected
         * @var    String (default: null)
         */
        _direction: null,

        /**
         * _padding
         * 
         * @access protected
         * @var    Number (default: 20)
         */
        _padding: 20,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StickyModalView')
         */
        _string: 'StickyModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String direction Which direction (eg. up down left right) the
         *         sticky modal should point
         * @param  jQuery $relative
         * @param  false|jQuery $highlight
         * @return void
         */
        init: function(element, direction, $relative, $highlight) {
            this._super(element);
            this._direction = direction;
            this._$relative = $relative;
            this._$highlight = $highlight || this._$relative;
            this._addPositionEvent();
            this._addCloseEvent();
        },
        
        /**
         * _addCloseEvent
         * 
         * @access protected
         * @return void
         */
        _addCloseEvent: function() {
            this.on('close', function() {
                this._$highlight.css('z-index', 'auto');
            });
        },
        
        /**
         * _addPositionEvent
         * 
         * @access protected
         * @return void
         */
        _addPositionEvent: function() {
            var reposition = function() {
                this.position();
            }.proxy(this);
            $(window).resize(reposition);
            this.on('close', function() {
                $(window).unbind('resize', reposition);
            });
        },
        
        /**
         * _positionAbove
         * 
         * @note   Content offset is used, because without it, the positioning
         *         is off when the app is loaded externally. This is because of
         *         the padding on the body, which throws off the calculations.
         * @access protected
         * @return void
         */
        _positionAbove: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    top: offset.relative.top.toInt() - offset.content.top.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.top - $content.css('height').toInt() - this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * _positionBelow
         * 
         * @note   Content offset is used, because without it, the positioning
         *         is off when the app is loaded externally. This is because of
         *         the padding on the body, which throws off the calculations.
         * @access protected
         * @return void
         */
        _positionBelow: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    bottom: offset.relative.top.toInt() - offset.content.top.toInt() + height.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.bottom + this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * position
         * 
         * @access public
         * @return void
         */
        position: function() {
            if (this._direction === 'up') {
                this._positionBelow();
            } else {
                this._positionAbove();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * TutorialsModalView
     * 
     * @extends ModalView
     */
    window.TutorialsModalView = ModalView.extend({

        /**
         * _tutorials
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _tutorials: {},

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TutorialsModalView')
         */
        _string: 'TutorialsModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupSections();
        },

        /**
         * _setupSections
         * 
         * @access protected
         * @return void
         */
        _setupSections: function() {
            var tutorials = Stencil.get('config').defaults.tutorials,
                _this = this;
            jQuery.each(tutorials, function(index, tutorial) {
                var slug = tutorial.slug,
                    selector = 'section.' + (slug),
                    $tutorials = _this.find(selector);
                _this._tutorials[slug] = new TutorialsView($tutorials, slug, _this);
            });
        },

        /**
         * getTutorials
         * 
         * @access public
         * @param  String slug
         * @return TutorialsView
         */
        getTutorials: function(slug) {
            return this._tutorials[slug];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpgradeModalView
     * 
     * @extends ModalView
     */
    window.UpgradeModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UpgradeModalView')
         */
        _string: 'UpgradeModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpgradedModalView
     * 
     * @extends ModalView
     */
    window.UpgradedModalView = ModalView.extend({

        /**
         * _plan
         * 
         * @access protected
         * @var    String (default: null)
         */
        _plan: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UpgradedModalView')
         */
        _string: 'UpgradedModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String plan
         * @return void
         */
        init: function(element, plan) {
            this._super(element);
            this._plan = plan;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * SearchUsersModalView
     * 
     * @extends ModalView
     */
    window.SearchUsersModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    'input[type="text"]': function(event, $input) {
                        if(event.keyCode === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $form
                     * @return void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SearchUsersModalView')
         */
        _string: 'SearchUsersModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  AdminUsersView section
         * @return void
         */
        init: function(element, section) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function() {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
            this.on({
                'submit': function(event) {
                    var $input = this.find('input[type="text"]'),
                        val = $input.val(),
                        query = encodeURIComponent(val),
                        path = '/app/admin/users/search/' + (query);
                    Stencil.navigate(path, true, true);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpdateUserModalView
     * 
     * @extends ModalView
     */
    window.UpdateUserModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'UpdateUserModalView')
         */
        _string: 'UpdateUserModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String key
         * @param  AdminUsersView section
         * @return void
         */
        init: function(element, key, section) {
            this._super(element);
            this.unbind('leave');
            this._setupTooltips();
            this._form = new AppFormView(this.find('form'));
            this.on({
                'leave': function() {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * WelcomeTourModalView
     * 
     * @extends ModalView
     */
    window.WelcomeTourModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WelcomeTourModalView')
         */
        _string: 'WelcomeTourModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * step
         * 
         * @access public
         * @param  Number step
         * @return void
         */
        step: function(step) {
            this.find('div.step').addClass('hidden');
            this.find('[step="' + (step) + '"]').removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * YouTubeVideoModalView
     * 
     * @extends ModalView
     */
    window.YouTubeVideoModalView = ModalView.extend({

        /**
         * _options
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _options: {},

        /**
         * _slug
         * 
         * @access protected
         * @var    false|String (default: false)
         */
        _slug: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'YouTubeVideoModalView')
         */
        _string: 'YouTubeVideoModalView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  String youTubeSlug
         * @param  Object options
         * @return void
         */
        init: function(element, youTubeSlug, options) {
            this._super(element);
            this._youTubeSlug = youTubeSlug;
            this._options = options;
            this.unbind('leave');
            this.on('leave', function() {
                this.triggerHandler('close');
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AppPageView
     * 
     * @extends View
     */
    window.AppPageView = View.extend({

        /**
         * _editor
         * 
         * @access protected
         * @var    EditorView (default: null)
         */
        _editor: null,

        /**
         * _hourglass
         * 
         * @access protected
         * @var    HourglassView (default: null)
         */
        _hourglass: null,

        /**
         * _last
         * 
         * Tracks the mouse position
         * 
         * @access protected
         * @var    Object
         */
        _last: {
            x: 0,
            y: 0
        },

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a[internal]:not([disabled])': function(event, $anchor) {
                        event.preventDefault();
                        var href = $anchor.attr('href');
                        Stencil.navigate(href);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'a[internal][disabled]': function(event, $anchor) {
                        event.preventDefault();
                    }
                }
                // ,
                // keydown: {
                //     '[tabindex]': function(event, $element) {
                //         StencilBooter.log(event);
                //         if (event.keyCode === 9) {
                //             event.preventDefault();
                //         }
                //     }
                // }
            });
        },

        /**
         * _maxScriptWaitMilliseconds
         * 
         * The maximum number of milliseconds the app will wait for a 3rd-party
         * script to load, before showing an alert.
         * 
         * @access protected
         * @var    Number (default: 30 * 1000)
         */
        _maxScriptWaitMilliseconds: 30 * 1000,

        /**
         * _sidebar
         * 
         * @access protected
         * @var    SidebarView (default: null)
         */
        _sidebar: null,

        /**
         * _stage
         * 
         * @access protected
         * @var    StageView (default: null)
         */
        _stage: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'AppPageView')
         */
        _string: 'AppPageView',

        /**
         * _thresholds
         * 
         * @access protected
         * @var    Object
         */
        _thresholds: {
            unrestrict: 2500
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            window.App = this;
            this._reInitFabricDevicePixelRatioSetting();
            this._addBrowserClasses();
            this._addDeviceClasses();
            this._addMousemoveEvent();
            this._addRenderEventListener();
            this._addChangeHistoryEventListeners();
            this._addDevicePixelRatioChangeEvent();
            this._drawHourglass();
            this._setupAuth();
            this._setupBusyModal();
            this._setupEditor();
            this._setupEmergency();
            this._setupHide();
            this._setupSidebar();
            this._setupStage();
            this._setupTooltipHiding();
            this._setupUnload();
            if (Browser.tablet() === true) {
                // FastClick.attach(document.body);
                this._setupOrientationModal();
            }
        },

        /**
         * _addBrowserClasses
         * 
         * A bit of gotcha here is that Microsoft Edge passes the Google Chrome
         * check. So to get around this, I simply check for Edge first. Also
         * worth noting is that Edge identifies as webkit, perhaps because it's
         * goal is to support all webkit features. This can throw things for a
         * loop sometimes.
         * 
         * @access protected
         * @return void
         */
        _addBrowserClasses: function() {
            if (Browser.edge() === true) {
                this._element.addClass('edge');
            } else if (Browser.chrome() === true) {
                this._element.addClass('chrome');
            } else if (Browser.safari() === true) {
                this._element.addClass('safari');
            } else if (Browser.firefox() === true) {
                this._element.addClass('firefox');
            } else if (Browser.ie() === true) {
                this._element.addClass('ie');
            }
        },

        /**
         * _addRenderEventListener
         * 
         * @access protected
         * @return void
         */
        _addRenderEventListener: function() {
            App.getElement().on({
                'mousedown': function(event) {
                    if (Canvases.Preview.get('rendering') === true) {
                        var msg = Stencil.getMessage('image.rendering'),
                            startTimestamp = new Date();
                        App.getBusy().show(msg);
                        Canvases.Preview.once({
                            'set/rendering': function(event, value) {
                                if (value === false) {
                                    var busy = App.getBusy();
                                    busy.hide.minDelay(
                                        startTimestamp,
                                        1000,
                                        busy
                                    );
                                }
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addChangeHistoryEventListeners
         * 
         * @access protected
         * @return void
         */
        _addChangeHistoryEventListeners: function() {
            if (ChangeHistory.active() === true) {

                /**
                 * 
                 */
                this._element.on({
                    'mouseup keyup': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });
                this.on({
                    'changeHistory/track': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });

                /**
                 * Adds the keyboard shortcut listeners for redo and undo.
                 * 
                 */
                App.getElement().on({
                    'keydown': function(event) {
                        if (ChangeHistory.keyboardShortcuts.redo(event) === true) {

                            /**
                             * I prevent the browser default action if the y-key
                             * is pressed, because in Chrome the default action
                             * is to open the browser history.
                             */
                            if (event.key.toLowerCase() === 'y') {
                                event.preventDefault();
                            }
                            ChangeHistory.initiate.redo(1);
                        } else if (ChangeHistory.keyboardShortcuts.undo(event) === true) {
                            ChangeHistory.initiate.undo(1);
                        }
                    }
                });
            }
        },

        /**
         * _addDeviceClasses
         * 
         * @access protected
         * @return void
         */
        _addDeviceClasses: function() {
            if (Browser.ipad() === true) {
                this._element.addClass('ipad');
            }
        },

        /**
         * _addDevicePixelRatioChangeEvent
         * 
         * Detects a change (any change) to the window's devicePixelRatio
         * property, and prompts the user to reload the app (since the canvas
         * will likely be bust otherwise).
         * 
         * @see    http://stackoverflow.com/questions/28905420/window-devicepixelratio-change-listener/29653772#29653772
         * @see    http://caniuse.com/#feat=matchmedia
         * @access protected
         * @return void
         */
        _addDevicePixelRatioChangeEvent: function() {
            var dPR = window.devicePixelRatio.round(3),
                queries = {
                    min: 'screen and (min-resolution: ' + (dPR) + 'dppx)',
                    max: 'screen and (max-resolution: ' + (dPR) + 'dppx)'
                },
                kill = function(event) {
                    Stencil.account().draft().setConfiguration();
                    Stencil.account().draft().saveConfiguration();
                    Stencil.alert('devicePixelRatio.change');
                    Stencil.kill();
                };
            window.matchMedia(queries.max).addListener(kill);
            window.matchMedia(queries.min).addListener(kill);
        },

        /**
         * _addMousemoveEvent
         * 
         * @access protected
         * @return void
         */
        _addMousemoveEvent: function() {
            $(window).mousemove(
                function(event) {
                    this._last.x = event.pageX;
                    this._last.y = event.pageY;
                }.proxy(this)
            );
        },

        /**
         * _drawHourglass
         * 
         * @access protected
         * @return void
         */
        _drawHourglass: function() {
            var $hourglass = Stencil.render('Hourglass');
            this._element.append($hourglass);
            this._hourglass = new HourglassView($hourglass);
        },

        /**
         * _reInitFabricDevicePixelRatioSetting
         * 
         * Firefox has a pretty big bug whereby the devicePixelRatio is
         * undefined while an iframe is hidden. This causes issues with the
         * Firefox extension and Publisher embed because the global
         * fabric.devicePixelRatio is defined initially when the fabric library
         * is loaded. As a result, when the iframe is loaded, it gets
         * invalidally set to 1. To deal with this, I reset the devicePixelRatio
         * for the library when the app is setup, since at that point, the
         * iframe is visible.
         * 
         * @access protected
         * @return void
         */
        _reInitFabricDevicePixelRatioSetting: function() {
            fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                fabric.window.webkitDevicePixelRatio ||
                fabric.window.mozDevicePixelRatio ||
                1;
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            if (User.admin() === true) {
                var email = Stencil.get('user').get('email');
                this._element.addClass('admin');
                this._element.attr('data-user-email', email);
                if (User.editor() === true) {
                    this._element.addClass('editor');
                }
            } else {
                User.once({
                    'login': function(event, user) {
                        if (User.admin() === true) {
                            var email = Stencil.get('user').get('email');
                            _this._element.addClass('admin');
                            _this._element.attr('data-user-email', email);
                            if (User.editor() === true) {
                                _this._element.addClass('editor');
                            }
                        }
                    }
                });
            }
        },

        /**
         * _setupBusyModal
         * 
         * @access protected
         * @return void
         */
        _setupBusyModal: function() {
            var $busy = this.find('> div.content > div.modal.busy');
            this._busy = new BusyModalView($busy);
        },

        /**
         * _setupHide
         * 
         * @access protected
         * @return void
         */
        _setupHide: function() {
            this.on({
                'hide': this.hide.proxy(this)
            });
        },

        /**
         * _setupEditor
         * 
         * @access protected
         * @return void
         */
        _setupEditor: function() {
            var $editor = this.find('section.editor');
            this._editor = new EditorView($editor);
        },

        /**
         * _setupEmergency
         * 
         * @access protected
         * @return void
         */
        _setupEmergency: function() {
            var emergency = Stencil.get('config').emergency,
                markup = '<div class="emergency">' +
                        '<div class="message"></div>' +
                        '<div class="close fa fa-close"></div>' +
                    '</div>',
                $element = $(markup);
            $element.find('.message').text(emergency.message);
            if (emergency.active === true) {
                this._element.prepend($element);
                $element.find('.close').one({
                    'click': function(event, $div) {
                        $element.remove();
                    }
                });
            }
        },

        /**
         * _setupOrientationModal
         * 
         * @access protected
         * @return void
         */
        _setupOrientationModal: function() {
            var check = function() {
                if (Browser.orientation() === 'portrait') {
                    Stencil.navigate('/app/orientation?clean=1');
                } else {
                    var modal = Modals.get('Orientation');
                    if (modal) {
                        modal.triggerHandler('leave');
                    }
                }
            };
            window.addEventListener('orientationchange', check, false);
        },

        /**
         * _setupSidebar
         * 
         * @access protected
         * @return void
         */
        _setupSidebar: function() {
            var $sidebar = this.find('aside.sidebar');
            this._sidebar = new SidebarView($sidebar);
        },

        /**
         * _setupStage
         * 
         * @access protected
         * @return void
         */
        _setupStage: function() {
            var $stage = this.find('section.stage');
            this._stage = new StageView($stage);
        },

        /**
         * _setupTooltipHiding
         * 
         * @access protected
         * @return void
         */
        _setupTooltipHiding: function() {
            var router = Stencil.getRouter();
            router.on({
                'route': function() {
                    App.tooltips.hide();
                }
            });
        },

        /**
         * _setupUnload
         * 
         * @todo   Stencil.kill? Not sur if possible
         * @access protected
         * @return void
         */
        _setupUnload: function() {
            $(window).bind('beforeunload', function() {
                if (jQuery.xhrPool.length > 0) {
                    return 'Still saving!';
                }
            });
        },

        // /**
        //  * busy
        //  * 
        //  * @access public
        //  * @param  String type
        //  * @return void
        //  */
        // busy: function(type) {
        //     if (type === 'popup') {
        //         var str = 'If a window does not popup, please check that it ' +
        //             'was<br />not blocked by your browser or popup-blocker.';
        //         App.getBusy().show(str);
        //     }
        // },

        /**
         * hide
         * 
         * @access protected
         * @return void
         */
        hide: function() {
            var slide = Stencil.get('config').defaults.slide;
            this.slide.up.call(this);
            Stencil.postMessage.delay(
                slide,
                Stencil,
                ['message.app.hide']
            );
        },

        /**
         * getEditor
         * 
         * @access public
         * @return EditorView
         */
        getEditor: function() {
            return this._editor;
        },

        /**
         * getHourglass
         * 
         * @access public
         * @return HourglassView
         */
        getHourglass: function() {
            return this._hourglass;
        },

        /**
         * getSidebar
         * 
         * @access public
         * @return SidebarView
         */
        getSidebar: function() {
            return this._sidebar;
        },

        /**
         * getStage
         * 
         * @access public
         * @return StageView
         */
        getStage: function() {
            return this._stage;
        },

        /**
         * getX
         * 
         * @access public
         * @return Number
         */
        getX: function() {
            return this._last.x;
        },

        /**
         * getY
         * 
         * @access public
         * @return Number
         */
        getY: function() {
            return this._last.y;
        },

        /**
         * preloadShareModalStaticAssets
         * 
         * @access public
         * @return void
         */
        preloadShareModalStaticAssets: function() {
            var key = 'shareModalStaticAssetsPreloaded',
                preloaded = Stencil.get(key);
            if (preloaded === undefined) {
                Stencil.set(key, true);
                var assets = [
                    '/app/static/images/backgrounds/phone.header.v2.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/chevron.down.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/globe.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/instagram/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/pinterest/header.png'
                ];
                for (var index in assets) {
                    new Image().src = (window.STATIC) + (assets[index]);
                }
            }
        },

        /**
         * setSelectedFrame
         * 
         * Sets the frame accessor that should be accessible via the global
         * window.Frame reference. Also updates the UI surrounding the canvas to
         * reference the selected frame (such as the dimensions copy and label
         * underneath the preview canvas).
         * 
         * @access public
         * @return void
         */
        setSelectedFrame: function() {
            var account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                key = draft.get('frame'),
                frame = account.collection('frames').find(key);
            if (frame === false) {
                frame = orphan;
                orphan.set({
                    width: draft.get('width'),
                    height: draft.get('height')
                });
            } else {
                if (
                    frame.get('width').toInt() !== draft.get('width').toInt()
                    || frame.get('height').toInt() !== draft.get('height').toInt()
                ) {
                    frame = orphan;
                    orphan.set({
                        width: draft.get('width'),
                        height: draft.get('height')
                    });
                }
            }
            frame.select();
            frame.updateMessaging();
        },

        /**
         * show
         * 
         * @access protected
         * @return void
         */
        show: function() {
            this.slide.down.call(this);
            // Stencil.postMessage.delay(
            //     750,
            //     Stencil,
            //     ['message.app.opened']
            // );
        },

        /**
         * slide
         * 
         * @var    Object
         * @access public
         */
        slide: {

            /**
             * down
             * 
             * @access public
             * @return void
             */
            down: function() {
                this._element.addClass('down');
            },

            /**
             * up
             * 
             * @access public
             * @return void
             */
            up: function() {
                this._element.removeClass('down');
            }
        },

        /**
         * tooltips
         * 
         * @var    Object
         * @access public
         */
        tooltips: {

            /**
             * hide
             * 
             * @access public
             * @return void
             */
            hide: function() {
                App.find('[tooltip]').tooltip('destroy');
            }
        },

        /**
         * unrestrict
         * 
         * @note   This is the function that upon initial page load, removes the
         *         busy modal. Look here, Oliver, look here!
         * @access public
         * @return void
         */
        unrestrict: function() {
            // var current = new Date.getTime();
            // if ((current - start) > this._thresholds.unrestrict) {
                this._busy.hide();
            // } else {
            //     this.unrestrict.delay(50, this);
            // }
        },

        /**
         * waitFor
         * 
         * Waits for a specific script to load by showing a busy modal with a
         * message, and once loaded, hides it. Also contains logic incase the
         * script doesn't load after X seconds. If that occurs, simply show an
         * alert and unbind the callback.
         * 
         * @access public
         * @param  String script
         * @return void
         */
        waitFor: function(script) {
            var msg = Stencil.getMessage('dependency.pending'),
                timeout,
                callback = function() {
                    jQuery.timeoutPool.clear(timeout);
                    App.getBusy().hide();
                },
                listener = 'script/' + (script) + '/loaded';
            timeout = (function() {
                Stencil.alert('dependency.failed');
                Stencil.kill();
                Stencil.unbind(listener, callback);
            }).delay(this._maxScriptWaitMilliseconds);
            App.getBusy().show(msg);
            Stencil.once(listener, callback);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * NotificationsSettingsView
     * 
     * @extends SettingsView
     */
    window.NotificationsSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'NotificationsSettingsView')
         */
        _string: 'NotificationsSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'notifications')
         */
        _type: 'notifications',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(100);
            this._form.on({
                'submitted': function() {
                    modal.pause();
                },
                'returned': function() {
                    modal.unpause();
                },
                /**
                 * 
                 * @note setting notification below is to trigger a User::change
                 *       event, which inits an analytics tracking call
                 */
                'returned/succeeded': function(event, response) {
                    Track.event('Notifications settings updated');
                    var user = Stencil.get('user'),
                        notification = response.data.object.notification;
                    user.set({'notification': notification});
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PasswordSettingsView
     * 
     * @extends SettingsView
     */
    window.PasswordSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PasswordSettingsView')
         */
        _string: 'PasswordSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'password')
         */
        _type: 'password',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function() {
                    modal.pause();
                },
                'returned': function() {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password changed');
                    this.find('input').val('');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PaymentSettingsView
     * 
     * @events  show/history
     * @extends SettingsView
     */
    window.PaymentSettingsView = SettingsView.extend({

        /**
         * _events
         * 
         * @access protected
         * @var    Object
         */
        _events: {

            /**
             * detect
             * 
             * @access private
             * @param  jQuery event
             * @param  jQuery $input
             * @return void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access protected
         * @var    CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PaymentSettingsView')
         */
        _string: 'PaymentSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'payment')
         */
        _type: 'payment',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('accountDock');
            this._form = new CreditCardAppFormView(this.find('form'));
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    this.find('a.button').removeAttr('disabled');
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Payment settings updated');
                    var account = Stencil.account(),
                        customer = account.upgrade().customer();
                    customer.set({
                        delinquent: 0
                    });
                }
            });
            this._form.setTimeout(0);
            this._form.setAcceptableCards([
                'Visa',
                'MasterCard',
                'American Express'
            ]);

            // History
            this.on({
                'show/history': function(event) {
                    if (Scripts.loaded('accountDock') === false) {
                        App.waitFor('accountDock');
                    } else {
                        if (Browser.extension() === true) {
                            Stencil.alert('accountDock.extension.disabled');
                        } else {
                            var key = Stencil.account().upgrade().customer().get(
                                    'gatewayKey'
                                ),
                                handler = AccountDock.configure({
                                    customer: key
                                });
                            handler.open({
                                container: 'window'
                            });
                        }
                    }
                }
            });

            // Pausing/unpausing
            this._form.on({
                'card/submitted': modal.pause.proxy(modal),
                'card/returned': modal.unpause.proxy(modal),
                'submitted': modal.pause.proxy(modal),
                'returned': modal.unpause.proxy(modal)
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PlanSettingsView
     * 
     * @extends SettingsView
     */
    window.PlanSettingsView = SettingsView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PlanSettingsView')
         */
        _string: 'PlanSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'plan')
         */
        _type: 'plan',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * ProfileSettingsView
     * 
     * @extends SettingsView
     */
    window.ProfileSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ProfileSettingsView')
         */
        _string: 'ProfileSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'profile')
         */
        _type: 'profile',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function() {
                    modal.pause();
                },
                'returned': function() {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Profile settings updated');
                    var user = Stencil.get('user');
                    user.set({
                        email: response.data.object.email,
                        name: response.data.object.name
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * ReferralSettingsView
     * 
     * @events  share/facebook
     *          share/twitter
     * @extends SettingsView
     */
    window.ReferralSettingsView = SettingsView.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ReferralSettingsView')
         */
        _string: 'ReferralSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'referral')
         */
        _type: 'referral',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on('share/facebook', this.showFacebookShare);
            this.on('share/twitter', this.showTwitterShare);
            Scripts.load('facebook');
        },

        /**
         * _getFacebookShareObject
         * 
         * @access protected
         * @return Object
         */
        _getFacebookShareObject: function() {
            var share = Stencil.get('config').defaults.shares['referral.facebook'];
            return {
                display: 'popup',
                method: 'feed',
                name: share.title,
                description: share.description,
                link: this._getShareUrl(),
                picture: share.picture
            };
        },

        /**
         * _getShareUrl
         * 
         * @access protected
         * @return String
         */
        _getShareUrl: function() {
            return Stencil.account().getReferralUrl();
        },

        /**
         * _getSnippet
         * 
         * @access protected
         * @return String
         */
        _getSnippet: function() {
            return 'Check out Stencil, the easiest way to create amazing ' +
                'graphics for #socialmedia:';
        },

        /**
         * selectInput
         * 
         * @access public
         * @return void
         */
        selectInput: function() {
            var input = this.find('input');
            (function() {
                input.select();
            }).delay(0);
        },

        /**
         * showFacebookShare
         * 
         * @access public
         * @return void
         */
        showFacebookShare: function() {
            if (Scripts.loaded('facebook') === false) {
                App.waitFor('facebook');
            } else {
                FB.ui(
                    this._getFacebookShareObject(),
                    function(response) {
                    }
                );
            }
        },

        /**
         * showTwitterShare
         * 
         * @access public
         * @return void
         */
        showTwitterShare: function() {
            var share = Stencil.get('config').defaults.shares['referral.twitter'],
                url = this._getShareUrl(),
                message = encodeURIComponent(share.message),
                link = 'https://twitter.com/intent/tweet' +
                    '?url=' + (url) +
                    '&via=' + (share.via) +
                    '&text=' + (message);
            window.open(
                link,
                'Twitter Share',
                'width=640, height=420'
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SettingsView
     * 
     * @extends View
     */
    window.SettingsView = View.extend({

        /**
         * _modal
         * 
         * @access protected
         * @var    SettingsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SettingsView')
         */
        _string: 'SettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[settings="' + (this._type) + '"]');
            $anchor.siblings('[settings]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            Browser.tablet() === false && this._element.focusable().focus();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * SocialSettingsView
     * 
     * @todo    Preload connection profile/images, incase they click on
     *          "View/edit"
     * @events  connect/facebook
     *          connect/twitter
     * @extends SettingsView
     */
    window.SocialSettingsView = SettingsView.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    Collection (default: null)
         */
        _collection: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SocialSettingsView')
         */
        _string: 'SocialSettingsView',

        /**
         * _type
         * 
         * @access protected
         * @var    String (default: 'social')
         */
        _type: 'social',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  SettingsModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this._setupCollection();
            this.refresh();
            this.on({
                'connect/facebook': function(event) {
                    if (Scripts.loaded('facebook') === false) {
                        App.waitFor('facebook');
                    } else {
                        this._showBusyModal();
                        // App.busy('popup');
                        var facebook = this._getModel('Facebook');
                        facebook.connect({
                            'connected': function(connections) {
                                App.getBusy().hide();
                            },
                            'denied': function() {
                                App.getBusy().hide();
                            }
                        });
                    }
                },
                'connect/twitter': function(event) {
                    this._showBusyModal();
                    // App.busy('popup');
                    var twitter = this._getModel('Twitter');
                    twitter.setup();
                    twitter.connect({
                        'closed': function(connections) {
                            App.getBusy().hide();
                        }
                    });
                }
            });
        },

        /**
         * _count
         * 
         * @access protected
         * @param  String network
         * @return void
         */
        _count: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]'),
                $count,
                type,
                hash = {
                    facebook: {
                        account: 'page',
                        profile: 'profile'
                    },
                    twitter: {
                        profile: 'account'
                    }
                },
                copy,
                matching,
                $counts = $network.find('[lookup="count"]');
            jQuery.each($counts, function(index, count) {
                matching = [];
                $count = $(count);
                type = $count.attr('type');
                jQuery.each(connections, function(index, connection) {
                    if (connection.get('type') === type) {
                        matching.push(connection);
                    }
                });
                copy = (matching.length) + ' ' +
                    (matching.length === 1 ? hash[network][type] : (hash[network][type] + 's'));
                $count.text(copy);
            });
        },

        /**
         * _setupCollection
         * 
         * @access protected
         * @return void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = Stencil.account().collection('connections');
            this._collection.on({
                'update': function(event) {
                    _this.refresh();
                }
            });
        },

        /**
         * _show
         * 
         * @access protected
         * @param  String network
         * @return void
         */
        _show: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]');
            $network.find('.prompt').addClass('hidden');
            $network.find('.details').addClass('hidden');
            if (connections.length === 0) {
                $network.find('.prompt').removeClass('hidden');
            } else {
                $network.find('.details').removeClass('hidden');
            }
        },

        /**
         * _showBusyModal
         * 
         * @access protected
         * @return void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },


        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            this._show('facebook');
            this._count('facebook');
            this._show('twitter');
            this._count('twitter');
            this._show('pinterest');
            this._count('pinterest');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * BufferShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.BufferShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _drawn: false,

        /**
         * _image
         * 
         * @access protected
         * @var    ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'buffer')
         */
        _network: 'buffer',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BufferShareView')
         */
        _string: 'BufferShareView',

        /**
         * init
         * 
         * @todo   Ensure action for this view cannot be initiated until after
         *         the image has been uploaded:
         *         eg: image.get('uploaded').toInt() === 1
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @access protected
         * @return String
         */
        _getShareUrl: function() {
            return '';
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access protected
         * @return void
         */
        _position: function() {
            var _this = this,
                image = new Image();
            image.onload = function() {
                var img = _this.find('img:not(.shadow)'),
                    width = img.css('width').toInt();
                _this.find('.shadow').css(
                    'margin-left',
                    0 - Math.round(width / 2)
                );
            };
            image.src = this._modal.getImage().getSrc();
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access public
         * @return void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * open
         * 
         * @note   Buffer breaks if I don't pass in a url parameter, so I
         *         override the NetworkShareView _getShareUrl method to return
         *         an empty string.
         * @note   I don't truncate, since Buffer offers it's own UI and UX to
         *         truncate the string. It's better for them to do it there,
         *         since the different networks off different degrees of
         *         truncation.
         * @access public
         * @return void
         */
        open: function() {
            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(false),
                    url = encodeURIComponent(this._getShareUrl()),
                    picture = encodeURIComponent(this._getOriginalImageUrl()),
                    text = encodeURIComponent(snippetObject.snippet),
                    link = 'https://buffer.com/add' +
                        '?url=' + (url) +
                        '&picture=' + (picture);
                if (snippetObject.default === false) {
                    link += '&text=' + (text);
                }
                window.open(
                    link,
                    'Buffer Share',
                    'width=900, height=840'
                );
            } else {
                var msg = Stencil.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function() {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since BufferShareView doesn't require one. Also, the <_position> call
         * is needed for Buffer.
         * 
         * @access public
         * @return void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._position();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * FacebookShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.FacebookShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $textarea
                     * @return void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'facebook')
         */
        _network: 'facebook',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FacebookShareView')
         */
        _string: 'FacebookShareView',

        /**
         * _thresholds
         * 
         * @access protected
         * @var    Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!! Instead of having image-uploaded property checked on backend,
         *         check it here, and if it is not yet uploaded, wait for it
         *         (via event listener), and then submit form.
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this.on({
                'connection/add': function() {
                    if (Scripts.loaded('facebook') === false) {
                        App.waitFor('facebook');
                    } else {
                        this._showBusyModal();
                        var _this = this,
                            model = this._getModel('Facebook');
                        model.connect({
                            connected: function(connections) {
                                App.getBusy().hide();
                                _this.state('connections');
                            },
                            denied: function(connections) {
                                App.getBusy().hide();
                            }
                        });
                    }
                }
            });
            this._setupForm();
            this.preview('desktop', false);

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _connections
         * 
         * Returns all connections for Facebook, or else Facebook connections by
         * type (eg. page, profile).
         * 
         * @access protected
         * @param  String type
         * @return Array
         */
        _connections: function(type) {
            var connections = this._super(),
                matching = [];
            if (type === undefined) {
                return connections;
            }
            jQuery.each(connections, function(index, connection) {
                if (connection.get('type') === type) {
                    matching.push(connection);
                }
            });
            return matching;
        },

        /**
         * _drawConnections
         * 
         * @access protected
         * @return void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections;
            $connections = Stencil.render('FacebookConnections', {
                live: connections.length > this._thresholds.search,
                connections: {
                    profiles: this._connections('profile'),
                    pages: this._connections('account')
                }
            });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access protected
         * @return void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareFacebookRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo   Ensure preselected is cookied
         * @access protected
         * @return void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareFacebookRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _removeConnections
         * 
         * @access protected
         * @return void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access protected
         * @return void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            this._form.on({
                'submitted': function() {
                    _this._modal.pause();
                },
                'returned': function() {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * setMessage
         * 
         * @todo   Match truncation for links in Facebook preview:
         *         https://i.imgur.com/WDJDlvy.png
         * @access public
         * @param  String message
         * @return void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://www.facebook.com/hashtag/$hashtag'
            });
            message = message.replace(/\n{2,}/g, '\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access public
         * @param  String state
         * @return void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo   Preload all conncetion urls into memory for faster
         *         transitions between them
         * @access public
         * @return void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $images = this.find('[lookup="connection.image"]');
                $names.text(selected.get('label'));
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * InstagramShareView
     * 
     * @extends NetworkShareView
     */
    window.InstagramShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $input
                     * @return void
                     */
                    '[type="tel"]': function(event, $input) {
                        this.find('[name="data[number]"]').val(
                            $input.intlTelInput('getNumber')
                        );
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'instagram')
         */
        _network: 'instagram',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'InstagramShareView')
         */
        _string: 'InstagramShareView',

        /**
         * init
         * 
         * @todo   Ensure action for this view cannot be initiated until after
         *         the image has been uploaded:
         *         eg: image.get('uploaded').toInt() === 1
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupForm();
            this.preview('desktop', false);
            this._setupMobileInput();
        },

        /**
         * _setupMobileInput
         * 
         * @note   Originally I was performing a Stencil.alive check before the
         *         Geo lookup, but that resulted in two things:
         *         1) In areas with firewalls (eg. Turkey), the Stencil.alive
         *         check would result in always showing a connection error.
         *         2) I don't believe a connection needs to be checked for
         *         first. Simply make the call, and if it bails, the connection
         *         check will come in.
         * @note   Alertnative Geo lookups:
         *         https://geoiplookup.wikimedia.org/
         *         https://freegeoip.net/json/?callback=captureCountryCode
         * @see    https://meta.wikimedia.org/wiki/Geo_IP_lookup
         * @todo!  Abstract utils.js to only be loaded if Instagram view is used
         * @access protected
         * @return void
         */
        _setupMobileInput: function() {

            // Input
            var $tel = this.find('input[type="tel"]');

            // GitHub Repo
            $tel.intlTelInput({
                // utilsScript: '/static/vendors/intl-tel-input-master/js/utils.js',
                defaultCountry: 'auto',
                preferredCountries: ['us', 'au', 'ca', 'gb', 'es'],
                geoIpLookup: function(callback) {
                    if (false) {
                        Stencil.ajax({
                            signature: {file: 'Instagram', line: 110},
                            sign: false,
                            url: 'https://bits.wikimedia.org/geoiplookup',
                            type: 'GET',
                            dataType: 'script',
                            cache: true,
                            success: function() {
                                callback(window.Geo.country);
                            }
                        });
                    } else if (true) {
                        window.captureCountryCode = function(response) {
                            callback(response.country_code.toLowerCase());
                            delete window.captureCountryCode;
                        };
                        Stencil.ajax({
                            signature: {file: 'Instagram', line: 126},
                            sign: false,
                            url: 'https://freegeoip.net/json/?callback=captureCountryCode',
                            type: 'GET',
                            dataType: 'script',
                            cache: true,
                            timeout: 2500,
                            error: function(jqXHR, textStatus, errorThrown) {
                                var geo = Stencil.get('account').geo();
                                if (geo === false) {
                                    callback('us');
                                } else {
                                    callback(geo.country.code.toLowerCase());
                                }
                            }
                        });
                    } else if (false) {
                        var geo = Stencil.get('account').geo();
                        if (geo === false) {
                            callback('us');
                        } else {
                            callback(geo.country.code.toLowerCase());
                        }
                    } else {
                        callback('us');
                    }
                }
            });

            // Number set
            if (Stencil.account().userAccount().setting('shareMobile') !== '') {
                this.find('[name="data[number]"]').val(
                    $tel.intlTelInput('getNumber')
                );
            }

            // Stripe
            // $input.mobilePhoneNumber({allowPhoneWithoutPrefix: '+1'});
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function() {
                    _this._modal.pause();
                    this._enabled = true;
                    if (Account.max.sms() === true && User.admin() === false) {
                    // if (true) {//&& User.admin() === false) {
                        this._enabled = false;
                        if (Account.upgraded() === true) {
                            if (Account.plan('unlimited') === true) {
                                Stencil.alert('account.unlimited.limit.sms');
                            } else {
                                Stencil.navigate('/app/upgrade/unlimited/sms?clean=1&additive');
                            }
                        } else {
                            Stencil.navigate('/app/upgrade/pro/sms?clean=1&additive');
                        }
                        this.enable.delay(0, this);
                        _this._modal.unpause();
                        this.find('a.button').removeAttr('disabled');
                        this.find('a.button').removeClass('busy');
                    }
                },
                'returned': function() {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    this.setErrorMessage(response.message);
                },
                'returned/succeeded': function(event, response) {
                    var path = _this._modal.getImage().getSentPath();
                    Stencil.navigate(path);

                    /**
                     * Track the messages sent this month and in total. This
                     * could be moved to the server.
                     */
                    var account = Stencil.account(),
                        monthlySentSmsMessages = account.get('monthlySentSmsMessages'),
                        totalSentSmsMessages = account.get('totalSentSmsMessages');
                    account.set({
                        'monthlySentSmsMessages': monthlySentSmsMessages + 1,
                        'totalSentSmsMessages': totalSentSmsMessages + 1
                    });
                    account.syncRefillData(function(changed) {
                        if (changed === true) {
                            this.set({
                                monthlySavedImages: this.get('monthlySavedImages').toInt(),
                                monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt() + 1,
                                totalSentSmsMessages: this.get('totalSentSmsMessages').toInt() + 1
                            });
                        }
                        this.save([
                            'monthlySentSmsMessages',
                            'totalSentSmsMessages'
                        ]);
                    });

                    /**
                     * Set mobile in accessor (saved on the backend by this
                     * point).
                     */
                    var userAccount = account.userAccount();
                    userAccount.set({
                        'settings.shareMobile': response.data.mobile
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * LinkShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.LinkShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access protected
         * @var    Boolean (default: false)
         */
        _drawn: false,

        /**
         * _image
         * 
         * @access protected
         * @var    ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {
                    'input': this.selectInput
                },
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'link')
         */
        _network: 'link',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'LinkShareView')
         */
        _string: 'LinkShareView',

        /**
         * init
         * 
         * @todo   Ensure action for this view cannot be initiated until after
         *         the image has been uploaded:
         *         eg: image.get('uploaded').toInt() === 1
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
        },

        /**
         * _getShareUrl
         * 
         * @access protected
         * @return String
         */
        _getShareUrl: function() {
            return '';
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access protected
         * @return void
         */
        _position: function() {
            var _this = this,
                image = new Image();
            image.onload = function() {
                var img = _this.find('img:not(.shadow)'),
                    width = img.css('width').toInt();
                _this.find('.shadow').css(
                    'margin-left',
                    0 - Math.round(width / 2)
                );
            };
            image.src = this._modal.getImage().getSrc();
        },

        /**
         * _setShortUrl
         * 
         * @access protected
         * @return void
         */
        _setShortUrl: function() {
            var image = this._getImage();
            if (image.setting('shortUrl') === '') {
                image.once({
                    'change/settings.shortUrl': this._setShortUrl.proxy(this)
                });
                image.generateShortUrl();
            } else {
                var shortUrl = image.setting('shortUrl');
                this.find('input[id="link"]').val(shortUrl);
                this.find('div.fields.placeholder').removeClass('placeholder');
                this.find('input:not(.placeholder)').focus();
            }
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access public
         * @return void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * selectInput
         * 
         * @access public
         * @return void
         */
        selectInput: function() {
            var input = this.find('input');
            (function() {
                input.select();
            }).delay(0);
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since LinkShareView doesn't require one. Also, the <_position> call
         * is needed for Link.
         * 
         * @access public
         * @return void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._setShortUrl();
            this._position();
            this.find('input:not(.placeholder)').focus();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * NetworkShareView
     * 
     * @events  show/desktop
     *          show/mobile
     * @extends View
     */
    window.NetworkShareView = View.extend({

        /**
         * _drawn
         * 
         * @access protected
         * @var    Object
         */
        _drawn: {
            desktop: false,
            mobile: false
        },

        /**
         * _modal
         * 
         * @access protected
         * @var    ShareModalView (default: null)
         */
        _modal: null,

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'NetworkShareView')
         */
        _string: 'NetworkShareView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
            this._drawn = {
                desktop: false,
                mobile: false
            };
            this.on({
                'show/desktop': function() {
                    this.preview('desktop', true);
                },
                'show/mobile': function() {
                    this.preview('mobile', true);
                }
            });
        },

        /**
         * _connections
         * 
         * @access protected
         * @return Array
         */
        _connections: function() {
            var _this = this;
            return Stencil.account().collection('connections').network(
                this._network
            );
        },

        /**
         * _getImage
         * 
         * @access protected
         * @return ImageAccessor
         */
        _getImage: function() {
            return this._modal.getImage();
        },

        // /**
        //  * _getImageUrl
        //  * 
        //  * @access protected
        //  * @return String
        //  */
        // _getImageUrl: function() {
        //     var image = this._getImage(),
        //         width = image.get('width');
        //     return this._getImage().url('scale', {
        //         width: width
        //     });
        // },

        /**
         * _getOriginalImageUrl
         * 
         * Returns the path to the original image on Cloudinary. This should
         * only be used by Buffer and Pinterest, to ensure they get the links to
         * the originally saved images.
         * 
         * @access protected
         * @return String
         */
        _getOriginalImageUrl: function() {
            return this._getImage().url('original');
        },

        /**
         * _getShareUrl
         * 
         * @access protected
         * @return String
         */
        _getShareUrl: function() {
            var key = this._getImage().get('key');
            return 'https://getstencil.com/p/' + (key);
        },

        /**
         * _getSnippet
         * 
         * @access protected
         * @param  Number limit
         * @return Object
         */
        _getSnippet: function(limit) {
            return this._getImage().getSnippet(limit);
        },

        /**
         * _showBusyModal
         * 
         * @access protected
         * @return void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },

        /**
         * drawImage
         * 
         * This function was intended to put less strain (read: memory
         * requirements) on the browser by only writing images when the user
         * requests a section and/or preview-tab that ought to show the image.
         * Specifically, I didn't want to write the base-64 encoded image data
         * in 9 different places if the user was only going to look at one, and
         * even more so, if they look at more than one, it's better to show the
         * image-src if the image has been uploaded by that point.
         * 
         * @access public
         * @param  String type
         * @return void
         */
        drawImage: function(type) {
            if (this._drawn[type] === false) {
                this._drawn[type] = true;
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    lookup = 'draw.' + (type),
                    selector = '[lookup="' + (lookup) + '"]',
                    $img = $('<img />');
                if (uploaded === 0 || preloaded === false) {
                // if (uploaded === 0) {

                    /**
                     * The below commented code works, but I'm not sure it
                     * should be used because of the following:
                     * 1. It's heavy. A Ghost canvas can be more than 1mb quite
                     *    easily. Considering that the image will likely only be
                     *    noticably blurry when it's a Pinterest frame, and
                     *    they're viewing Facebook/Twitter (where 100% width
                     *    stretching happens), it might not be worth the weight.
                     * 2. After X seconds the image will have been uploaded, so
                     *    it's likely okay to wait until then.
                     * 3. Listeners on Ghost are fine, but Ghost fires very
                     *    quickly. So without a secondary-access method for
                     *    the above <_getImageUrl> call, this Ghost listener
                     *    will only actually be run once for whatever network
                     *    and tab the user first hits. After that, the Preview
                     *    canvas data string will be used. Would need to be
                     *    build a helper method for this, which would touch a
                     *    lot of parts of the app.
                     */
                    // Canvases.Ghost.once({
                    //     'export': function(event, content) {
                    //         $img.attr('src', content);
                    //     }
                    // });

                    // Once preloaded, swap out the image src
                    this._getImage().once({
                        'preload': function(event) {
                            $img.attr('src', this.getSrc());
                        }
                    });
                }
                $img.attr('src', src);
                this.find(selector).replaceWith($img);
            }
        },

        /**
         * getNav
         * 
         * @access public
         * @return jQuery
         */
        getNav: function() {
            return this.find('aside nav');
        },

        /**
         * getPreview
         * 
         * @access public
         * @return jQuery
         */
        getPreview: function() {
            return this.find('aside div.preview');
        },

        /**
         * preview
         * 
         * @access public
         * @param  String type
         * @param  Boolean drawImage
         * @return void
         */
        preview: function(type, drawImage) {
            if (drawImage === true) {
                this.drawImage(type);
            }
            this.getNav().find('a').removeClass('active');
            this.getNav().find('a.' + (type)).addClass('active');
            this.getPreview().find('> section').addClass('hidden');
            this.getPreview().find('> section.' + (type)).removeClass('hidden');
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage('desktop');
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            Browser.tablet() === false && this._element.focusable().focus();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * PinterestShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.PinterestShareView = NetworkShareView.extend({

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'pinterest')
         */
        _network: 'pinterest',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PinterestShareView')
         */
        _string: 'PinterestShareView',

        /**
         * init
         * 
         * @todo   Ensure action for this view cannot be initiated until after
         *         the image has been uploaded:
         *         eg: image.get('uploaded').toInt() === 1
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupKeyEvents();
            this.preview('desktop', false);
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @acccess protected
         * @return  String
         */
        _getShareUrl: function() {
            var urlValue = this.find('[name="url"]').val();
            // if (urlValue.isUrl() === false) {
            //     return '';
            // }
            return urlValue;
        },

        /**
         * _setupKeyEvents
         * 
         * @acccess protected
         * @return  void
         */
        _setupKeyEvents: function() {
            var _this = this;
            this.find('input[name="url"]').on({
                'keydown': function(event) {
                    if (event.keyCode === 13) {
                        _this.triggerHandler('open');
                    }
                }
            });
        },

        /**
         * open
         * 
         * @note   Pinterest (oddly) truncates (by adding three dots) at 500 or
         *         greater characters. So I truncate at 499, with my own three
         *         dots, to ensure things are in sync.
         * @note   It's okay to exclude the description (eg. if there is none)
         * @access public
         * @return void
         */
        open: function() {
            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(499),
                    url = encodeURIComponent(this._getShareUrl()),
                    media = encodeURIComponent(this._getOriginalImageUrl()),
                    description = encodeURIComponent(snippetObject.snippet),
                    link = 'https://pinterest.com/pin/create/button/' +
                        '?url=' + (url) +
                        '&media=' + (media);
                if (snippetObject.default === false) {
                    link += '&description=' + (description);
                }
                window.open(
                    link,
                    'Pinterest Share',
                    'width=640, height=320'
                );
            } else {
                var msg = Stencil.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function() {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * TwitterShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.TwitterShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $textarea
                     * @return void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access protected
         * @var    String (default: 'twitter')
         */
        _network: 'twitter',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TwitterShareView')
         */
        _string: 'TwitterShareView',

        /**
         * _thresholds
         * 
         * @access protected
         * @var    Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!! Instead of having image-uploaded property checked on backend,
         *         check it here, and if it is not yet uploaded, wait for it
         *         (via event listener), and then submit form.
         * @access public
         * @param  jQuery element
         * @param  ShareModalView modal
         * @return void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on({
                'connection/add': function() {
                    this._showBusyModal();
                    var _this = this,
                        model = this._getModel('Twitter');
                    model.setup();
                    model.connect({
                        closed: function() {
                            App.getBusy().hide();
                        },
                        connected: function(connections) {
                            _this.state('connections');
                        }
                    });
                }
            });
            this._setupForm();
            this.preview('desktop', false);
            this._addCountListener();
            this._refreshCount();
            this._setupTooltips();

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _addCountListener
         * 
         * @access protected
         * @return void
         */
        _addCountListener: function() {
            this.on({
                'change/message': this._refreshCount
            });
        },

        /**
         * _drawConnections
         * 
         * @access protected
         * @return void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections = Stencil.render('TwitterConnections', {
                    live: connections.length > this._thresholds.search,
                    connections: connections
                });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access protected
         * @return void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareTwitterRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo   Ensure preselected is cookied
         * @access protected
         * @return void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareTwitterRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _refreshCount
         * 
         * @see    https://dev.twitter.com/rest/reference/get/help/configuration
         * @note   Count starts at 24 since an image is attached to the tweet
         * @access protected
         * @return void
         */
        _refreshCount: function() {
            var $textarea = this.find('textarea'),
                val = $textarea.val(),
                $status = this.find('.status'),
                $count = $status.find('[lookup="current"]'),
                count = 24;

            // Leading @ sign


            // Replace links with hardcoded-counts (23)
            count += val.replace(
                /h[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&~\?\/.=]+/g,
                '12345678901234567890123'
            // Twitter doesn't require http(s) when a trailing .com is found
            ).replace(
                /^[a-z0-9]+\.com(\s)/gi,
                '12345678901234567890123$1'
            ).replace(
                /(\s)[a-z0-9]+\.com(\s)/gi,
                '$112345678901234567890123$2'
            ).replace(
                /(\s)[a-z0-9]+\.com$/gi,
                '$112345678901234567890123'
            ).replace(
                /^[a-z0-9]+\.com$/gi,
                '12345678901234567890123'
            ).length;
            // ).replace(
            //     /^[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /^[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).length;

            // Twitter doesn't require http(s) when a trailing .com is found
//             count += val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             ).length;
// StencilBooter.log(
//     val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             )
// );
//             count += val.replace(
//                 /\s[a-z0-9]+\.com$/gi,
//                 '12345678901234567890123'
//             ).length;

            // Set count, along with UI for overage
            $count.text(count);
            $status.removeClass('red');
            if (count > 140) {
                $status.addClass('red');
            }
        },

        /**
         * _removeConnections
         * 
         * @access protected
         * @return void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access protected
         * @return void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            this._form.on({
                'submitted': function() {
                    _this._modal.pause();
                },
                'returned': function() {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        } else if (response.data.action === 'error') {
                            this.setErrorMessage(response.message);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                // container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * setMessage
         * 
         * This function is very peculiar. The goal is to have the preview look
         * exactly like how Twitter will render it. To that end, note the
         * following:
         * - Twitter will strip lead whitespace
         * - It will cap more than 2 newline characters to just 2
         * - It will strip trailing whitespace
         * 
         * @see    https://i.imgur.com/VTsHkJi.png
         *         https://i.imgur.com/p2Fg7a9.png
         *         Look into truncating url's to match how Twitter does it
         * @access public
         * @param  String message
         * @return void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://twitter.com/hashtag/$hashtag'
            });
            message = message.encode('username', {
                href: 'https://twitter.com/$username'
            });
            message = message.replace(/\n{2,}/g, '\n\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access public
         * @param  String state
         * @return void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo   Preload all conncetion urls into memory for faster
         *         transitions between them
         * @access public
         * @return void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $usernames = this.find('[lookup="connection.networkUserId"]'),
                    $images = this.find('[lookup="connection.image"]'),
                    label = '@' + (selected.get('label')),
                    raw = selected.getRaw(),
                    name = raw.name;

                // Inserts
                $names.text(name === undefined ? '' : name);
                $usernames.text(label);
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SidebarView
     * 
     * @extends View
     */
    window.SidebarView = View.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'SidebarView')
         */
        _string: 'SidebarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            // this._setupAuth();
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        // _setupAuth: function() {
        //     var _this = this;
        //     User.on('login', function(event, user) {
        //         if (User.admin() === true) {
        //             // _this._setupSpinner();
        //         }
        //     });
        // },

        // /**
        //  * _setupSpinner
        //  * 
        //  * @access protected
        //  * @return void
        //  */
        // _setupSpinner: function() {
        //     var $active = this.find('.active');
        //     $active.addClass('fa');
        //     $active.addClass('fa-refresh');
        //     $active.addClass('fa-spin');
        //     setInterval(
        //         function() {
        //             $active.addClass('hidden');
        //             if (Stencil.active() === true) {
        //                 $active.removeClass('hidden');
        //             }
        //         },
        //         250
        //     );
        // },

        /**
         * getNav
         * 
         * @access public
         * @return jQuery
         */
        getNav: function() {
            return this.find('nav');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * CanvasView
     * 
     * @see     http://rstgroup.github.io/fabricjs-viewport/
     *          Contains library to zoom in and out of a fabricjs canvas
     * @extends View
     */
    window.CanvasView = View.extend({

        /**
         * _cotton
         * 
         * Reference to the fabric.Canvas object.
         * 
         * @access protected
         * @var    null|fabric.Canvas (default: null)
         */
        _cotton: null,

        /**
         * _image
         * 
         * @access protected
         * @var    null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'CanvasView')
         */
        _string: 'CanvasView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * _setupCotton
         * 
         * @note   Had to add the moveCursor property to prevent the move cursor
         *         from showing up when the BackgroundRectangle layer was being
         *         accidentally dragged
         * @see    https://gist.github.com/paulkaplan/6050309
         * @access protected
         * @return void
         */
        _setupCotton: function() {
            this._cotton = new fabric.Canvas(
                this._element.get(0),
                {
                    controlsAboveOverlay: true,
                    moveCursor: 'default',
                    magnets: {
                        drawings: []
                    },
                    selection: false
                    // ,targetFindTolerance: 5
                }
            );
            // if (window.devicePixelRatio !== 1) {
            //     var canvas = this._element.get(0),
            //         width = canvas.width,
            //         height = canvas.height,
            //         ratio = window.devicePixelRatio;
            //     canvas.getContext('2d').scale(ratio, ratio);
            //     canvas.setAttribute('width', width * ratio);
            //     canvas.setAttribute('height', height * ratio);
            //     $(canvas).css({
            //         width: (width) + 'px',
            //         height: (height) + 'px'
            //     });
            // }
        },

        /**
         * drawLayers
         * 
         * Recursively draws layers onto the canvas since it may at time require
         * fetching further resources (eg. fonts, svg images, bitmap images,
         * etc). Also imortant for exporting (done via the Ghost canvas), since
         * the fully rendered image won't be available until it's assets have
         * been loaded.
         * 
         * @access public
         * @return void
         */
        drawLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    drawing.once({
                        'draw': function(event) {
                            if (index !== length - 1) {
                                next(index + 1);
                            } else {
                                _this.triggerHandler('draw');
                            }
                        }
                    });
                    drawing.draw();
                };
            next(0);
        },

        /**
         * getBackgroundImageLayer
         * 
         * @access public
         * @return BackgroundBitmapImageLayer
         */
        getBackgroundImageLayer: function() {
            var layers = this._image.getImageDocument().filter(
                function(index, layer) {
                    return layer.getProperty('background') === true
                        && layer.getProperty('type') === 'image';
                }
            );
            return layers[0];
        },

        /**
         * getBitmapImageLayers
         * 
         * Returns layers that are not the background, are images, and are not
         * vectors.
         * 
         * @access public
         * @return Array
         */
        getBitmapImageLayers: function() {
            var layers = this._image.getImageDocument().filter(
                function(index, layer) {
                    return layer.getProperty('background') !== true
                        && layer.getProperty('type') === 'image'
                        && layer.getProperty('vector') !== true;
                }
            );
            return layers;
        },

        /**
         * getCotton
         * 
         * @access public
         * @return fabric.Canvas
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getRenderedDimensions
         * 
         * @access public
         * @return Object
         */
        getRenderedDimensions: function() {
            var height = this._cotton.getHeight(),
                width = this._cotton.getWidth(),
                ratio = width / height;
            return {
                height: height,
                ratio: ratio,
                width: width
            };
        },

        /**
         * render
         * 
         * Reorders the drawn layers, assuming that the order in which they're
         * returned from getLayers is the order that they're desired via the UI.
         * 
         * A check is made against whether the drawings have successfully been
         * drawn, because it's possible that this method is called after a layer
         * has been added to the image document, but before it's been drawn. I
         * ran into this issue when I was a logged in user with more than one
         * watermark enabled. When I logged out, and then back in, one of the
         * calls below failed because the <cotton> property didn't yet exist.
         * The Canvas.render method was being triggered by the
         * WatermarkAccessor.addToCanvas method.
         * 
         * The renderFilters check is always made to prevent rendering files
         * when actions unrelated to a bitmap operation is made. Without this
         * check, when a filter is specified, running non-filter based
         * operations against the canvas would be super-slow, since it would be
         * doing bitmap operations each time.
         * 
         * @todo   Look into fabric's moveTo method. It may be useful for
         *         ordering layers.
         * @access public
         * @return void
         */
        render: function() {

            // Reorder layers, including backdrop (if any)
            this.set({
                'rendering': true
            });
            var imageDocument = this._image.getImageDocument(),
                layers = imageDocument.getLayers(true),
                drawing,
                cotton;
            jQuery.each(layers, function(index, layer) {
                drawing = layer.getDrawing();
                if (drawing.drawn() === true) {
                    cotton = drawing.getCotton();
                    if (layer.getProperty('type') === 'text') {
                        if (cotton.backdrop !== undefined) {
                            cotton.backdrop.bringToFront();
                            // cotton.backdrop.setCoords();
                        }
                    }
                    if (layer.getProperty('background') === undefined) {
                        cotton.bringToFront();
                    }
                    if (drawing.getOutline() !== null) {
                        drawing.getOutline().centers.top.bringToFront();
                        drawing.getOutline().centers.right.bringToFront();
                        drawing.getOutline().centers.bottom.bringToFront();
                        drawing.getOutline().centers.left.bringToFront();
                        drawing.getOutline().red.bringToFront();
                        drawing.getOutline().white.bringToFront();
                    }
                    // cotton.setCoords();
                }
            });

            // Determine if a filter-rendering is required on any layer
            var layer, index, filterLayersToRender = [], filterLayers = [],
                filters;
            for (index in layers) {
                layer = layers[index];
                filters = layer.getProperty('filters');
                if (filters !== undefined && filters.length > 0) {
                    filterLayers.push(layer);
                }
                if (layer.get('renderFilters') === true) {
                    filterLayersToRender.push(layer);
                }
            }

            // Post filter-rendering callback
            if (filterLayersToRender.length > 0) {
                var _this = this,
                    recursiveFilterRendering = function(layers) {
                        if (layers.length === 0) {
                            _this._cotton.renderAll();
                            _this.set({
                                'rendering': false
                            });
                            _this.triggerHandler('render');
                        } else {
                            var layer = layers.shift();
                            layer.sortFilters();
                            layer.getDrawing().once({
                                'applyFilters/complete': function(event) {
                                    recursiveFilterRendering(layers);
                                }
                            });
                            layer.getCotton().applyFilters();
                            layer.set({'renderFilters': false});
                        }
                    };
                recursiveFilterRendering(filterLayersToRender);
            } else {
                this._cotton.renderAll();
                this.set({
                    'rendering': false
                });
                this.triggerHandler('render');
            }
        },

        /**
         * getImage
         * 
         * @access public
         * @return ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * setImage
         * 
         * @access public
         * @param  ImageAccessor image
         * @return void
         */
        setImage: function(image) {
            this._image = image;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CanvasView', function() {

    /**
     * GhostCanvasView
     * 
     * @extends CanvasView
     */
    window.GhostCanvasView = CanvasView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'GhostCanvasView')
         */
        _string: 'GhostCanvasView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            window.Canvases.Ghost = this;
            this._setupCotton();
        },

        /**
         * _getExportMime
         * 
         * @access protected
         * @return String
         */
        _getExportMime: function() {
            var layer = this.getBackgroundImageLayer();
            if (layer.getProperty('image') === false) {
                return 'image/png';
            }
            return 'image/jpeg';
            // var layer = this.getBackgroundImageLayer();
            // if (layer.getProperty('image') !== false) {
            //     return 'image/jpeg';
            // }
            // var bitmapImageLayers = this.getBitmapImageLayers();
            // if (bitmapImageLayers.length > 0) {
            //     return 'image/jpeg';
            // }
            // return 'image/png';
        },

        /**
         * _resizeCanvas
         * 
         * Fabric.js automatically creates a secondary canvas behind the main
         * one. They do this to deal with retina issues: they want to ensure
         * that whatever is exported, it's optimized for the display (read
         * "number of pixels"). So in the case where the device pixel ratio
         * matches the minPixelDensity property of 2 set in the config file,
         * nothing needs to be done, since Fabric.js will create the proper
         * sized canves.
         * 
         * But in the case:
         * 1) The device has a lower device pixel ratio (eg. 1), the canvas
         *    is blown up to ensure that whatever download the user desires (
         *    eg. retina)
         * 2) The device has a higher device pixel ratio (eg. zoomed in to 2.2),
         *    the canvas is made a bit smaller to ensure whatever is downloaded
         *    fits the proper dimensions.
         * 
         * @access protected
         * @return void
         */
        _resizeCanvas: function() {
            var width = Frame.get('width'),
                height = Frame.get('height'),
                devicePixelRatio = window.devicePixelRatio,
                minDevicePixelRatio = Stencil.get('config').defaults.minPixelDensity.toInt();
            if (devicePixelRatio === minDevicePixelRatio) {
                this._cotton.resizeTo(width, height);
            } else {
                width *= (minDevicePixelRatio / devicePixelRatio);
                height *= (minDevicePixelRatio / devicePixelRatio);
                this._cotton.resizeTo(width, height);
            }
        },

        /**
         * _setupCotton
         * 
         * @access protected
         * @return void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('ghost-canvas-container');
        },

        /**
         * _syncBackgroundBitmapImage
         * 
         * @access protected
         * @param  Function callback
         * @return void
         */
        _syncBackgroundBitmapImage: function(callback) {
            var layer = this.getBackgroundImageLayer(),
                key = layer.getProperty('image');
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                callback();
            } else {
                var accessor = Stencil.getAccessor(key);
                accessor.once({
                    'save': function(event, resource, asset) {
                        callback();
                    }
                });
                accessor.save();
            }
        },

        /**
         * draw
         * 
         * Waits for a background image, if defined, to be saved to the backend
         * to ensure a frame-dimension-specific background image can be loaded
         * (via Cloudinary). After that's completed, standard call to
         * <drawLayers> method.
         * 
         * @note   <clear> call to get rid of any previously drawn objects
         * @access public
         * @return void
         */
        draw: function() {
            this.once({
                'draw': function(event) {
                    this.render();
                }
            });
            this._cotton.clear();
            var layer = this.getBackgroundImageLayer(),
                key = layer.getProperty('image');
            if (key === false) {
                this.drawLayers();
            } else {
                this._syncBackgroundBitmapImage(this.drawLayers.proxy(this));
            }
        },

        /**
         * export
         * 
         * @access public
         * @param  false|String mime
         * @param  Boolean scaleForRetina
         * @return void
         */
        export: function(mime, scaleForRetina) {
            mime = mime === false ? this._getExportMime() : mime;
            this.time('export');

            // Numbers based on device pixel ratio and retina desire
            var minDevicePixelRatio = Stencil.get('config').defaults.minPixelDensity.toInt(),
                multiplier = 0.5,
                width = Frame.get('width').toInt() * minDevicePixelRatio,
                height = Frame.get('height').toInt() * minDevicePixelRatio;
            if (scaleForRetina === true) {
                multiplier = 1;
            }

            // Export and trigger event
            window.exportingMultiplier = multiplier;
            var content = this._cotton.toDataURL({
                format: mime === 'image/jpeg' ? 'jpeg' : 'png',
                quality: 1,
                multiplier: multiplier,
                left: 0,
                top: 0,
                width: width,
                height: height
            });
            delete window.exportingMultiplier;

            // 
            this.time('export');
            this.triggerHandler('export', [content, mime]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CanvasView', function() {

    /**
     * PreviewCanvasView
     * 
     * @extends CanvasView
     */
    window.PreviewCanvasView = CanvasView.extend({

        /**
         * _events
         * 
         * Behinds a number of events to the app. This works a bit differently
         * than other views, in that events are sometimes bound to other view
         * elements, as well as elements that aren't selected via the
         * traditional <find> method.
         * 
         * @access protected
         * @var    Function
         */
        _events: function() {
            return {

                /**
                 * center.snap
                 * 
                 * @access protected
                 * @return void
                 */
                'center.snap': function() {
                    var $app = App.getElement();
                    this._cotton.on({
                        'mouse:up': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:moving': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:modified': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        }
                    });
                },

                /**
                 * body.click
                 * 
                 * Listeners for mousedown events to allow the selected layer to
                 * be blurred, so long as anything other than the text toolbar
                 * is clicked. When the toolbar is clicked, simply force the
                 * selected layer out of editing mode.
                 * 
                 * @access protected
                 * @return void
                 */
                'body.click': function() {
                    var $app = App.getElement();
                    $app.on({
                        'mousedown': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                if (Stencil.get('ignoreMouseDownLayerBlur') !== true) {
                                    var $target = $(event.target),
                                        drawing = layer.getDrawing();
                                    if ($target.parents('.toolbar.text').length === 1) {
                                        drawing.getCotton().exitEditing();
                                    } else if ($target.parents('.toolbar').length !== 1) {
                                        if ($target.tag() !== 'canvas') {
                                            // drawing.getCotton().exitEditing();
                                            canvas.getCotton().discardActiveObject();
                                            canvas.setSelectedLayer(false);
                                            drawing.bb.hide.apply(drawing);
                                            Toolbars.hide();
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.click
                 * 
                 * Ensures the selected layer is blurred when the canvas is
                 * clicked on, and another fabric object is focused, or simply
                 * the canvas itself is focused on. The key here being that the
                 * selected object's fabric object is _not_ the target event
                 * that's clicked on.
                 * 
                 * @access protected
                 * @return void
                 */
                'canvas.click': function() {
                    this._cotton.on({
                        'mouse:down': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                var drawing = layer.getDrawing();
                                if (event.target !== drawing.getCotton()) {
                                    canvas.setSelectedLayer(false);
                                    drawing.bb.hide.apply(drawing);
                                    Toolbars.hide();
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.dblclick
                 * 
                 * Allows for double-click insertion of an empty text layer.
                 * 
                 * @access protected
                 * @return void
                 */
                'canvas.dblclick': function() {
                    App.find('canvas#preview').parent().on({
                        'dblclick': function(event) {
                            var $target = $(event.target);
                            if ($target.parent('.busy.modal').length === 0) {
                                var canvas = Canvases.Preview,
                                    selected = canvas.getSelectedLayer();
                                if (
                                    selected === false
                                    || selected.toString() === 'BackgroundRectangleLayer'
                                    || selected.toString() === 'BackgroundBitmapImageLayer'
                                ) {
                                    // Position of click
                                    var options = {
                                        left: ((event.offsetX / canvas.getCotton().getWidth()) * 100).round(4),
                                        top: ((event.offsetY / canvas.getCotton().getHeight()) * 100).round(4)
                                    };

                                    // Add layer
                                    var layer = canvas.addTextLayer(options),
                                        drawing = layer.getDrawing();
                                    layer.setChangeOperationType('added');
                                    drawing.once({
                                        'draw': function(event) {
                                            this.select();
                                            drawing.animate();
                                            // cotton.enterEditing();
                                            // cotton.selectAll();
                                        }
                                    });
                                    drawing.draw();
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.rclick
                 * 
                 * @access protected
                 * @return void
                 */
                'canvas.rclick': function() {
                    App.find('canvas#preview').parent().on({
                        'contextmenu': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                var drawing = layer.getDrawing();
                                if (drawing.toString() === 'TextDrawing') {
                                    Stencil.alert('canvas.text.rclick');
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.hover
                 * 
                 * @access protected
                 * @return void
                 */
                // 'canvas.hover': function() {
//                     var _this = this;
// StencilBooter.log(App.find('canvas#preview').siblings('canvas'));
//                     App.find('canvas#preview').siblings('canvas').on({
//                         'hover': function(event) {
//                             var layers = this._imageDocument.filter(function(index, layer) {
//                                 return layer.getStyle('order').toInt() >= 2;
//                             });
//                             StencilBooter.log(layers);
//                         }
//                     });
                // },

                /**
                 * canvas.render
                 * 
                 * Method to throttle requests to Footer.reset whenever the
                 * canvas is updated. Nice central place to do this.
                 * 
                 * @access protected
                 * @return void
                 */
                // 'canvas.render': function() {
                    // var callback = Footer.reset.proxy(Footer);
                    // this._cotton.on({
                    //     'after:render': _.throttle(callback, 75)
                    // });
                // },

                /**
                 * key.autoAlign
                 * 
                 * @access protected
                 * @return void
                 */
                'key.autoAlign': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.keyCode === 67) {
                                var $target = $(event.target);
                                if (
                                    $target.tag() !== 'input'
                                    || (
                                        $target.tag() === 'input'
                                        && $target.attr('type') !== 'text'
                                    )
                                ) {
                                    var layer = Canvases.Preview.getSelectedLayer();
                                    if (layer !== false) {
                                        var layerType = layer.toString();
                                        if (
                                            layerType !== 'BackgroundRectangleLayer'
                                            && layerType !== 'BackgroundBitmapImageLayer'
                                        ) {
                                            if (layerType === 'TextLayer') {
                                                var cotton = layer.getCotton();
                                                if (cotton.isEditing === false) {
                                                    layer.autoAlign();
                                                }
                                            } else {
                                                layer.autoAlign();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.delete
                 * 
                 * Allows for delete-key deletion. Checks whether a correct
                 * keyCode was detected, a layer is currently selected, and the
                 * user is currently not focused on a text input (since if they
                 * are, they may intend to delete a hex code value, rather than
                 * the layer).
                 * 
                 * @access protected
                 * @return void
                 */
                'key.delete': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.keyCode === 8 || event.keyCode === 46) {
                                var layer = Canvases.Preview.getSelectedLayer();
                                if (layer !== false) {
                                    if (layer.toString() === 'BackgroundBitmapImageLayer') {
                                        var $target = $(event.target);
                                        if (
                                            $target.tag() !== 'input'
                                            || (
                                                $target.tag() === 'input'
                                                && $target.attr('type') !== 'text'
                                            )
                                        ) {
                                            event.preventDefault();
                                            var canvas = Canvases.Preview;
                                            ChangeHistory.clearOperationType();
                                            layer.setChangeOperationType('deleted');
                                            canvas.clearBackgroundImageLayer();
                                            canvas.render();
                                            canvas.getBackgroundRectangleLayer().select();
                                        }
                                    } else if (layer.toString() !== 'BackgroundRectangleLayer') {
                                        var drawing = layer.getDrawing();

                                        /**
                                         * There was a bug whereby if the user
                                         * highlighted text by dragging, and
                                         * their mouse ended up outside the
                                         * canvas, clicking delete would delete
                                         * the whole text field. I account for
                                         * this by checking if the fabric object
                                         * is currently being edited below, in
                                         * cases where the drawing is a
                                         * TextDrawing object.
                                         */
                                        if (
                                            drawing.toString() !== 'TextDrawing'
                                            || drawing.getCotton().isEditing === false
                                        ) {
                                            var $target = $(event.target);
                                            if (
                                                $target.tag() !== 'input'
                                                || (
                                                    $target.tag() === 'input'
                                                    && $target.attr('type') !== 'text'
                                                )
                                            ) {
                                                event.preventDefault();
                                                layer.triggerHandler('delete', [
                                                    {
                                                        trigger: 'key.delete'
                                                    }
                                                ]);
                                            }
                                        }

                                        /**
                                         * 
                                         */
                                        if (layer.toString() === 'WatermarkBitmapImageLayer') {
                                            layer.getWatermark().set({
                                                'settings.active': 0
                                            });
                                            layer.getWatermark().save([
                                                'settings.active'
                                            ]);
                                        }
                                    } else {
                                        var $target = $(event.target);
                                        if (
                                            $target.tag() !== 'input'
                                            || (
                                                $target.tag() === 'input'
                                                && $target.attr('type') !== 'text'
                                            )
                                        ) {
                                            event.preventDefault();
                                            var backgroundColor = layer.getStyle('backgroundColor');
                                            backgroundColor = backgroundColor.addSpacesToRgba();
                                            if (backgroundColor !== 'rgba(0, 0, 0, 0)') {

                                                /**
                                                 * It's important that the color
                                                 * value is formatted exactly as
                                                 * it is below (including
                                                 * spaces), because the rest of
                                                 * the platform formats things
                                                 * this way, and if the
                                                 * formatting is different, it
                                                 * can cause issues with the
                                                 * ChangeHistory system (since
                                                 * it might think something is
                                                 * different in the image, even
                                                 * if it's just formatting).
                                                 */
                                                var white = 'rgba(255, 255, 255, 1)';
                                                if (backgroundColor === white) {
                                                    Toolbars.backgroundRectangle.triggerHandler('clear/backgroundColor');
                                                } else {
                                                    Canvases.Preview.getSelectedLayer().triggerHandler(
                                                        'change/backgroundColor',
                                                        [white, true]
                                                    );
                                                    Toolbars.backgroundRectangle.show();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.directional
                 * 
                 * Allows for directional-key-based positioning. Directional
                 * keys in this case are the up, down, right and left keys.
                 * 
                 * @access protected
                 * @return void
                 */
                'key.directional': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            var layer = Canvases.Preview.getSelectedLayer();
                            if (
                                layer !== false
                                && layer.toString() !== 'BackgroundBitmapImageLayer'
                                && layer.toString() !== 'BackgroundRectangleLayer'
                            ) {
                                var $target = $(event.target);
                                if (
                                    $target.tag() !== 'input'
                                    || (
                                        $target.tag() === 'input'
                                        && $target.attr('type') !== 'text'
                                    )
                                ) {
                                    // Left
                                    if (event.keyCode === 37) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/left');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Up
                                    else if (event.keyCode === 38) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/up');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Right
                                    else if (event.keyCode === 39) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/right');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Down
                                    else if (event.keyCode === 40) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/down');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.enter
                 * 
                 * Allows for enter-key-based text editing.
                 * 
                 * @access protected
                 * @return void
                 */
                'key.enter': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.keyCode === 13) {
                                var canvas = Canvases.Preview,
                                    layer = canvas.getSelectedLayer();
                                if (layer !== false) {
                                    var drawing = layer.getDrawing();
                                    if (drawing.toString() === 'TextDrawing') {
                                        if (layer.getCotton().isEditing === false) {
                                            var $target = $(event.target);
                                            if (
                                                $target.tag() !== 'input'
                                                || (
                                                    $target.tag() === 'input'
                                                    && $target.attr('type') !== 'text'
                                                )
                                            ) {
                                                event.preventDefault();
                                                var cotton = layer.getCotton();
                                                layer.select();
                                                canvas.render();
                                                // canvas.getCotton().setActiveObject(cotton);
                                                cotton.enterEditing();
                                                cotton.selectAll();
                                            }
                                        }
                                    } else {
                                        if (drawing.toString() === 'BackgroundRectangleDrawing') {
                                            var $target = $(event.target);
                                            if (
                                                $target.tag() !== 'input'
                                                || (
                                                    $target.tag() === 'input'
                                                    && $target.attr('type') !== 'text'
                                                )
                                            ) {
                                                event.preventDefault();
                                                var layer = canvas.addTextLayer(),
                                                    drawing = layer.getDrawing();
                                                layer.setChangeOperationType('added');
                                                drawing.once({
                                                    'draw': function(event) {
                                                        this.select();
                                                        drawing.animate();
                                                    }
                                                });
                                                drawing.draw();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.escape
                 * 
                 * Allows for escape-key blurring of layer. Requires the
                 * following:
                 * - Escape key pressed (code: 27)
                 * - Layer selected
                 * - Layer not in editing mode (incase text)
                 * - Target element when key pressed down is not an <input>
                 *   element,
                 *   or it's got a type of "range" or "checkbox"
                 * - Dropdown menu for fonts not open (since escape key here is
                 *   more important from a UX perspective).
                 * 
                 * @access protected
                 * @return void
                 */
                'key.escape': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.keyCode === 27) {
                                var canvas = Canvases.Preview,
                                    layer = canvas.getSelectedLayer();
                                if (layer !== false) {
                                    var drawing = layer.getDrawing(),
                                        cotton = layer.getCotton(),
                                        $target = $(event.target);
                                    if (drawing.toString() === 'TextDrawing') {
                                        if (cotton.isEditing === false) {
                                            if (
                                                (
                                                    $target.tag() !== 'input'
                                                    || $target.attr('type') === 'range'
                                                    || $target.attr('type') === 'checkbox'
                                                )
                                                /**
                                                 * This is to prevent a bug that
                                                 * comes up when leaving the
                                                 * GoogleFonts modal. Leaving it
                                                 * causes focus to be made on
                                                 * the search input of the
                                                 * active editor tab, which is
                                                 * naturally an input tag. So we
                                                 * check for that here.
                                                 * 
                                                 * @see https://i.imgur.com/bZn6Gm1.png
                                                 */
                                                || (
                                                    $target.hasClass('search') === true
                                                )
                                            ) {
                                                if (
                                                    Toolbars.text.getFontsDropdown().getElement().hasClass('open') === false
                                                ) {
                                                    event.preventDefault();
                                                    canvas.getCotton().discardActiveObject();
                                                    canvas.setSelectedLayer(
                                                        false
                                                    );
                                                    drawing.bb.hide.apply(drawing);
                                                    Toolbars.hide();
                                                }
                                            }
                                        }
                                        /**
                                         * This is a fix to a fabric bug,
                                         * whereby if the user started
                                         * editing a text drawing,
                                         * highlighted some text, but during
                                         * that highlight process their
                                         * mouse left the canvas, clicking
                                         * the escape key woud not do
                                         * anything. I believe the issue
                                         * exists because fabric is
                                         * listening for events in the
                                         * canvas, which can't be accessed
                                         * in this case because the event is
                                         * happening elsewhere (the html
                                         * element outside of the canvas).
                                         * So to deal with this, I just
                                         * ensure the layer exits editing
                                         * mode.
                                         */
                                        else {
                                            cotton.exitEditing();
                                            drawing.select();
                                            // canvas.getCotton().setActiveObject(cotton);
                                        }
                                    } else {

                                        /**
                                         * Prevents escaping when, for
                                         * example, the user is changing the
                                         * color of a vector, and tries to
                                         * blur focus from the color picker.
                                         */
                                        if (
                                            $target.tag() !== 'input'
                                            || $target.attr('type') === 'range'
                                        ) {
                                        // if ($target.tag() !== 'input') {
                                            event.preventDefault();
                                            canvas.getCotton().discardActiveObject();
                                            canvas.setSelectedLayer(false);
                                            drawing.bb.hide.apply(drawing);
                                            Toolbars.hide();
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.tab
                 * 
                 * Allows for tabbing and shift-tabbing between layers.
                 * 
                 * @access protected
                 * @return void
                 */
                'key.tab': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.keyCode === 9) {
                                var layer = Canvases.Preview.getSelectedLayer();
                                if (layer !== false) {
                                    event.preventDefault();
                                    if (event.shiftKey === true) {
                                        layer.goto.previous.apply(layer);
                                    } else {
                                        layer.goto.next.apply(layer);
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * watermark.activate
                 * 
                 * @access protected
                 * @return void
                 */
                'watermark.activate': function() {
                }
            };
        },

        /**
         * _fabricGuides
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _fabricGuides: {},

        /**
         * _facebookAdGrid
         * 
         * @access protected
         * @var    Object (default: [])
         */
        // _facebookAdGrid: [],

        /**
         * _htmlGuides
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _htmlGuides: {},

        /**
         * _max
         * 
         * Object that has the maximum size of the canvas defined. There are
         * three possible hashes. <absolute> defines the maximum across browser
         * resolutions, <viewport> defines the maximum values according to the
         * space within the canvas container (after instantiation). Defined
         * defines what should be actually used during canvas drawing/resizing.
         * 
         * This will be defined by:
         * - Math.min(absolute.height, viewport.height)
         * - Math.min(absolute.width, viewport.width)
         * 
         * @access protected
         * @var    Object
         */
        _max: {
            absolute: {
                // height: 600,
                // width: 600
                height: 900,
                width: 900
            },
            defined: {
                height: false,
                width: false
            },
            viewport: {
                height: false,
                width: false
            }
        },

        /**
         * _positionMap
         * 
         * Tracks the position of background images, within the context of a
         * Frame, so that if a user sets a position in, for example, a Pinterest
         * Frame, switches to a Facebook one, sets the background image position
         * relative to that Frame, and then switches back, it remembers where
         * the background image was (manully, purposefully) set for the
         * Pinterest one.
         *
         * Without this, it can feel disjointed when you position your
         * background image, switch to a frame and think "Ahh, I don't want this
         * one", switch back, and now your background image isn't set to where
         * it was before.
         * 
         * An exception here is if the user loads the app, sees a background
         * image in a specific place, switches to a different Frame before
         * adjusting the position of the background image at all, adjusts the
         * background image in that new Frame, and then switches back to the
         * first one, the background image will be adjusted relative to the
         * positioning data for the second Frame. This is because this hash
         * won't contain any data on the initial Frame, since the user didn't
         * interact with it.
         * 
         * I could update this to ensure this data is present as soon as an
         * image is set as a background image on a Frame, but not sure if that's
         * needed.
         * 
         * Frame positioning works in such a way that it'll always try to
         * best-guess the position of a background image relative to a frame
         * since the position coordinates (left/top) are relative numbers.
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _positionMap: {},

        /**
         * _previouslySelectedLayer
         * 
         * Tracks the previously selected layer, for usage with font preview
         * closing.
         * 
         * @access protected
         * @var    Layer (default: false)
         */
        _previouslySelectedLayer: false,

        /**
         * _selectedLayer
         * 
         * @access protected
         * @var    Layer (default: false)
         */
        _selectedLayer: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'PreviewCanvasView')
         */
        _string: 'PreviewCanvasView',

        /**
         * init
         * 
         * @see    http://alvarotrigo.com/blog/firing-resize-event-only-once-when-resizing-is-finished/
         * @note   Order here is very important
         * @todo   Don't run a refresh if the canvas size hasn't actually
         *         changed. Waste of resources.
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupCotton();
            window.Canvases.Preview = this;
            this._setupFabricGuides();
            // this._setupHtmlGuides();
            this._setMaximumsDimensions();
            this._setupAuth();
            this._setupEvents();
            // this._listenForLockedChange();
        },

        /**
         *_listenForLockedChange
         * 
         * @access protected
         * @return void
         */
       // _listenForLockedChange: function() {
       //      Stencil.account().draft().on({
       //          'change/settings.locked': function(event, value) {
       //              var $lock = App.getStage().getContent().find('div.sandbox a.lock');
       //              $lock.addClass('hidden');
       //              if (value.toInt() === 1) {
       //                  $lock.removeClass('hidden');
       //              }
       //          }
       //      });
       //  },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var unlockLayers = function() {
                var lockedLayers = Stencil.account().draft().getImageDocument().getLockedLayers();
                if (lockedLayers.length > 0) {
                    jQuery.each(lockedLayers, function(index, layer) {
                        layer.setProperty('locked', false);
                    });
                }
            };
            User.once({
                'login': function(event, user) {
                    if (User.admin() === true || Account.upgraded() === true) {
                        unlockLayers();
                    }
                }
            });
            Account.once({
                'upgrade': unlockLayers
            });
        },

        /**
         *_setupEvents
         * 
         * @access protected
         * @return void
         */
       _setupEvents: function() {
            var _this = this;
            this._events = this._events();
            jQuery.each(
                this._events,
                function(type, event) {
                    event.apply(_this);
                }
            );
        },

        /**
         * _setupCotton
         * 
         * @access protected
         * @return void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('preview-canvas-container');
        },

        /**
         * _setupFabricGuides
         * 
         * @access protected
         * @return void
         */
        _setupFabricGuides: function() {
            var options = {
                    visible: false,
                    strokeDashArray: [5, 5],
                    // stroke: '#aaa',
                    stroke: 'rgba(0, 0, 0, 0.65)',
                    selectable: false,
                    strokeWidth: 1
                },
                horizontal = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ],
                vertical = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ];
            this._cotton.add(horizontal[0]);
            this._cotton.add(horizontal[1]);
            this._cotton.add(vertical[0]);
            this._cotton.add(vertical[1]);

            // Backgrounds
            options.stroke = 'rgba(255, 255, 255, 0.65)';
            options.strokeDashArray = false;
            var backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            horizontal[0].backdrop = backdrop[0];
            horizontal[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);
            backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            vertical[0].backdrop = backdrop[0];
            vertical[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);

            // 
            this._fabricGuides.vertical = vertical;
            this._fabricGuides.horizontal = horizontal;

            // 
            this._cotton.on({
                'mouse:move': function(options) {
                    vertical[0].set('visible', false);
                    vertical[1].set('visible', false);
                    vertical[0].backdrop.set('visible', false);
                    vertical[1].backdrop.set('visible', false);
                    horizontal[0].set('visible', false);
                    horizontal[1].set('visible', false);
                    horizontal[0].backdrop.set('visible', false);
                    horizontal[1].backdrop.set('visible', false);
                }
            });
        },

        /**
         * _setupHtmlGuides
         * 
         * @access protected
         * @return void
         */
        _setupHtmlGuides: function() {
            var $app = App.getElement();
            this._cotton.on({
                'object:moving': function(options) {
                    var $guides = $app.find('div.guides');
                    $guides.find('div.guide').addClass('hidden');
                }
            });
        },

        /**
         * _setMaximumsDimensions
         * 
         * This method sets the maximum possible width and height that a canvas
         * can be set to. Values are set to be the lowest between the viewport
         * (set to a maximum of 70% of available space) and an absolute defined
         * Stencil-wide.
         * 
         * @access protected
         * @return void
         */
        _setMaximumsDimensions: function() {
            var $content = App.find('section.stage > div.inner > div.content'),
                $outer = $content.find('> div.outer'),
                height,
                width;
            $outer.addClass('hidden');
            height = $content.height();
            width = $content.width();
            $outer.removeClass('hidden');
            this._max.viewport = {
                // height: Math.floor(height * 0.7),
                height: Math.floor(height * 0.75),
                // width: Math.floor(width * 0.7)
                width: Math.floor(width * 0.85)
            };
            this._max.defined.height = Math.min(
                this._max.absolute.height,
                this._max.viewport.height
            );
            this._max.defined.width = Math.min(
                this._max.absolute.width,
                this._max.viewport.width
            );
        },

        /**
         * _resizeCanvas
         * 
         * @access protected
         * @return void
         */
        _resizeCanvas: function() {

            // Get maximum dimension allowed
            var max = this._max.defined,
                ratio = Frame.getRatio(),
                width, height;

            // Square: just set to the lowest of the max width/height
            if (ratio === 1) {
                width = height = Math.min(max.height, max.width);
            } else {

                // Wide rectangle
                var scale;
                if (ratio > 1) {

                    // Frame width is smaller than max allowed
                    if (Frame.get('width').toInt() < max.width) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame width is larger than max allowed
                    else {
                        width = max.width;
                        scale = Frame.get('width').toInt() / width;
                        height = Frame.get('height').toInt() / scale;

                        // Converted/relative height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                }
                // Tall rectangle
                else {

                    // Frame height is smaller than max allowed
                    if (Frame.get('height').toInt() < max.height) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame width is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame height is larger than max allowed
                    else {
                        height = max.height;
                        scale = Frame.get('height').toInt() / height;
                        width = Frame.get('width').toInt() / scale;

                        // Converted/relative widht is larger than max allowed
                        if (width > max.width) {
                            width = max.width;
                            scale = Frame.get('width').toInt() / width;
                            height = Frame.get('height').toInt() / scale;
                        }
                    }
                }
            }

            // Resize to maximum allowed
            this._cotton.resizeTo(width.ceil(), height.ceil());
        },

        /**
         * addTextLayer
         * 
         * @access public
         * @param  Object options
         * @return TextLayer
         */
        addTextLayer: function(options) {
            options = options || {};
            var properties = {
                    locked: false,
                    styles: {
                        align: options.align || 'center',
                        angle: 0,
                        // backdropColor: '#00ff00',
                        backdropColor: false,
                        backdropPaddingFactor: Stencil.get('config').defaults.backdropPaddingFactor,
                        backdropStretch: 'slim',
                        bold: false,
                        // fontFamily: options.fontFamily || Stencil.get('config').defaults.font,
                        fontFamily: options.fontFamily || Stencil.account().setting('defaultFontFamily'),
                        fontSize: options.fontSize || 50,
                        italic: false,
                        left: options.left || 50,
                        lineHeight: 1.1,
                        shadowStrength: 0,
                        strokeColor: false,
                        strokeWidthDividingFactor: Stencil.get('config').defaults.strokeWidthDividingFactor,
                        // textColor: 'rgba(69, 69, 69, 1)',// #454545
                        textColor: 'rgba(0, 0, 0, 1)',// #000000
                        top: options.top || 50,
                        underline: false,
                        width: options.width || 30
                    },
                    // text: 'I repeat. We are out of Bort license plates!',
                    text: options.text || 'Text',
                    type: 'text'
                },
                textLayers = this._image.getImageDocument().getTextLayers(),
                layer;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;

            // Inheritance
            if (textLayers.length > 0) {
                var index = textLayers.length - 1;
                if (options.align === undefined) {
                    properties.styles.align = textLayers[index].getStyle('align');
                }
                properties.styles.bold = textLayers[index].getStyle('bold');
                if (options.align === undefined) {
                    properties.styles.fontFamily = textLayers[index].getStyle('fontFamily');
                }
                if (options.fontSize === undefined) {
                    properties.styles.fontSize = textLayers[index].getStyle('fontSize');
                }
                properties.styles.italic = textLayers[index].getStyle('italic');
                properties.styles.lineHeight = textLayers[index].getStyle('lineHeight');
                properties.styles.textColor = textLayers[index].getStyle('textColor');
            }

            // Create and run overhead
            layer = new TextLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            // layer.getDrawing().draw();
            return layer;
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @access public
         * @param  Object options
         * @return ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(options) {
            options = options || {};
            var properties = {
                    filters: [],
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 15
                    },
                    type: 'image'
                },
                layer;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;
            layer = new ForegroundBitmapImageLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addVectorImageLayer
         * 
         * Sets the color of the added vector to either the default, or else if
         * a vector has already been drawn to the canvas, grabs that color
         * (which makes a large assumption).
         * 
         * @access public
         * @param  Object options
         * @return VectorImageLayer
         */
        addVectorImageLayer: function(options) {
            options = options || {};
            var properties = {
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        fillColor: 'rgba(0, 0, 0, 1)',
                        // fillColor: 'rgba(255, 0, 0, 1)',
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 15
                    },
                    type: 'image',
                    vector: true
                },
                vectorImageLayers = this._image.getImageDocument().getVectorImageLayers(),
                layer;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;

            // Inheritance
            if (vectorImageLayers.length > 0) {
                var index = vectorImageLayers.length - 1;
                properties.styles.fillColor = vectorImageLayers[index].getStyle('fillColor');
            }

            // Overhead
            layer = new VectorImageLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addWatermarkBitmapImageLayer
         * 
         * @access public
         * @param  Object properties
         * @return WatermarkBitmapImageLayer
         */
        addWatermarkBitmapImageLayer: function(properties) {
            properties.locked = false;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers().length;
            layer = new WatermarkBitmapImageLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addWindowResizeListener
         * 
         * @access public
         * @return void
         */
        addWindowResizeListener: function() {
            var delay = Stencil.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'resize': callback
            });
        },

        /**
         * addWindowOrientationChangeListener
         * 
         * Listener for orientation change needed to happen, because at times on
         * Adam's iPad, the resize function would not be triggered when he
         * changed his orientation. So to be safe, I trigger a resize on
         * orientation change as well.
         * 
         * Not sure if this will cause a problem since resize might be called
         * twice (especially since the debounce reference is different). Might
         * want to look into this, or else use a common debounce reference.
         * 
         * @todo   Look into the note above on possibly multiple calls to
         *         resize.
         * @access public
         * @return void
         */
        addWindowOrientationChangeListener: function() {
            var delay = Stencil.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'orientationchange': callback
            });
        },

        /**
         * clear
         * 
         * Filter here is made against the position being greater than
         * or equal to two. This is because the first two layers are the
         * BackgroundRectangleLayer and BackgroundBitmapImageLayer.
         * 
         * Note that I need to perform a set + save against the sourceImageId
         * property, rather than a push, because a push does a checks
         * 
         * @access public
         * @param  Boolean prompt
         * @param  undefined|String promptType
         * @return void
         */
        clear: function(prompt, promptType) {

            /**
             * callback
             * 
             * @access private
             * @param  Boolean clearWatermarks
             * @return void
             */
            var callback = function(clearWatermarks) {
                var layers = this._image.getImageDocument().getOrderedLayers(
                    clearWatermarks === true
                );
                jQuery.each(layers, function(index, layer) {
                    layer.triggerHandler('delete');
                    if (layer.toString() === 'WatermarkBitmapImageLayer') {
                        layer.getWatermark().push('settings.active', 0);
                    }
                });
                this.resetBackgroundRectangleLayer();
                this.clearBackgroundImageLayer();
                this.render();
                var draft = Stencil.account().draft();
                draft.removeSourceImage();
                // if (Account.draftIsLocked() === true) {
                //     draft.set({
                //         'settings.locked': 0
                //     });
                //     draft.save(['settings.locked']);
                // }
            };

            /**
             * 
             */
            if (prompt === true) {
                var _this = this;
                if (promptType === 'unsaved') {
                    this.unsavedChangesClearCanvasConfirm().on({
                        'yes': function() {
                            ChangeHistory.setOperationType('image // newImage:created');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                } else {
                    this.clearCanvasConfirm().on({
                        'yes': function() {
                            ChangeHistory.setOperationType('image // cleared');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                }
            } else {
                ChangeHistory.setOperationType('image // newImage:created');
                callback.apply(this, [false]);
            }
        },

        /**
         * clearCanvasConfirm
         * 
         * @access public
         * @return ConfirmModal
         */
        clearCanvasConfirm: function() {
            var h1 = 'Clearing will remove all images and text.',
                h2 = 'Are you sure?',
                modal = Modals.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function() {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * clearBackgroundImageLayer
         * 
         * @access public
         * @return void
         */
        clearBackgroundImageLayer: function() {
            var layer = this.getBackgroundImageLayer();
            layer.clearFilters();
            if (layer.getProperty('image') !== false) {
                layer.setImage(false);
            }

            // Clear OriginalBackgroundSizeFrame
            // var framer = App.getStage().getContent().getFramer(),
            //     frame = framer.getOriginalBackgroundSizeFrame();
            // frame.hide();
        },

        /**
         * draw
         * 
         * @access public
         * @param  Boolean showBusyModal This variable was introduced to offer
         *         up the option of not showing the busy modal when the image
         *         being redrawn was being done so through a redo / undo action
         * @return void
         */
        draw: function(showBusyModal) {
            var start = new Date();
            this.set({drawing: true});
            if (showBusyModal === true) {
                this.getBusy().show();
            }
            this._image.getImageDocument().mergeWatermarks();
            this._image.getImageDocument().setupLayers();//this);
            this._image.getImageDocument().sortLayers();
            // this._image.markConfigurationAsSaved();
            this.once({
                'draw': function(event) {
                    this.render();
                },
                'render': function(event) {
                    this.set({drawing: false});
                    if (showBusyModal === true) {
                        var busy = this.getBusy();
                        busy.hide.minDelay(start, 500, busy);
                    }
                }
            });
            this.drawLayers();
        },

        /**
         * getActiveBackgroundLayer
         * 
         * Returns the active background layer. Note that the active background
         * may not actually be selected. For example, the user could have a
         * text layer selected (eg. the TextToolbar is open), but calling this
         * method will return the BackgroundRectangleLayer if no image is set
         * as the background, or else the BackgroundBitmapImageLayer.
         * 
         * @access public
         * @return BackgroundBitmapImageLayer|BackgroundRectangleLayer
         */
        getActiveBackgroundLayer: function() {
            var backgroundBitmapImageLayer = this.getBackgroundBitmapImageLayer();
            if (backgroundBitmapImageLayer.getProperty('image') !== false) {
                return backgroundBitmapImageLayer;
            }
            return this.getBackgroundRectangleLayer();
        },

        /**
         * getBackgroundBitmapImageLayer
         * 
         * @access public
         * @return BackgroundBitmapImageLayer
         */
        getBackgroundBitmapImageLayer: function() {
            var layers = this._image.getImageDocument().filter(
                function(index, layer) {
                    return layer.getProperty('background') === true
                        && layer.getProperty('type') === 'image';
                }
            );
            return layers[0];
        },

        /**
         * getBackgroundRectangleLayer
         * 
         * @access public
         * @return BackgroundRectangleLayer
         */
        getBackgroundRectangleLayer: function() {
            var layers = this._image.getImageDocument().filter(
                function(index, layer) {
                    return layer.getProperty('background') === true
                        && layer.getProperty('type') === 'rectangle';
                }
            );
            return layers[0];
        },

        /**
         * getBusy
         * 
         * @access public
         * @return BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = Stencil.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.parent('.canvas-container').append($busy);
            }
            return this._busy;
        },

        /**
         * getFabricGuides
         * 
         * @access public
         * @return Object
         */
        getFabricGuides: function() {
            return this._fabricGuides;
        },

        /**
         * getHtmlGuides
         * 
         * @access public
         * @return Object
         */
        getHtmlGuides: function() {
            var $app = App.getElement(),
                $guides = $app.find('div.guides');
            return $guides.find('div.guide');
        },

        /**
         * getImageDocument
         * 
         * @access public
         * @return ImageDocument
         */
        // getImageDocument: function() {
        //     return this._image.getImageDocument();
        // },

        /**
         * getPreviouslySelectedLayer
         * 
         * @access public
         * @return Layer
         */
        getPreviouslySelectedLayer: function() {
            return this._previouslySelectedLayer;
        },

        /**
         * getSelectedLayer
         * 
         * @access public
         * @return Layer
         */
        getSelectedLayer: function() {
            return this._selectedLayer;
        },

        /**
         * repositionFacebookAdGrid
         * 
         * @access public
         * @return void
         */
        // repositionFacebookAdGrid: function() {
        //     var dimensions = this.getRenderedDimensions(),
        //         width = dimensions.width,
        //         height = dimensions.height;
        //     for (var index in this._facebookAdGrid) {
        //         this._facebookAdGrid[index].set({
        //             width: Math.floor(width / 5),
        //             height: Math.floor(height / 5)
        //         });
        //     }
        //     var rows = 5,
        //         columns = 5;
        //         x = 0,
        //         y = 0,
        //         current = 0;
        //     for (x; x < rows; x++) {
        //         for (y = 0; y < columns; y++) {
        //             this._facebookAdGrid[current].set({
        //                 left: 10,
        //                 top: 10
        //             });
        //             current++;
        //         }
        //     }
        // },

        /**
         * hideFacebookAdGrid
         * 
         * @access public
         * @return void
         */
        // hideFacebookAdGrid: function() {
            // for (var index in this._facebookAdGrid) {
            //     this._facebookAdGrid[index].set({visible: false});
            //     this._facebookAdGrid[index].bringToFront();
            // }
        // },

        /**
         * showFacebookAdGrid
         * 
         * @access public
         * @return void
         */
        // showFacebookAdGrid: function() {
            // for (var index in this._facebookAdGrid) {
            //     this._facebookAdGrid[index].set({visible: true});
            //     this._facebookAdGrid[index].bringToFront();
            // }
        // },

        /**
         * toggleFacebookAdGrid
         * 
         * @access public
         * @return void
         */
        // toggleFacebookAdGrid: function() {
        //     for (var index in this._facebookAdGrid) {
        //         this._facebookAdGrid[index].bringToFront();
        //     }
        // },

        // /**
        //  * prepareAndDraw
        //  * 
        //  * @access public
        //  * @param  Object document
        //  * @return void
        //  */
        // prepareAndDraw: function(document) {

        //     // 
        //     Canvases.Preview.setImageDocument(document);

        //     /**
        //      * If a backgroud image is not set, ensure the background color is
        //      * set to the background rectangle's
        //      */
        //     var layer = Canvases.Preview.getBackgroundImageLayer(),
        //         busy = Canvases.Preview.getBusy(),
        //         backgrounds = App.getEditor().getArea('backgrounds'),
        //         filters = backgrounds.getChild('filters');
        //     if (layer.getProperty('image') === false) {
        //         var rectangle = Canvases.Preview.getBackgroundRectangleLayer();
        //         colors.setBackgroundColor(
        //             rectangle.getStyle('backgroundColor')
        //         );
        //         filters.disable();
        //     }
        //     /**
        //      * Otherwise, set the background image filters (if any)
        //      */
        //     else {
        //         filters.enable();
        //         filters.setFilters(layer.getProperty('filters'));
        //     }

        //     /** 
        //      * Initially, the busy overlay had a transition applied that would
        //      * have it's opacity fade to 1. I had to remove this because it
        //      * conflicted with the Chrome Extension (specifically, when an image
        //      * was right-clicked).
        //      */
        //     busy.show();
        //     Canvases.Preview.once({
        //         'draw': function(event) {
        //             Canvases.Preview.getImageDocument().reorderWatermarks();
        //             Canvases.Preview.render(function() {
        //                 busy.hide();
        //             });
        //         }
        //     });
        //     Canvases.Preview.drawLayers();
        // },

        /**
         * refreshLayers
         * 
         * @note   A <drawn> check is made against the drawing to prevent trying
         *         to, for example, resize a vector image that hasn't yet been
         *         fully loaded. An example of when this might happen:
         *         You load the app, and while it's loading, resize your window.
         *         Since one of the vectors may have yet been drawn, it doesn't
         *         make sense to refresh it. If that happens, I wait for the
         *         drawn event on the layer before trying to refresh it again.
         * @access public
         * @return void
         */
        refreshLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    if (drawing.drawn() === true) {
                        drawing.once({
                            'refresh': function() {
                                if (index !== length - 1) {
                                    next(index + 1);
                                } else {
                                    _this.triggerHandler('refresh');
                                }
                            }
                        });
                        drawing.refresh();
                    } else {
                        drawing.once({
                            'draw': function(event) {
                                next(index);
                            }
                        });
                    }
                };
            next(0);
        },

        /**
         * resetBackgroundRectangleLayer
         * 
         * @access public
         * @return void
         */
        resetBackgroundRectangleLayer: function() {
            var layer = this.getBackgroundRectangleLayer();
            layer.triggerHandler('reset/backgroundColor');
        },

        // /**
        //  * setBackgroundBitmapImage
        //  * 
        //  * @access public
        //  * @param  String resource
        //  * @return BackgroundBitmapImageLayer
        //  */
        // setBackgroundBitmapImage: function(resource) {
        //     options = options || {};
        //     var properties = {
        //             background: true,
        //             resource: options.resource,
        //             styles: {
        //                 left: options.left || 50,
        //                 top: options.top || 50,
        //                 position: 1,
        //                 visible: true
        //             },
        //             type: 'image'
        //         },
        //         layer;
        //     layer = new BackgroundBitmapImageLayer(properties, this._image.getImageDocument());
        //     this._image.getImageDocument().addLayer(layer);
        //     this._image.getImageDocument().reorderWatermarks();
        //     return layer;
        // },

        /**
         * resize
         * 
         * @access public
         * @return void
         */
        resize: function() {
            this._setMaximumsDimensions();
            Toolbars.hide();
            this._cotton.discardActiveObject();
            this.once({
                'refresh': function() {
                    this.render();
                }
            });
            this.refreshLayers();
        },

        /**
         * restoreFrameSpecificPosition
         * 
         * @access public
         * @return void
         */
        restoreFrameSpecificPosition: function() {
            var layer = this.getBackgroundImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key'),
                position;
            if (image !== false) {
                position = {
                    left: layer.getStyle('left'),
                    top: layer.getStyle('top')
                };
                if (typeof this._positionMap[image] !== 'undefined') {
                    if (typeof this._positionMap[image][key] !== 'undefined') {
                        position = this._positionMap[image][key];
                        layer.setStyles(position);
                        layer.triggerHandler('position/restored');
                    } else {
                        layer.setStyles(position);
                    }
                } else {
                    layer.setStyles(position);
                }
            }
        },

        /**
         * setSelectedLayer
         * 
         * Sets the passed in Layer as the the selected one in the canvas, which
         * is then used to determine which layer should be affected when events
         * happen (for example, key-nudging).
         * 
         * It's worth noting that I'm keeping track of the previously selected
         * layer, as it's being used the TextToolbar view. In that case, it's
         * used to determine which layer should have it's font-family reinstated
         * if the font dropdown is shown, and then the user clicks elsewhere on
         * the canvas (or on another layer).
         * 
         * @access public
         * @param  Layer layer
         * @return void
         */
        setSelectedLayer: function(layer) {
            this._previouslySelectedLayer = this._selectedLayer;
            this._selectedLayer = layer;
        },

        /**
         * trackBackgroundImageLayerPosition
         * 
         * @access public
         * @return void
         */
        trackBackgroundImageLayerPosition: function() {
            var layer = this.getBackgroundImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key');
            if (typeof this._positionMap[image] === 'undefined') {
                this._positionMap[image] = {};
            }
            if (typeof this._positionMap[image][key] === 'undefined') {
                this._positionMap[image][key] = {};
            }
            this._positionMap[image][key].left = layer.getStyle('left');
            this._positionMap[image][key].top = layer.getStyle('top');
        },

        /**
         * unsavedChangesClearCanvasConfirm
         * 
         * @access public
         * @return ConfirmModal
         */
        unsavedChangesClearCanvasConfirm: function() {
            // var h1 = 'You have unsaved changes.<br />Creating a new image will remove all images and text.',
            var h1 = 'You have unsaved changes.',
                h2 = 'Are you sure you\'d like to proceed?',
                modal = Modals.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function() {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ChangeHistoryPopoverView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.ChangeHistoryPopoverView = View.extend({

        /**
         * _$scrollbar
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _changeHistoryPopoverList
         * 
         * @access protected
         * @var    undefined|ChangeHistoryPopoverListView (default: undefined)
         */
        _changeHistoryPopoverList: undefined,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ChangeHistoryPopoverView')
         */
        _string: 'ChangeHistoryPopoverView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._addHideListeners();
            this._addWindowResizeListener();
            this._drawChangeHistoryPopoverList();
            this._setupScrollbars();
            this.on({
                'hide': function(event) {
                    this.hide();
                },
                'show': function(event) {
                    this.show();
                },
                'toggle': function(event) {
                    this.toggle();
                }
            });
        },

        /**
         * _addHideListeners
         * 
         * @access protected
         * @return void
         */
        _addHideListeners: function() {
            var autoHidePopover = Stencil.get('config').defaults.changeHistory.autoHidePopover;
            if (autoHidePopover === true) {
                this.on({
                    'show': function(event) {
                        var _this = this,
                            $app = App.getElement(),
                            hide = {
                                'body/mousedown': function(event) {
                                    var $target = $(event.target);
                                    if ($target.parents('div.changeHistoryPopover').length === 0) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                },
                                'body/keydown/escape': function(event) {
                                    if (event.keyCode === 27) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            };
                        $app.on({
                            'mousedown': hide['body/mousedown'],
                            'keydown': hide['body/keydown/escape']
                        });
                    }
                });
            }
        },

        /**
         * _addWindowResizeListener
         * 
         * @access protected
         * @return void
         */
        _addWindowResizeListener: function() {
            if (Stencil.scrollbars() === true) {
                var delay = Stencil.getResizeDelay('canvas'),
                    callback = _.debounce(
                        // console.log.proxy(console, ['test']),
                        this.refresh.proxy(this),
                        delay
                    );
                $(window).on({
                    'resize': callback
                });
            }
        },

        /**
         * _drawChangeHistoryPopoverList
         * 
         * @access protected
         * @return void
         */
        _drawChangeHistoryPopoverList: function() {
            var $element = Stencil.render('ChangeHistoryPopoverList', {
                changeHistory: ChangeHistory.history.all()
            });
            this._element.find('div.content').append($element);
            this._changeHistoryPopoverList = new ChangeHistoryPopoverListView(
                $element
            );
        },

        /**
         * _makeScrollable
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _refreshScrollbar
         *
         * @access protected
         * @return void
         */
        _refreshScrollbar: function() {
            if (Stencil.scrollbars() === true) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * _setupScrollbars
         * 
         * @access protected
         * @return void
         */
        _setupScrollbars: function() {
            if (Stencil.scrollbars() === true) {
                var $content = this.find('div.content'),
                    $caret = $content.find('.stencil-caret');
                this._makeScrollable($content);
                $content.addClass('dark');
                $content.append($caret);
            }
        },

        /**
         * hide
         * 
         * @access public
         * @return void
         */
        hide: function() {
            this._element.addClass('hidden');
            App.find('[lookup="changeHistory"]').removeClass('active');
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            // this._changeHistoryPopoverList.refresh();
            this._changeHistoryPopoverList.reRender();
            this._refreshScrollbar();
            this.scrollToActive();
        },

        /**
         * scrollToActive
         * 
         * @see    http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery
         * @access public
         * @return void
         */
        scrollToActive: function() {
            var list = this._changeHistoryPopoverList,
                $parent = list.getElement().parent(),
                $active = list.find('.active').parent();
            if (Stencil.scrollbars() === true) {
                this._$scrollbar.data('jsp').scrollToY(0, false);
                this._$scrollbar.data('jsp').scrollToY(
                    $active.position().top - 4,
                    false
                );
            } else {
                var topPosition = $active.offset().top - $parent.offset().top +
                        $parent.scrollTop();
                $parent.scrollTop(topPosition);
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.scrollToActive();
            // this._changeHistoryPopoverList.scrollToActive();
            App.find('[lookup="changeHistory"]').addClass('active');
        },

        /**
         * toggle
         * 
         * @access public
         * @return void
         */
        toggle: function() {
            if (this._element.hasClass('hidden') === true) {
                this.triggerHandler('show');
            } else {
                this.triggerHandler('hide');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ChangeHistoryPopoverListView
     * 
     * @extends View
     */
    window.ChangeHistoryPopoverListView = View.extend({

        /**
         * _lastRenderHash
         * 
         * @access protected
         * @var    String (default: '')
         */
        _lastRenderHash: '',

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ChangeHistoryPopoverListView')
         */
        _string: 'ChangeHistoryPopoverListView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'redo': function(event, $anchor) {
                    var stepsForward = $anchor.attr('steps');
                    ChangeHistory.initiate.redo(stepsForward);
                },
                'undo': function(event, $anchor) {
                    var stepsBack = $anchor.attr('steps');
                    ChangeHistory.initiate.undo(stepsBack);
                }
            });
        },

        /**
         * _hasChangedSinceLastRender
         * 
         * Determines whether or not anything in the change history (redo and
         * undo) is different, by checking against a previously stored hash.
         * If something is different, it naturally returns true, which at the
         * moment is used for refreshing the list.
         * 
         * @access protected
         * @return Boolean
         */
        _hasChangedSinceLastRender: function() {
            var history = ChangeHistory.history.all(),
                hash = JSON.stringify(history).hash();
            if (hash === this._lastRenderHash) {
                return false;
            }
            this._lastRenderHash = hash;
            return true;
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        // refresh: function() {
        //     if (this._hasChangedSinceLastRender() === true) {
        //         this.rerender();
        //         // this.scrollToActive();
        //     }
        // },

        /**
         * reRender
         * 
         * @access public
         * @return void
         */
        reRender: function() {
            if (this._hasChangedSinceLastRender() === true) {
                var $element = Stencil.render('ChangeHistoryPopoverList', {
                    changeHistory: ChangeHistory.history.all()
                });
                this._element.replaceWith($element);
                this._element = $element;
                this._setupListeners();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageContentView
     * 
     * @events  toggle/changeHistory
     *          toggle/framer
     *          toggle/grid
     *          clear
     * @extends View
     */
    window.StageContentView = View.extend({

        /**
         * _canvases
         * 
         * @access protected
         * @var    Object
         */
        _canvases: {

            /**
             * ghost
             * 
             * @access protected
             * @var    GhostCanvasView (default: null)
             */
            ghost: null,

            /**
             * preview
             * 
             * @access protected
             * @var    PreviewCanvasView (default: null)
             */
            preview: null
        },

        /**
         * _changeHistoryPopover
         * 
         * @access protected
         * @var    ChangeHistoryPopoverView (default: null)
         */
        _changeHistoryPopover: null,

        /**
         * _framer
         * 
         * @access protected
         * @var    FramerView (default: null)
         */
        _framer: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                contextmenu: {

                    /**
                     * (anonymous)
                     * 
                     * Prevents right-click on the canvas.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $canvas
                     * @return void
                     */
                    'canvas': function(event, $canvas) {
                        event.preventDefault();
                    }
                },
                dragenter: {
                    '> div.outer > div.inner > div.sandbox': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            var type = decoded.type,
                                accessor = decoded.accessor;
                            this.find('section.messages > div.message:not(.hidden)').addClass('active');
                        }
                    }
                },
                dragleave: {
                    '> div.outer > div.inner > div.sandbox': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            this.find('section.messages > div.message:not(.hidden)').removeClass('active');
                        }
                    }
                },
                dragover: {
                    '> div.outer > div.inner > div.sandbox': function(event, $div) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                drop: {
                    '> div.outer > div.inner > div.sandbox': function(event, $div) {
// console.log('drop');
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {

                            // 
                            var type = decoded.type,
                                accessor = decoded.accessor;
                            if (accessor.indexOf(':') !== -1) {
                                accessor = accessor.replaceAll({
                                    'algoliaquote': 'AlgoliaQuote',
                                    'pexels': 'Pexels',
                                    'pixabay': 'Pixabay',
                                    'thenounproject': 'TheNounProject',
                                    'unsplash': 'Unsplash'
                                });
                            }
                            accessor = Stencil.getAccessor(accessor);
                            this.find('section.messages > div.message:not(.hidden)').removeClass('active');
                            accessor.select.apply(
                                accessor,
                                [type, 'drop', decoded.locked, {
                                    x: event.originalEvent.layerX,
                                    y: event.originalEvent.layerY
                                }]
                            );

                            // 
                            if (
                                decoded.type === 'background'
                                || decoded.type === 'graphic'
                            ) {
                                var start = new Date(),
                                    busy = Canvases.Preview.getBusy();
                                Canvases.Preview.once({
                                    'render': function(event) {
                                        var busy = this.getBusy();
                                        // busy.hide.minDelay(start, 500, busy);
                                        busy.hide.minDelay(start, 0, busy);
                                    }
                                });
                                busy.show();
                            }

                            /**
                             * There's a weird bug that I ran into while
                             * building change history. When an asset, resource
                             * or upload is dropped on the canvas, sometimes
                             * (about 1 in 5), the mouseup event does not fire.
                             * I tried for a number of hours to figure out why,
                             * to noavail. So I'm manully firing here.
                             * 
                             * It should not cause any issues, since even if the
                             * mouseup event does fire correctly, the change
                             * history operation will have already been tracked,
                             * and won't be inserted into the array again.
                             */
                            App.triggerHandler('changeHistory/track');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StageContentView')
         */
        _string: 'StageContentView',

        /**
         * _toolbars
         * 
         * @access protected
         * @var    Object
         */
        _toolbars: {
            foregroundBitmapImage: null,
            text: null,
            vectorImage: null,
            watermarkBitmapImage: null
        },

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._drawFramer();
            window.Canvases = {};
            this._setupGhostCanvas();
            this._setupPreviewCanvas();
            this._drawToolbars();
            this._setupChangeHistoryPopover();
            this._setupTooltips();
            this._setupButterBar();
            this._setupFacebookAdGrid();
            this._setupBackgroundHandles();
            this.on({
                'interaction/block': function(event, $element) {
                    this.interaction.block.apply(this);
                },
                'toggle/changeHistory': function(event, $element) {
                    $element.blur();
                    // App.tooltips.hide();
                    this.getChangeHistoryPopover().triggerHandler('toggle');
                },
                'toggle/framer': function(event, $element) {
                    $element.blur();
                    // App.tooltips.hide();
                    this._framer.toggle();
                },
                'toggle/grid': function(event, $element) {
                    $element.blur();
                    // App.tooltips.hide();
                    this.find('div.butter.bar [lookup="toggle/grid"]').toggleClass('hidden');
                    this.find('div.ui.actions [lookup="toggle/grid"]').toggleClass('active');
                    this.find('div.grid').toggleClass('hidden');
                },
                'addText': function(event, $element) {
                    $element.blur();
                    // App.tooltips.hide();
                    this.addText();
                },
                'clear': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    Canvases.Preview.clear(true);
                },
                'createNewImage': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    var canvasHasbeenChanged = Footer.validate.changedCanvas.apply(Footer).valid;
                    if (canvasHasbeenChanged === true) {
                        Canvases.Preview.clear(true, 'unsaved');
                    } else {
                        Canvases.Preview.clear(false);
                    }
                },
                'redo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.redo(1);
                    // App.tooltips.hide();
                },
                'undo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.undo(1);
                    // App.tooltips.hide();
                }
            });
        },

        /**
         * _drawFramer
         * 
         * @access protected
         * @return void
         */
        _drawFramer: function() {
            var $framer = Stencil.render('Framer');
            this._element.find('div.reframer').append($framer);
            this._framer = new FramerView($framer, this);
        },

        /**
         * _drawToolbars
         * 
         * @access protected
         * @return void
         */
        _drawToolbars: function() {

            // Global accessor
            window.Toolbars = {
                hide: function() {
                    Toolbars.backgroundBitmapImage.hide();
                    Toolbars.backgroundRectangle.hide();
                    Toolbars.foregroundBitmapImage.hide();
                    Toolbars.text.hide();
                    Toolbars.vectorImage.hide();
                    Toolbars.watermarkBitmapImage.hide();
                    var content = App.getStage().getContent();
                    content.handles.hide.apply(content);
                },
                show: function(type, options) {
                    Toolbars.hide();
                    Toolbars[type].show(options || {});
                }
            };

            // BackgroundBitmapImage toolbar
            var $backgroundBitmapImage = Stencil.render('BackgroundBitmapImageToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($backgroundBitmapImage);
            this._toolbars.backgroundBitmapImage = new BackgroundBitmapImageToolbarView($backgroundBitmapImage);
            window.Toolbars.backgroundBitmapImage = this._toolbars.backgroundBitmapImage;

            // BackgroundRectangle toolbar
            var $backgroundRectangle = Stencil.render('BackgroundRectangleToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($backgroundRectangle);
            this._toolbars.backgroundRectangle = new BackgroundRectangleToolbarView($backgroundRectangle);
            window.Toolbars.backgroundRectangle = this._toolbars.backgroundRectangle;

            // ForegroundBitmapImage toolbar
            var $foregroundBitmapImage = Stencil.render('ForegroundBitmapImageToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($foregroundBitmapImage);
            this._toolbars.foregroundBitmapImage = new ForegroundBitmapImageToolbarView($foregroundBitmapImage);
            window.Toolbars.foregroundBitmapImage = this._toolbars.foregroundBitmapImage;

            // Text toolbar
            var $text = Stencil.render('TextToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($text);
            this._toolbars.text = new TextToolbarView($text);
            window.Toolbars.text = this._toolbars.text;

            // VectorImage toolbar
            var $vectorImage = Stencil.render('VectorImageToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($vectorImage);
            this._toolbars.vectorImage = new VectorImageToolbarView($vectorImage);
            window.Toolbars.vectorImage = this._toolbars.vectorImage;

            // WatermarkBitmapImage toolbar
            var $watermarkBitmapImage = Stencil.render('WatermarkBitmapImageToolbar');
            this._element.find('> .outer > div.inner div.toolbars').append($watermarkBitmapImage);
            this._toolbars.watermarkBitmapImage = new WatermarkBitmapImageToolbarView($watermarkBitmapImage);
            window.Toolbars.watermarkBitmapImage = this._toolbars.watermarkBitmapImage;
        },

        /**
         * _setupBackgroundHandles
         * 
         * @access protected
         * @return void
         */
        _setupBackgroundHandles: function() {
            var $handles = this.find('div.handles');
            this.find('.preview-canvas-container').append($handles);
        },

        /**
         * _setupButterBar
         * 
         * @access protected
         * @return void
         */
        _setupButterBar: function() {
            var $bar = this.find('div.butter.bar');
            this.find('.sandbox').parent().append($bar);
            // this.find('.preview-canvas-container').append($bar);
        },

        /**
         * _setupChangeHistoryPopover
         * 
         * @access protected
         * @return void
         */
        _setupChangeHistoryPopover: function() {
            var $element = this.find('.changeHistoryPopover'),
                view = new ChangeHistoryPopoverView($element);
            this._changeHistoryPopover = view;
        },

        /**
         * _setupFacebookAdGrid
         * 
         * @access protected
         * @return void
         */
        _setupFacebookAdGrid: function() {
            var $grid = this.find('div.grid');
            this.find('.preview-canvas-container').append($grid);
        },

        /**
         * _setupGhostCanvas
         * 
         * @access protected
         * @return void
         */
        _setupGhostCanvas: function() {
            var $ghost = this.find('canvas#ghost'),
                ghost = new GhostCanvasView($ghost);
            this._canvases.ghost = ghost;
        },

        /**
         * _setupPreviewCanvas
         * 
         * @access protected
         * @return void
         */
        _setupPreviewCanvas: function() {
            var $preview = this.find('canvas#preview'),
                preview = new PreviewCanvasView($preview);
            this._canvases.preview = preview;
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            var $actions = this.find('div.ui.actions');
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: function() {
                    var placement = this.$element.attr('placement');
                    if (placement === undefined) {
                        placement = 'bottom';
                    }
                    if (placement === 'smart') {
                        var offset = $actions.offset(),
                            widths = {
                                body: App.getElement().width()
                            };
                        // if ((widths.body - offset.left) >= 142) {
                        if ((widths.body - offset.left) >= 153) {
                            return 'right';
                        }
                        return 'bottom';
                    }
                    return placement;
                }
            });
        },

        /**
         * addText
         * 
         * @access public
         * @return void
         */
        addText: function() {
            var canvas = Canvases.Preview,
                layer = canvas.addTextLayer(),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * drawPreviewCanvas
         * 
         * @access public
         * @return void
         */
        drawPreviewCanvas: function() {
            var draft = Stencil.account().draft(),
                document = draft.json(),
                preview = this._canvases.preview,
                imageDocument = new ImageDocument(document, draft, preview);
            draft.loadDependentFonts();
            draft.setImageDocument(imageDocument);
            preview.setImage(draft);
            preview.once({
                'render': preview.addWindowResizeListener
            });
            preview.once({
                'render': preview.addWindowOrientationChangeListener
            });
            preview.once({
                'render': function(event) {
                    var sourceImage = draft.getSourceImage();
                    if (sourceImage !== undefined) {
                        if (sourceImage.owned() === true) {
                            Footer.setLastSavedImage(sourceImage);
                        }
                    }
                }
            });
            preview.once({
                'render': function(event) {
                    var callback = Footer.reset.proxy(Footer);
                    this._cotton.on({
                        'after:render': _.throttle(callback, 75)
                    });
                    Footer.reset();
                }
            });
            preview.draw(true);
            draft.markConfigurationAsSaved();
        },

        /**
         * getChangeHistoryPopover
         * 
         * @access public
         * @return ChangeHistoryPopoverView
         */
        getChangeHistoryPopover: function() {
            return this._changeHistoryPopover;
        },

        /**
         * getFramer
         * 
         * @access public
         * @return FramerView
         */
        getFramer: function() {
            return this._framer;
        },

        /**
         * getMessage
         * 
         * @access public
         * @param  String type
         * @return jQuery
         */
        getMessage: function(type) {
            var selector = 'section.messages div.message[type="' + (type) + '"]';
            return this.find(selector);
        },

        /**
         * getMessages
         * 
         * @access public
         * @return jQuery
         */
        getMessages: function() {
            return this.find('section.messages div.message');
        },

        /**
         * handles
         * 
         * @access public
         * @var    Object
         */
        handles: {

            /**
             * hide
             * 
             * @access public
             * @return void
             */
            hide: function() {
                this.find('div.handles').addClass('hidden');
            },

            /**
             * show
             * 
             * @access public
             * @return void
             */
            show: function() {
                this.find('div.handles').removeClass('hidden');
            }
        },

        /**
         * interaction
         * 
         * @access public
         * @var    Object
         */
        interaction: {

            /**
             * block
             * 
             * @access public
             * @return void
             */
            block: function() {
                var busyModal = Canvases.Preview.getBusy(),
                    $element = busyModal.getElement();
                if ($element.hasClass('hidden') === true) {
                    $element.addClass('light');
                    // busyModal.show('Applying filter..');
                    busyModal.show('Resizing image..');
                }
            },

            /**
             * unblock
             * 
             * @access public
             * @return void
             */
            unblock: function() {
                var busyModal = Canvases.Preview.getBusy();
                busyModal.hide();
                busyModal.getElement().removeClass('light');
            }
        },

        /**
         * refreshChangeHistoryElements
         * 
         * This method is pretty simple: it disables the redo and undo CTAs,
         * and then checks the length of the redo and undo history stacks. In
         * the case of the redo history stack, I enable the redo CTA if there
         * are any entries.
         * 
         * The undo history stack is different, because there will *always* be
         * at least one entry: the original image state. So in that case, I
         * check if there's greater than 1 entry, and if so, enable the CTA.
         * 
         * @access public
         * @return void
         */
        refreshChangeHistoryElements: function() {
            var $redo = this.find('a.redo'),
                $undo = this.find('a.undo'),
                history = ChangeHistory.history.all();
            $redo.disabled(true);
            $undo.disabled(true);
            if (history.redo.length > 0) {
                $redo.disabled(false);
            }
            if (history.undo.length > 1) {
                $undo.disabled(false);
            }
        },

        /**
         * updateReframer
         * 
         * @access public
         * @return void
         */
        updateReframer: function() {
            var $reframer = this.find('.reframer'),
                $anchor = $reframer.find('a').first(),
                $middot = $reframer.find('span.middot').first(),
                $label = $anchor.find('div.label'),
                $width = $anchor.find('span.width'),
                $height = $anchor.find('span.height');
            $label.text(Frame.get('label'));
            $width.text(Frame.get('width'));
            $height.text(Frame.get('height'));
            $middot.removeClass('hidden');
            if (Frame.get('label').trim() === '') {
                $middot.addClass('hidden');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageFooterView
     * 
     * @events  download
     *          save
     *          template
     *          menu/save/close
     *          menu/save/open
     * @extends View
     */
    window.StageFooterView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    '[lookup="previewAndShare"]': function(event, $anchor) {
                        App.preloadShareModalStaticAssets();
                    }
                }
            });
        },

        /**
         * _lastSavedImage
         * 
         * Reference to the last saved ImageAccessor object (used by downloading
         * and sharing methods).
         * 
         * @access protected
         * @var    false|ImageAccessor (default: false)
         */
        _lastSavedImage: false,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StageFooterView')
         */
        _string: 'StageFooterView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            window.Footer = this;
            this._setupSecondarySaveMenu();
            this._setupAuth();
            this._setupDownload();
            this._setupPreviewAndShare();
            this._setupSave();
            this._setupSaveAsTemplate();
            this._setupTooltips();
            Scripts.load('aws');
        },

        /**
         * _closeOnboardModal
         * 
         * @access protected
         * @return void
         */
        _closeOnboardModal: function() {
            var onboard = Modals.get('Onboard');
            if (onboard !== false) {
                onboard.triggerHandler('leave');
            }
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            User.once({
                'login': function(event, user) {
                    Footer.reset();
                }
            });
            Account.once({
                'upgrade': function(event, account) {
                    Footer.reset();
                }
            });
        },

        /**
         * _setupDownload
         * 
         * @access protected
         * @return void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {
                    var check = this.validate.download.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        var draft = Stencil.account().draft(),
                            key = draft.get('key');
                        Modals.showDownload(key);
                    }
                }
            });
        },

        /**
         * _setupPreviewAndShare
         * 
         * @todo   Look into whether an image needs to actually be saved when
         *         the P+S button is clicked. Might make more sense to only
         *         save the image once they try to get interact with it via the
         *         share modal? More complicated, since there are non-OAuth
         *         based interaction methods (eg. Buffer, Pinterest, SMS), but
         *         it's much more efficient, in that no image gets saved to the
         *         DB or S3 if they just want to see what it looks like. It thus
         *         also saves browser-memory.
         * @access protected
         * @return void
         */
        _setupPreviewAndShare: function() {
            this.on({
                'previewAndShare': function(event) {
                    this._closeOnboardModal();
                    var check = this.validate.previewAndShare.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        check = this.validate.changedCanvas.apply(this);
                        if (check.valid === true) {
                            Stencil.account().draft().share();
                            // var msg = Stencil.getMessage('image.saving');
                            // App.getBusy().show(msg);
                            this.save('share', false);
                        } else {
                            this._lastSavedImage.share();
                        }
                    }
                }
            });
        },

        /**
         * _setupSave
         * 
         * @note   I set the account's monthlySavedImages and totalSavedImages
         *         right away (and delay the syncing to the db) because I want
         *         the UI to change immediately (eg.
         *         https://i.imgur.com/M5fueDd.png), but I don't want the
         *         account record to be patched until _after_ a new shadow draft
         *         has been created. This is to prevent a possible 
         *         race-condition when the AccountAccessor is patched before
         *         the new shadow draft has been created. This can happen if the
         *         server is lagging. Specifically, the draft ImageAccessor is
         *         updated, a new shadow draft ImageAccessor is created, but
         *         before that completes, the existing AccountAccessor is
         *         updated. If the AccountAccessor is patched before the new
         *         shadow draft ImageAccessor has been created, this line of
         *         code will fire, which will result in two draft records in the
         *         db for the account: https://i.imgur.com/1hyuGwa.png
         *         Here's the result: https://i.imgur.com/pKApJAK.png
         *         Tough one to crack..
         * @access protected
         * @return void
         */
        _setupSave: function() {
            this.on({
                'save': function(event) {
                    var check = this.validate.save.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        // Account setting/saving
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // Image collection addition
                        var draft = account.draft(),
                            images = App.getEditor().getArea('images').getChild('all').getCollection();
                        images.add(draft, false);

                        // Save and navigate to images tab
                        // var msg = Stencil.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        this.save('save', false);

                        // Scrolling
                        if (Stencil.getRouter().current().fragment === 'app/saved') {
                            App.getEditor().getArea('images').getChild('all').scrollToTop();
                        } else {
                            Stencil.getRouter().once({
                                'route:app/saved': function() {
                                    App.getEditor().getArea('images').getChild('all').scrollToTop();
                                }
                            });
                        }

                        // Send over
                        Stencil.navigate('/app/saved');

                        // Image count warning
                        if (User.admin() === false) {
                            var remaining = account.getImagesRemaining();
                            if (remaining === 0 || remaining === 1) {
                                Stencil.navigate('/app/countdown?clean=1');
                            }
                        }

                        // Actions
                        Footer.reset();
                        // this.disable.save.apply(this);
                        // this.enable.distribution.apply(this);
                    }
                }
            });
        },

        /**
         * _setupSaveAsTemplate
         * 
         * @access protected
         * @return void
         */
        _setupSaveAsTemplate: function() {
            this.on({
                'saveAsTemplate': function(event) {
                    this.triggerHandler('menu/save/close');
                    var check = this.validate.saveAsTemplate.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        // Account setting/saving
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // 
                        Stencil.account().draft().template();
                        // var msg = Stencil.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        this.save('template', false);
                        Track.event('Template saved');
                        Stencil.navigate('/app/templates/saved');
                    }
                }
            });
        },

        /**
         * _setupSecondarySaveMenu
         * 
         * @access protected
         * @return void
         */
        _setupSecondarySaveMenu: function() {
            this.on({
                'menu/save/close': function(event) {
                    this.find('div.save').removeClass('expanded');
                },
                'menu/save/open': function(event) {
                    var _this = this;
                    this.find('div.save').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover[button="save"]').length === 0) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.keyCode === 27) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: this._element,
                placement: 'top'
            });
        },

        /**
         * disable
         * 
         * @access public
         * @var    Object
         */
        disable: {

            /**
             * all
             * 
             * @access public
             * @return void
             */
            all: function() {
                this.disable.distribution.apply(this);
                this.disable.save.apply(this);
            },

            /**
             * distribution
             * 
             * Disables the "Download" and "Preview & Share" buttons. Adds the
             * tooltips to them.
             * 
             * @access public
             * @return void
             */
            distribution: function() {
                this.find('[lookup="download"]').disable();
                this.find('[lookup="previewAndShare"]').disable();
                this.find('[lookup="download"]').tooltips(true);
                this.find('[lookup="previewAndShare"]').tooltips(true);
            },

            /**
             * save
             * 
             * Disables the "Save" and "Save as template" buttons. Adds the
             * tooltip to the parent save button.
             * 
             * @access public
             * @return void
             */
            save: function() {
                this.find('[lookup="save"]').disable();
                this.find('[lookup="saveChevron"]').disable();
                this.find('[lookup="saveWrapper"]').tooltips(true);
            }
        },

        /**
         * enable
         * 
         * @access public
         * @var    Object
         */
        enable: {

            /**
             * all
             * 
             * Helper method for the other two enable methods. Enables all three
             * actions, and removes all tooltips.
             * 
             * @access public
             * @return void
             */
            all: function() {
                this.enable.distribution.apply(this);
                this.enable.save.apply(this);
            },

            /**
             * distribution
             * 
             * Enables the "Download" and "Preview & Share" buttons. Removes the
             * tooltips from them.
             * 
             * @access public
             * @return void
             */
            distribution: function() {
                this.find('[lookup="download"]').enable();
                this.find('[lookup="previewAndShare"]').enable();
                this.find('[lookup="download"]').tooltips(false);
                this.find('[lookup="previewAndShare"]').tooltips(false);
            },

            /**
             * save
             * 
             * Enables the "Save" and "Save as template" buttons. Removes the
             * tooltip from the parent save button.
             * 
             * @access public
             * @return void
             */
            save: function() {
                this.find('[lookup="save"]').enable();
                this.find('[lookup="saveChevron"]').enable();
                this.find('[lookup="saveWrapper"]').tooltips(false);
            }
        },

        /**
         * getLastSavedImage
         * 
         * @access public
         * @return null|ImageAccessor
         */
        getLastSavedImage: function() {
            return this._lastSavedImage;
        },

        /**
         * setLastSavedImage
         * 
         * @access public
         * @param  false|ImageAccessor image
         * @return void
         */
        setLastSavedImage: function(image) {//, disableSave) {
    // console.log('Footer.setLastSavedImage called');
    // console.log(arguments);
    // console.trace();
            this._lastSavedImage = image;
            // disableSave === true && this.disable.save.apply(this);
            // this.enable.distribution.apply(this);
        },

        /**
         * validate
         * 
         * @access public
         * @var    Object
         */
        validate: {

            /**
             * changedCanvas
             * 
             * This validation method is intended to determine whether the draft
             * is different than the source image defined (if any). It does this
             * by first checking if a saved image is stored in the footer (which
             * would be the source image of any draft). If none is, then the
             * canvas is identified as different (this would happen for
             * brand-new guests).
             * 
             * If a saved image is defined, it then checks whether it's
             * configuration (which is the same as the draft's source image) is
             * different than the draft. If that check passes, then we return
             * true: the canvas has changed.
             * 
             * Originally, I thought I would have to check 3rd-party resources
             * to see if, for example, a Pixabay:123 resource was in fact the
             * same as a asst123 resource. The convern was that if a user clicks
             * a Pixabay background, and then saves it right away, when the
             * /save call came back, it would swap out the new draft's image-key
             * property, and thus be seen as a different relative to the source
             * image. The reason this is no longer an issue is because the way
             * /save call listeners work, is the source image would have _it's_
             * image-key property swapped out too. So in fact, the two canvases
             * would be the same from a programmtic/json perspective.
             * 
             * Something that _could_ be done is right now, if you click a
             * Pixabay image, and save it, the resource-hash is replaced with
             * the asset key (via the /save call). But if the user then
             * continues navigating through the search results, if they make
             * their way _back_ to the initial image, it will be seen as
             * different because the asset key and resource-hash do not seem to
             * match up.
             * 
             * While this is an edge-case, it is something that could be
             * improved.
             * 
             * @todo   See note above
             * @access public
             * @return Object
             */
            changedCanvas: function() {
                if (this._lastSavedImage === false) {
                    return {
                        valid: true
                    };
                }
                var draft = Stencil.account().draft(),
                    configurations = {
                        draft: draft.getConfiguration(),
                        lastSavedImage: this._lastSavedImage.getConfiguration()
                    },
                    configurationStrings;
                delete configurations.draft.sourceImageId;
                delete configurations.lastSavedImage.sourceImageId;
                configurationStrings = {
                    draft: JSON.stringify(configurations.draft),
                    lastSavedImage: JSON.stringify(configurations.lastSavedImage)
                };
// console.log(configurationStrings);
// console.log(JSON.stringify(draft.data()));
// console.log(JSON.stringify(this._lastSavedImage.data()));
                if (configurationStrings.draft !== configurationStrings.lastSavedImage) {
                    return {
                        valid: true
                    };
                }
                return {
                    valid: false
                };
            },

            /**
             * download
             * 
             * Series of validation methods to determine whether a download can
             * take place. Of particular interest is the saving-check, which
             * also checks whether the <_lastSavedImage> property is set to
             * null. This is to allow for the case whereby a user saves an image
             * first, and before updating anything about it, attempts to use the
             * Download or Preview & Share buttons. In that case, the user
             * should be allow to proceed, since those flows manage themselves
             * nicely already with respect to an image that is still being
             * uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access public
             * @return Object
             */
            download: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, content) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (Account.max.images() === true && User.admin() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * previewAndShare
             * 
             * Series of validation methods to determine whether a Preview &
             * Share can take place. Of particular interest is the saving-check,
             * which also checks whether the <_lastSavedImage> property is set
             * to null. This is to allow for the case whereby a user saves an
             * image first, and before updating anything about it, attempts to
             * use the Download or Preview & Share buttons. In that case, the
             * user should be allow to proceed, since those flows manage
             * themselves nicely already with respect to an image that is still
             * being uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access public
             * @return Object
             */
            previewAndShare: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, content) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (Account.max.images() === true && User.admin() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access public
             * @return Object
             */
            save: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, content) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (Account.draftIsLocked() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/locked-save?clean');
                        }
                    };
                }
                if (User.exists() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/signup?save');
                        }
                    };
                }
                if (Account.max.images() === true && User.admin() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * saveAsTemplate
             * 
             * @access public
             * @return Object
             */
            saveAsTemplate: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, content) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (Account.upgraded() === false && User.admin() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                        }
                    };
                }
                if (Account.max.images() === true && User.admin() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * sourceImageContext
             * 
             * Checks whether the source image for the draft was saved under a
             * specific context (eg. save, template, download or share). This is
             * used to determine whether the Footer save button should be
             * enabled. For example, if save is passed in, it will ensure that
             * the source image for the account's draft image was in fact saved,
             * rather than possibly saved as a template or via a download or
             * share action.
             * 
             * @access public
             * @param  String context
             * @return Object
             */
            sourceImageContext: function(context) {
                if (this._lastSavedImage === false) {
                    return {
                        valid: false
                    };
                }
                var draft = Stencil.account().draft(),
                    sourceImage = draft.getSourceImage();
                if (sourceImage === undefined) {
                    return {
                        valid: false
                    };
                }
                return {
                    valid: sourceImage.get('context') === context
                };
            }
        },

        /**
         * reset
         * 
         * @access public
         * @return void
         */
        reset: function() {
            var changedCanvas = this.validate.changedCanvas.apply(this).valid;
            if (changedCanvas === true) {
                this.enable.save.apply(this);
                if (User.admin() === false) {
                    if (
                        Account.guest() === true
                        || Account.free() === true
                        || Account.plan('pro') === true
                    ) {
                        this.disable.distribution.apply(this);
                    } else {
                        this.enable.distribution.apply(this);
                    }
                } else {
                    this.enable.distribution.apply(this);
                }
            } else {
                var saveContext = this.validate.sourceImageContext.apply(this, ['save']).valid;
                if (saveContext === true) {
                    this.disable.save.apply(this);
                } else {
                    this.enable.save.apply(this);
                }
                this.enable.distribution.apply(this);
                // if (User.admin() === false) {
                //     if (Account.guest() === true || Account.free() === true) {
                //         this.enable.distribution.apply(this);
                //     }
                // }
            }
        },

        /**
         * save
         * 
         * @access public
         * @param  String context
         * @param  false|String mime
         * @param  undefined|Function callback
         * @return void
         */
        save: function(context, mime, callback) {

            // Draft swapping
            this.time('save');
            Canvases.Ghost.set({'saving': true});
            var account = Stencil.account(),
                saving = account.draft(),
                imageDocument = saving.getImageDocument(),
                draft = account.createNewDraft(saving);
            this._lastSavedImage = saving;
            draft.setImageDocument(imageDocument);
            imageDocument.setImage(draft);
            draft.markConfigurationAsSaved();
            Canvases.Preview.setImage(draft);

            // 
            ChangeHistory.syncSourceImageId(
                saving.get('sourceImageId').toInt(),
                saving.get('id').toInt()
            );

            // Settings
            saving.setConfiguration();
            saving.set({
                'context': context,
                'draft': 0
            });

            /**
             * It's important to clear the configuration save timeout to prevent
             * the following possible race-condition:
             * 
             * If an image is really simple, and the user makes a change and
             * then quickly saves it, it's possible that the PATCH call to save
             * the image gets dipstached *after* the image has been fully
             * uploaded. If this happens, then the ImageValidator::notUploaded
             * check will fail, since the image has technically already been
             * uploaded.
             * 
             * Cancelling this call is fine, because it really is only
             * cancelling the dispatching of the PATCH call. The data itself is
             * already changed in the ImageAccessor reference, and will be
             * synced in the below .save call anyhow
             */
            saving.clearSaveConfigurationTimeout();

            // Create new image document and layers for saving image
            var document = saving.json(),
                ghost = Canvases.Ghost;
            imageDocument = new ImageDocument(document, saving, ghost);
            imageDocument.mergeWatermarks();
            imageDocument.setupLayers();
            saving.setImageDocument(imageDocument);

            // Save through the Ghost canvas
            var _this = this;
            Canvases.Ghost.setImage(saving);
            Canvases.Ghost.once({
                'export': function(event, content, mime) {

                    // Image saved
                    _this.time('save');
                    Canvases.Ghost.set({'saving': false});
                    Track.event('Image pushed', {
                        label: context,
                        _label: context
                    });

                    // Promote the draft to a saved image
                    saving.set({
                        size: content.length,
                        mime: mime
                    });
                    saving.save([
                        'context', 'draft', 'size', 'mime', 'width', 'height',
                        'sourceImageId', 'frame', 'settings.json',
                        'settings.watermarks'
                    ]);
                    // saving.markConfigurationAsSaved();

                    // Init and start upload
                    var model = Stencil.getModel('S3Upload');
                    saving.once({
                        'upload/error': function(event, response) {
                            Stencil.alert('image.upload.error');
                            Stencil.kill();
                            StencilBooter.log(event, response);
                            var msg = {
                                response: response
                            };
                            try {
                                msg.raw = {
                                    code: response.code,
                                    hostname: response.hostname,
                                    message: response.message,
                                    name: response.name,
                                    region: response.region,
                                    time: response.time
                                };
                            } catch(exception) {}
                            Stencil.report(msg);
                        },
                        'upload/success': function(event, response) {
                            this.compress(function() {
                                this.set({
                                    'uploaded': 1,
                                    'uploadedTimestamp': 1,
                                    'settings.icons': JSON.stringify(
                                        this.getIcons()
                                    )
                                });
                                this.save([
                                    'uploaded',
                                    'uploadedTimestamp',
                                    'settings.icons'
                                ]);
                                this.preload(function() {
                                    this.triggerHandler('preload');
                                });
                            });
                        }
                    });
                    try {
                        model.uploadData(
                            saving,
                            saving.get('key'),
                            content
                        );

                        // Send response to callback if defined
                        callback && callback.apply(_this, [saving, content]);
                    } catch (err) {
                        Stencil.alert('image.upload.exception');
                    }
                },

                /**
                 * I wait for the render event, rather than the draw, to allow
                 * for filters that may take some time to be applied, to be
                 * applied. Without this listener, filters weren't coming
                 * through in the data
                 */
                'render': function(event) {
                    this.export(mime, true);
                }
            });
            Canvases.Ghost.draw();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FramerView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.FramerView = View.extend({

        /**
         * _collection
         * 
         * @access protected
         * @var    FramesCollection (default: null)
         */
        _collection: null,

        /**
         * _form
         * 
         * @access protected
         * @var    AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'nav a': function(event, $anchor) {
                        event.preventDefault();
                        this.section($anchor.attr('type'));
                    }
                }
            });
        },

        /**
         * _originalBackgroundSizeFrame
         * 
         * @access protected
         * @var    OriginalBackgroundSizeFrameView (default: null)
         */
        _originalBackgroundSizeFrame: null,

        /**
         * _scrollables
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _scrollables: {},

        /**
         * _stageContent
         * 
         * @access protected
         * @var    StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'FramerView')
         */
        _string: 'FramerView',

        /**
         * _views
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _views: {},

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @param  StageContentView stageContent
         * @return void
         */
        init: function(element, stageContent) {
            this._super(element);
            this._stageContent = stageContent;
            this._setupAuth();
            if (Stencil.scrollbars() === true) {
                this._setupScrollbars();
            }

            // Collection
            this._collection = Stencil.account().collection('frames');
            var _this = this;
            this._collection.on({
                'add': function(event, frame, position) {
                    _this._drawFrame(frame, position);
                },
                'empty': function(event) {
                    _this.find('.frame').remove();
                },
                'update': function(event) {
                    _this.refresh();
                }
            });

            // UI
            this.on({
                // 'frame': this.frame,
                'hide': this.hide,
                'show': this.show,
                'toggle': this.toggle,
            });
            this._draw();
            this.section('posts');
            this._setupForm();
        },

        /**
         * _draw
         * 
         * @access protected
         * @return void
         */
        _draw: function() {
            var _this = this;
            this._collection.each(function(index, frame) {
                _this._drawFrame(frame, index);
            });
        },

        /**
         * _drawCustomFrame
         * 
         * @access protected
         * @param  FrameAccessor frame
         * @param  Number position
         * @return void
         */
        _drawCustomFrame: function(frame, position) {
            var $frames = this.find('section[type="custom"] div.frames'),
                $frame = Stencil.render('CustomFrame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new CustomFrameView($frame, this, frame);
        },

        /**
         * _drawDefaultFrame
         * 
         * @access protected
         * @param  FrameAccessor frame
         * @param  Number position
         * @return void
         */
        _drawDefaultFrame: function(frame, position) {
            var type = frame.get('type').plural(),
                $frames = this.find('section[type="' + (type) + '"] div.frames'),
                $frame = Stencil.render('Frame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new FrameView($frame, this, frame);
        },

        /**
         * _drawFrame
         * 
         * @access protected
         * @param  FrameAccessor frame
         * @param  Number position
         * @return void
         */
        _drawFrame: function(frame, position) {
            if (frame.get('type') === 'custom') {
                this._drawCustomFrame(frame, position);
            } else {
                this._drawDefaultFrame(frame, position);
            }
        },

        /**
         * _scrollable
         * 
         * @see    http://jquery-custom-scrollbar.rocketmind.pl/
         * @access protected
         * @param  jQuery $element
         * @param  String section
         * @return void
         */
        _scrollable: function($element, section) {
            this._scrollables[section] = $element;
            this._scrollables[section].jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _setupAuth
         * 
         * @access protected
         * @return void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    // _this._collection.empty();
// StencilBooter.log(_this._collection.custom());
// return;
                    jQuery.each(
                        _this._collection.custom(),
                        function(index, frame) {
                            // _this._collection.remove(frame);
                            // frame.getElement().remove();
                        }
                    );
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access protected
         * @return void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on('returned/succeeded', function(event, response) {
                Track.event('Custom frame created');
                this.find('input[type="text"]').val('');
                var collection = _this._collection;
                collection.map(response.data.object, false);
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access protected
         * @return void
         */
        _setupScrollbars: function() {
            var $posts = this.find('section.posts');
            this._scrollable($posts.find('.content'), 'posts');
            var $ads = this.find('section.ads');
            this._scrollable($ads.find('.content'), 'ads');
            var $headers = this.find('section.headers');
            this._scrollable($headers.find('.content'), 'headers');
            var $custom = this.find('section.custom');
            this._scrollable($custom.find('.content'), 'custom');
        },

        /**
         * hide
         * 
         * @access public
         * @return void
         */
        hide: function() {
            this._element.addClass('hidden');
            this.refresh();
        },

        /**
         * getContent
         * 
         * @access public
         * @return StageContentView
         */
        getContent: function() {
            return this._stageContent;
        },

        /**
         * getOriginalBackgroundFrameView
         * 
         * @access public
         * @return FrameView
         */
        getOriginalBackgroundFrameView: function() {
            return this._originalBackgroundSizeFrame;
        },

        /**
         * refresh
         * 
         * @access public
         * @return void
         */
        refresh: function() {
            if (Stencil.scrollbars() === true) {
                this._scrollables.posts.data('jsp').reinitialise();
                this._scrollables.ads.data('jsp').reinitialise();
                this._scrollables.headers.data('jsp').reinitialise();
                this._scrollables.custom.data('jsp').reinitialise();
            }
        },

        /**
         * section
         * 
         * @access public
         * @param  String section
         * @return void
         */
        section: function(section) {
            var $nav = this.find('nav'),
                $content = this.find('> div.content > div.content');
            $nav.find('a').removeClass('active');
            $nav.find('a[type=' + (section) + ']').addClass('active');
            $content.find('> section').addClass('hidden');
            $content.find('> section.' + (section)).removeClass('hidden');
            this.refresh();
            if (section === 'custom') {
                Browser.tablet() === false && Browser.ie() === false
                    && $content.find('> section.' + (section)).focusable().focus();
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.refresh();
        },

        /**
         * toggle
         * 
         * @access public
         * @return void
         */
        toggle: function() {
            this._element.toggleClass('hidden');
            if (this._element.hasClass('hidden') === false) {
                var _this = this,
                    $app = App.getElement(),
                    hide = {
                        'body/mousedown': function(event) {
                            var $target = $(event.target),
                                outsideFramer = $target.parents('div.framer').length === 0;
                            if (outsideFramer === true) {
                                var outsideConfirmModal = $target.parents('div.modal.confirm').length === 0;
                                if (outsideConfirmModal === true) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        },
                        'body/keydown/escape': function(event) {
                            if (event.keyCode === 27) {
                                var confirmModalShowing = App.find('div.modal.confirm').length !== 0;
                                if (confirmModalShowing === false) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        }
                    };
                $app.on({
                    'mousedown': hide['body/mousedown'],
                    'keydown': hide['body/keydown/escape']
                });
            }
            this.refresh();
        },

        /**
         * updateSelected
         * 
         * @access public
         * @return void
         */
        updateSelected: function() {

            // Reset
            this.find('div.active').removeClass('active');
            this.find('a.button.tiny').removeClass('done');
            this.find('a.button.tiny').removeAttr('disabled');

            // Current
            var $frame = this.find('[lookup="' + (Frame.get('key')) + '"]');
            $frame.addClass('active');
            $frame.find('a.button').addClass('done');
            $frame.find('a.button').attr('disabled', 'disabled');

            // Section
            var type = Frame.get('type'),
                sections = {
                    custom: 'custom',
                    post: 'posts',
                    ad: 'ads',
                    header: 'headers'
                },
                section = sections[type];
            section !== undefined && this.section(section);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageHeaderView
     * 
     * @events  menu/close
     *          menu/open
     * @extends View
     */
    window.StageHeaderView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $anchor
                     * @return void
                     */
                    'div.popover div.content > a': function(event, $anchor) {
                        this.triggerHandler('menu/close');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @note   I needed to add a 0 millisecond delay to get the
                     *         event triggering at the end of the call-stack.
                     *         This is because I believe Headway is cancelling
                     *         out right away. Namely, it opens the menu, and
                     *         then hide's it immediately.
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $div
                     * @return void
                     */
                    'div.notifications': function(event, $div) {
                        var $target = $(event.target);
                        if ($target.hasClass('icon') === true) {
                            (function() {
                                $div.find('#HW_badge_cont').trigger('click');
                            }).delay(0);
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StageHeaderView')
         */
        _string: 'StageHeaderView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupHeadway();
            this.on({
                'menu/close': function(event) {
                    this.find('div.text').removeClass('expanded');
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('div.text').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover').length === 0) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.keyCode === 27) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                    // var escape = function(event) {
                    //     if (event.keyCode === 27) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // };
                    // App.getElement().on({
                    //     'keydown': escape
                    // });
                    // App.getElement().one({
                    //     'mousedown': function(event) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // });
                },
                'logout': function(event) {
                    // App.getBusy().show();
                    User.logout();//.delay(1000);
                    // User.logout.delay(1000);
                }
            });
            var _this = this;
            Stencil.account().on({
                'change': function(event) {
                    var remaining = this.getImagesRemaining(),
                        $count = _this.find('div.count');
                    $count.text(remaining);
                    $count.attr('class', 'count');
                    if (remaining <= 0) {
                        $count.addClass('red');
                    } else if (remaining < 4) {
                        $count.addClass('orange');
                    }

                    // Date
                    var $date = _this.find('div.date'),
                        $strong = $date.find('strong'),
                        refillDate = this.getRefillDate();
                    $strong.text(refillDate);
                }
            });
            User.once({
                'login': this.render.proxy(this),
                'signup': this.render.proxy(this)
            });
            Account.once({
                'upgrade': this.render.proxy(this)
            });
        },

        /**
         * _setupHeadway
         * 
         * @access protected
         * @return void
         */
        _setupHeadway: function() {
            if (Services.check('headway') === true) {
                App.getElement().on({
                    'keydown': function(event) {
                        if (event.keyCode === 27) {
                            if ($(this).find('#HW_badge_cont').length > 0) {
                                if ('Headway.hide'.validMethod() === true) {
                                    Headway.hide();
                                }
                            }
                        }
                    },
                    'mousedown': function(event) {
                        if ($(this).find('#HW_badge_cont').length > 0) {
                            if ('Headway.hide'.validMethod() === true) {
                                Headway.hide();
                            }
                        }
                    }
                });
            }
        },

        /**
         * render
         * 
         * @access public
         * @return void
         */
        render: function() {
            if (Services.check('headway') === true) {
                Headway.init();
            }
            var $header = Stencil.render('StageHeader', {
                account: Stencil.account()
            });
            this._element.replaceWith($header);
            this._element = $header;
            this._setupListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageView
     * 
     * @extends View
     */
    window.StageView = View.extend({

        /**
         * _content
         * 
         * @access protected
         * @var    StageContentView (default: null)
         */
        _content: null,

        /**
         * _footer
         * 
         * @access protected
         * @var    StageFooterView (default: null)
         */
        _footer: null,

        /**
         * _header
         * 
         * @access protected
         * @var    StageHeaderView (default: null)
         */
        _header: null,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'StageView')
         */
        _string: 'StageView',

        /**
         * init
         * 
         * @note   Purposelly ordered the drawing so that the content is drawn
         *         last, to ensure that the height is properly calculated for
         *         the canvas.
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._drawHeader();
            this._drawFooter();
            this._drawContent();
            if (Browser.tablet() === true) {
                // FastClick.attach(element.get(0));
            }
            // this.find('> div.spinner').addClass('invisible');
        },

        /**
         * _drawContent
         * 
         * @access protected
         * @return void
         */
        _drawContent: function() {
            var $content = Stencil.render('StageContent');
            this.find('> div.inner > footer').before($content);
            this._content = new StageContentView($content);
        },

        /**
         * _drawFooter
         * 
         * @access protected
         * @return void
         */
        _drawFooter: function() {
            var $footer = Stencil.render('StageFooter');
            this.find('> div.inner').append($footer);
            this._footer = new StageFooterView($footer);
        },

        /**
         * _drawHeader
         * 
         * @access protected
         * @return void
         */
        _drawHeader: function() {
            var $header = Stencil.render('StageHeader', {
                account: Stencil.account()
            });
            this.find('> div.inner').append($header);
            this._header = new StageHeaderView($header);
        },

        /**
         * getContent
         * 
         * @access public
         * @return StageContentView
         */
        getContent: function() {
            return this._content;
        },

        /**
         * getFooter
         * 
         * @access public
         * @return StageFooterView
         */
        getFooter: function() {
            return this._footer;
        },

        /**
         * getHeader
         * 
         * @access public
         * @return StageHeaderView
         */
        getHeader: function() {
            return this._header;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ToolbarView
     * 
     * @fires   show
     * @see     http://cache.preserve.io/5g18q0pw/index.html
     * @extends View
     */
    window.ToolbarView = View.extend({

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        // _listeners: function() {
        //     return jQuery.extend(true, {}, this._super(), {
        //         mouseover: {
        //             'input[type="range"]': function(event, $range) {
        //                 $range.addClass('active');
        //             }
        //         }
        //     });
        // },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ToolbarView')
         */
        _string: 'ToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'change/order/back': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [false]);
                    this.order.auto.apply(this);
                },
                'change/order/forward': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [true]);
                    this.order.auto.apply(this);
                },
                'clone': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('clone');
                },
                'delete': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('delete');
                },
                'flip/x': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipX') === false;
                    if (layer.getStyle('flipX') === undefined) {
                        flip = true;
                    }
                    layer.triggerHandler('flip/x', [flip]);
                },
                'flip/y': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipY') === false;
                    if (layer.getStyle('flipY') === undefined) {
                        flip = true;
                    }
                    layer.triggerHandler('flip/y', [flip]);
                }
            });
        },

        /**
         * _positionTooltip
         * 
         * @access protected
         * @param  jQuery $range
         * @return void
         */
        _positionTooltip: function($range) {
            var $tooltip = $range.siblings('.tooltip');
            if ($tooltip.length > 0) {
                var value = $range.val().toFloat(),
                    uiValue = value;
                if ($range.attr('data-ui-value') !== undefined) {
                    uiValue = $range.attr('data-ui-value');
                }
                $tooltip.find('.tooltip-inner').text(uiValue);
                var max = $range.attr('max').toFloat(),
                    min = $range.attr('min').toFloat(),
                    paddingLeft = $range.parent().css('padding-left').toFloat(),
                    rangeWidth = $range.css('width').toFloat(),
                    tooltipWidth = $tooltip.css('width').toFloat(),
                    thumbWidth = 16,
                    left = 0;
                left = left + paddingLeft;
                left = left - (tooltipWidth / 2);
                left = left + (thumbWidth / 2);
                left = left + (rangeWidth - thumbWidth) * ((value - min) / (max - min));
                $tooltip.css({
                    left: left.round(0) + ('px')
                });
            }
        },

        /**
         * _setupTooltip
         * 
         * @access protected
         * @param  String name
         * @return void
         */
        _setupTooltip: function(name) {
            var $range = this.find('input[name="' + (name) + '"]')
            $range.after('' +
                '<div class="tooltip bottom" lookup="tooltip/' + (name) + '">' +
                    '<div class="tooltip-arrow"></div>' +
                    '<div class="tooltip-inner">#</div>' +
            '</div>');
        },

        /**
         * hide
         * 
         * @access public
         * @return void
         */
        hide: function() {
            this._element.addClass('hidden');
        },

        /**
         * order
         * 
         * @access public
         * @var    Object
         */
        order: {

            /**
             * auto
             * 
             * Enables/disables the ordering UI options by checking the selected
             * layer's position within the other layers.
             * 
             * @access public
             * @return void
             */
            auto: function() {
                var layer = Canvases.Preview.getSelectedLayer();
                this.order.enable.apply(this);
                if (layer.front() === true) {
                    this.order.disable.apply(this, ['forward']);
                }
                if (layer.back() === true) {
                    this.order.disable.apply(this, ['back']);
                }
            },

            /**
             * disable
             * 
             * @access public
             * @param  String direction
             * @return void
             */
            disable: function(direction) {
                var selector = 'a[direction="' + (direction) + '"]';
                this.find(selector).attr('disabled', 'disabled');
            },

            /**
             * enable
             * 
             * @access public
             * @return void
             */
            enable: function() {
                this.find('div.tool.layer').find('a').removeAttr('disabled');
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.triggerHandler('show');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * BackgroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.BackgroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundBitmapImageToolbarView')
         */
        _string: 'BackgroundBitmapImageToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupBackgroundClear();
            this._setupBackgroundUpload();
        },

        /**
         * _setupBackgroundClear
         * 
         * @access protected
         * @return void
         */
        _setupBackgroundClear: function() {
            this.on({
                'clear': function(event, $anchor) {
                    var canvas = Canvases.Preview;
                    canvas.getSelectedLayer().setChangeOperationType('deleted');
                    canvas.clearBackgroundImageLayer();
                    canvas.render();
                    canvas.getBackgroundRectangleLayer().select();
                }
            });
        },

        /**
         * _setupBackgroundUpload
         * 
         * @access protected
         * @return void
         */
        _setupBackgroundUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var backgrounds = App.getEditor().getArea('backgrounds'),
                        dropzone = backgrounds.getDropzone();
                    dropzone.once({
                        'start': function() {
                            Stencil.navigate('/app/backgrounds/uploads');
                            Toolbars.hide();
                        }
                    });
                    dropzone.find('input[type="file"]').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.call(arguments));
            var content = App.getStage().getContent();
            content.handles.show.apply(content);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * BackgroundRectangleToolbarView
     * 
     * @extends ToolbarView
     */
    window.BackgroundRectangleToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not touch (and
         * should not) touch any underlying model logic.
         * 
         * @access protected
         * @var    Object
         */
        _set: {

            /**
             * backgroundColor
             * 
             * @access protected
             * @param  String rgba
             * @return void
             */
            'backgroundColor': function(rgba) {
                var $fill = this.find('[name="backgroundColor"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $fill.data('minicolors-initialized', false);
                $fill.minicolors('value', hex);
                $fill.minicolors('opacity', opacity);
                $fill.data('minicolors-initialized', true);
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BackgroundRectangleToolbarView')
         */
        _string: 'BackgroundRectangleToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupBackgroundColor();
            this._setupUpload();
            this.on({
                'clear/backgroundColor': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this.backgroundColor.clear.apply(this)
                    layer.triggerHandler('clear/backgroundColor');
                }
            });
        },

        /**
         * backgroundColor
         * 
         * @access protected
         * @var    Object
         */
        backgroundColor: {

            /**
             * clear
             * 
             * @access public
             * @return void
             */
            clear: function() {
                var $backgroundColor = this.find('[name="backgroundColor"]');
                $backgroundColor.minicolors('value', '');
                $backgroundColor.minicolors('opacity', '1');
            }
        },

        /**
         * _setupBackgroundColor
         * 
         * @access protected
         * @return void
         */
        _setupBackgroundColor: function() {
            var _this = this;
            this.find('[name="backgroundColor"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                opacity: true,

                /**
                 * change
                 * 
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    if (hex !== '') {
                        var type = 'change/backgroundColor',
                            color = rgba(hex, opacity.toFloat());
                        color = color.addSpacesToRgba();
                        Canvases.Preview.getSelectedLayer().triggerHandler(
                            type,
                            [color, false]
                        );
                        _this.triggerHandler(type, [color]);
                    }
                }
            });
        },

        /**
         * _setupUpload
         * 
         * @access protected
         * @return void
         */
        _setupUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var backgrounds = App.getEditor().getArea('backgrounds'),
                        dropzone = backgrounds.getDropzone();
                    dropzone.once({
                        'start': function() {
                            Stencil.navigate('/app/backgrounds/uploads');
                            Toolbars.hide();
                        }
                    });
                    dropzone.find('input[type="file"]').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var layer = Canvases.Preview.getSelectedLayer();
            this._super();
            this.order.auto.apply(this);
            if (layer.getStyle('backgroundColor').addSpacesToRgba() === 'rgba(0, 0, 0, 0)') {
                this.backgroundColor.clear.apply(this);
            } else {
                this._set.backgroundColor.apply(
                    this,
                    [layer.getStyle('backgroundColor')]
                );
            }
            var content = App.getStage().getContent();
            content.handles.show.apply(content);

            /**
             * See TextToolbarView for details on why this is needed.
             */
            this.find('[name="backgroundColor"]').removeData('minicolors-lastChange');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * BitmapImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.BitmapImageToolbarView = ToolbarView.extend({

        /**
         * _$scrollable
         * 
         * @access protected
         * @var    jQuery (default: null)
         */
        _$scrollable: null,

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not touch (and
         * should not) touch any underlying model logic.
         * 
         * @access protected
         * @var    Object
         */
        _set: {

            /**
             * blurStrength
             * 
             * @access protected
             * @param  String strength
             * @return void
             */
            'blurStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="blurStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * colorOverlay
             * 
             * @access protected
             * @param  false|String rgba
             * @return void
             */
            'colorOverlay': function(rgba) {
                var $backdrop = this.find('[name="colorOverlay"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $backdrop.data('minicolors-initialized', false);
                $backdrop.minicolors('value', hex);
                $backdrop.minicolors('opacity', opacity);
                $backdrop.data('minicolors-initialized', true);
                // $backdrop.trigger.delay(0, $backdrop, ['keyup']);
            },

            /**
             * colorOverlayStrength
             * 
             * @access protected
             * @param  String strength
             * @return void
             */
            'colorOverlayStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="colorOverlayStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * darkenStrength
             * 
             * @access protected
             * @param  String strength
             * @return void
             */
            'darkenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="darkenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * lightenStrength
             * 
             * @access protected
             * @param  String strength
             * @return void
             */
            'lightenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="lightenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * opacityStrength
             * 
             * @access protected
             * @param  String strength
             * @return void
             */
            'opacityStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="opacityStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'BitmapImageToolbarView')
         */
        _string: 'BitmapImageToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupColorOverlay();
            this._setupStrengthSlider('blur');
            this._setupStrengthSlider('colorOverlay');
            this._setupStrengthSlider('darken');
            this._setupStrengthSlider('lighten');
            this._setupStrengthSlider('opacity');
            this._setupTooltips();
            this._listenForPresetFilterEvents();
            if (Stencil.scrollbars() === true) {
                this._setupScrollbars();
            }

            // Color Overlay
            this.on({

                /**
                 * (anonymous)
                 * 
                 * @note I need to use the show method (instead of the reset
                 *       method) here, because BitmapImage layers debounce
                 *       before adding a filter object to the filters-array.
                 *       This can be seen in the BitmapImage.js layer class.
                 */
                'change/colorOverlay': function(event) {
                    this.colorOverlay.show.apply(this);
                    this.clearAllAnchor.show.apply(this);
                },
                'clear/all': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.clearFilters();
                    Toolbars.hide();
                    this.show({
                        focusOnActiveFilter: false
                    });
                    layer.setChangeOperationType('filter:allCleared');
                },
                'clear/colorOverlay': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this.colorOverlay.clear.apply(this);
                    this._set.colorOverlayStrength.apply(this, [0]);
                    layer.triggerHandler('clear/colorOverlay');
                    this.clearAllAnchor.reset.apply(this);
                }
            });

            // Firefox scrollbar init
            this.once({
                'show': function(event) {
                    this._refreshScrollbar();
                }
            });
        },

        /**
         * _focusOnActiveFilter
         * 
         * Focuses on the active filter (always one, since No Filter is an
         * option). Takes into consideration custom scrollbars, and when that's
         * the case, nulls the left margin calculation, since it's not used
         * with custom scrollbars.
         * 
         * Also note that it's important that the offset calculation occurs
         * after the scrollLeft offset reset (to value: 0), since not doing so
         * messes up things (not sure why at the moment).
         * 
         * @access protected
         * @return void
         */
        _focusOnActiveFilter: function() {
            var $content = this.find('div.tool.filters div.content'),
                $ul = $content.find('ul'),
                $li = $ul.find('li.active'),
                $thumb = $li.find('div.thumb');
            if ($li.length > 0) {
                if (Stencil.scrollbars() === true) {
                    this._$scrollable.data('jsp').scrollToX(0, false);
                    var offset = $li.position().left
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    this._$scrollable.data('jsp').scrollToX(offset, false);
                } else {
                    $content.animate({
                        scrollLeft: 0
                    }, 0);
                    var offset = $li.position().left
                        - $content.css('margin-left').toInt()
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    $content.animate({
                        scrollLeft: offset
                    }, 0);
                }
            }
        },

        /**
         * _listenForPresetFilterEvents
         * 
         * @note   I am adding an empty properties object when triggering a
         *         filter addition to ensure a consistent JSON makeup of filter
         *         objects. If I don't do this, Footer.js's changedCanvas method
         *         will fail, because the signature of a filter will sometimes
         *         include a properties object (because of the _normalizeFilters
         *         method in BitmapImage layers), and sometimes now.
         * @access protected
         * @return void
         */
        _listenForPresetFilterEvents: function() {
            this.on({
                'setFilter': function(event, $element) {
                    if ($element.hasClass('active') === false) {
                        var filter = $element.attr('filter'),
                            layer = Canvases.Preview.getSelectedLayer(),
                            filters = layer.getProperty('filters');

                        // 
                        var blacklist = ['blur', 'colorOverlay', 'darken', 'lighten', 'opacity'];
                        for (var i = filters.length - 1; i >= 0; i--) {
                            if (jQuery.inArray(filters[i].type, blacklist) === -1) {
                                // layer.set({'renderFilters': true});
                                layer.triggerHandler('filter/remove', [filters[i]]);
                            }
                        }
// StencilBooter.log(filters[i], obj);
//                             if (filters[i].type === obj.type) {
//                                 filters.splice(i, 1);
//                             }
//                         }
//                         var cotton = this.getCotton(),
//                             filters = cotton.filters || [];
//                         for (var i = filters.length - 1; i >= 0; i--) {
//                         jQuery.each(filters, function(index, obj) {
//                             if (jQuery.inArray(obj.type, blacklist) === -1) {
//                                 layer.triggerHandler('filter/remove', [obj]);
//                             }
//                         });

                        // Add filter and refresh the UI
                        layer.set({'renderFilters': true});
                        if (filter !== 'noFilter') {
                            layer.triggerHandler('filter/add', [{
                                type: filter,
                                properties: {}
                            }]);
                            layer.setChangeOperationType('filter:preset:set');
                        } else {
                            Canvases.Preview.render();
                            layer.setChangeOperationType('filter:preset:cleared');
                        }

                        // Ensure anchor is / isn't showing (where appropriate)
                        this.clearAllAnchor.reset.apply(this);

                        // UI in toolbar
                        var $filters = this.find('li[filter]'),
                            $filter = this.find('li[filter="' + (filter) + '"]'),
                            cotton = layer.getDrawing().getCotton(),
                            callback = function() {
                                $filters.removeAttr('disabled');
                                cotton.off('applyFilters/complete', callback);
                                $filter.removeClass('loading');
                                $filter.addClass('active');
                            };
                        $filters.attr('disabled', 'disabled');
                        $filters.removeClass('active');
                        $filters.removeClass('loading');
                        if (filter === 'noFilter') {
                            callback();
                        } else {
                            $filter.addClass('loading');
                            cotton.on({
                                'applyFilters/complete': callback
                            })
                        }
                    }
                }
            });
        },

        /**
         * _refreshScrollbar
         * 
         * @access protected
         * @return void
         */
        _refreshScrollbar: function() {
            this._$scrollable && this._$scrollable.data('jsp').reinitialise();
        },

        /**
         * _scrollable
         * 
         * @access protected
         * @param  jQuery $element
         * @return void
         */
        _scrollable: function($element) {
            this._$scrollable = $element;
            this._$scrollable.jScrollPane({
                animateScroll: true,
                animateDuration: 200
            });
        },

        /**
         * _setupColorOverlay
         * 
         * @access protected
         * @return void
         */
        _setupColorOverlay: function() {
            var _this = this;
            this.find('[name="colorOverlay"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                // opacity: true,

                /**
                 * change
                 * 
                 * @note   A hardcoded opacity of 1 is set here because the
                 *         opacity cannot be set for the color overlay filter of
                 *         bitmap images. See:
                 *         https://i.imgur.com/H4DHub5.png
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    if (hex !== '') {
                        var type = 'change/colorOverlay',
                            color = rgba(hex, 1);//opacity.toFloat());
                        color = color.addSpacesToRgba();
                        Canvases.Preview.getSelectedLayer().triggerHandler(
                            type,
                            [color]
                        );
                        _this.triggerHandler(type, [color]);
                    }
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @see    https://jsfiddle.net/8bnp7c39/8/
         * @access public
         * @return void
         */
        _setupScrollbars: function() {
            var $filters = this.find('div.tool.filters');
            if ($filters.length > 0) {
                this._scrollable($filters.find('.content'));
            }
        },

        /**
         * _setupStrengthSlider
         * 
         * @access protected
         * @param  String type
         * @return void
         */
        _setupStrengthSlider: function(type) {
            var _this = this,
                label = (type) + 'Strength',
                selector = 'input[type="range"][name="' + (label) + '"]',
                $range = this.find(selector),
                listener = function(event) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        layer.triggerHandler('change/' + (label), [value]);

                        // Ensure anchor is / isn't showing (where appropriate)
                        _this.clearAllAnchor.reset.apply(_this);
                    }
                },
                filterResampleDelay = Stencil.getFilterResampleDelay();
            if (Browser.ie() === true) {
                $range.on({
                    'change': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'change': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            } else {
                $range.on({
                    'input': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'input': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            }

            // Change history
            $range.on({
                'mouseup': function(event) {
                    (function() {
                        App.triggerHandler('changeHistory/track');
                    }).delay(filterResampleDelay);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._setupTooltip('blurStrength');
            this._setupTooltip('opacityStrength');
            this._setupTooltip('lightenStrength');
            this._setupTooltip('darkenStrength');
            this._setupTooltip('colorOverlayStrength');
        },

        /**
         * colorOverlay
         * 
         * @access public
         * @var    Object
         */
        colorOverlay: {

            /**
             * clear
             * 
             * @access public
             * @return void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/colorOverlay"]');
                $lookup.addClass('hidden');
                this.find('[name="colorOverlay"]').minicolors('value', '');
                this.find('[name="colorOverlay"]').minicolors('opacity', '1');
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access public
             * @return void
             */
            show: function() {
                var $outline = this.find('[name="colorOverlay"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * clearAllAnchor
         * 
         * @access public
         * @var    Object
         */
        clearAllAnchor: {

            /**
             * hide
             * 
             * @access public
             * @return void
             */
            hide: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.addClass('hidden');
            },

            /**
             * show
             * 
             * @access public
             * @return void
             */
            show: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.removeClass('hidden');
            },

            /**
             * reset
             * 
             * @access public
             * @return void
             */
            reset: function() {
                var layer = Canvases.Preview.getSelectedLayer(),
                    filters = layer.getProperty('filters');
                this.clearAllAnchor.hide.apply(this);
                if (filters.length > 0) {
                    this.clearAllAnchor.show.apply(this);
                }
            }
        },

        /**
         * show
         * 
         * @access public
         * @param  Object options
         * @return void
         */
        show: function(options) {
            options = options || {};
            var layer = Canvases.Preview.getSelectedLayer();
            this._super();

            // Active preset filter
            var filters = layer.getProperty('filters');
            this.find('[filter]').removeClass('active');
            this.find('[filter="noFilter"]').addClass('active');
            this.clearAllAnchor.reset.apply(this);
            if (filters.length > 0) {
                var index, type;
                for (index in filters) {
                    type = filters[index].type
                    if (this.find('[filter="' + (type) + '"]').length > 0) {
                        this.find('[filter]').removeClass('active');
                        this.find('[filter="' + (type) + '"]').addClass('active');
                        break;
                    }
                }
            }

            // Whether to auto scroll to the active filter
            if (
                options.focusOnActiveFilter === undefined ||
                options.focusOnActiveFilter === true
            ) {
                this._focusOnActiveFilter();
            }

            // Color Overlay
            // if (layer.getStyle('colorOverlay') !== false) {
            //     this._set.colorOverlay.apply(
            //         this,
            //         [layer.getStyle('colorOverlay')]
            //     );
            //     this.colorOverlay.show.apply(this);
            // } else {
            //     this.colorOverlay.clear.apply(this);
            // }

            /**
             * This resets the internal minicolors object that keeps track of
             * what the last color was. This is to address a bug whereby if the
             * copy + pasted the same color into other fields, the color would
             * not take effect, since minicolors did not think anything has
             * changed (since the input itself is the same one between text
             * layers).
             */
            var selectors = ['[name="colorOverlay"]'],
                selector = selectors.join(',');
            this.find(selector).removeData('minicolors-lastChange');

            /**
             * Secondary filters
             * 
             */

            // Blur
            var filter = layer.getFilter('blur'),
                strength = filter === false ? 0 : filter.properties.strength;
            this._set.blurStrength.apply(this, [strength]);

            // Opacity
            filter = layer.getFilter('opacity');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.opacityStrength.apply(this, [strength]);

            // Lighten
            filter = layer.getFilter('lighten');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.lightenStrength.apply(this, [strength]);

            // Darken
            filter = layer.getFilter('darken');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.darkenStrength.apply(this, [strength]);

            // Color Overlay (strength)
            filter = layer.getFilter('colorOverlay');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.colorOverlayStrength.apply(this, [strength]);

            // Color Overlay (color)
            filter = layer.getFilter('colorOverlay');
            if (filter !== false) {
                this._set.colorOverlay.apply(this, [filter.properties.color]);
                this.colorOverlay.show.apply(this);
            } else {
                this.colorOverlay.clear.apply(this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * ForegroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.ForegroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'ForegroundBitmapImageToolbarView')
         */
        _string: 'ForegroundBitmapImageToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.call(arguments));
            this.order.auto.apply(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * TextToolbarView
     * 
     * @note    minicolors always fires the <change> method, even when the color
     *          and/or opacity are set manually. To get around this (since I
     *          only want the event firing when it's manually changed), I use
     *          an internal property called <minicolors-initialized>, which
     *          prevents the event from firing. Take note of this if you decide
     *          to upgrade the minicolors library. See here for more info:
     *          https://github.com/claviska/jquery-minicolors/issues/183
     * @fires   change/backdropColor
     *          change/fontFamily
     *          change/strokeColor
     * @extends ToolbarView
     */
    window.TextToolbarView = ToolbarView.extend({

        /**
         * _font
         * 
         * The font that is currently set (used in conjunction with font
         * previewing).
         * 
         * @access protected
         * @var    false|Object (default: false)
         */
        _font: false,

        /**
         * _fontsDropdown
         * 
         * @access protected
         * @var    false|FontsDropdownView (default: false)
         */
        _fontsDropdown: false,

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $checkbox
                     * @return void
                     */
                    'input#backdropStretch': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked'),
                            backdropStretch = checked === true
                                ? 'full'
                                : 'slim';
                        this.triggerHandler(
                            'change/backdropStretch',
                            [backdropStretch]
                        );
                    }
                }
            });
        },

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not touch (and
         * should not) touch any underlying model logic.
         * 
         * @access protected
         * @var    Object
         */
        _set: {

            /**
             * align
             * 
             * @access protected
             * @param  String position
             * @return void
             */
            'align': function(position) {
                this.find('[name^="align"]').removeClass('active');
                this.find('[name="align[' + (position) + ']"]').addClass(
                    'active'
                );
            },

            /**
             * backdropColor
             * 
             * @access protected
             * @param  false|String rgba
             * @return void
             */
            'backdropColor': function(rgba) {
                var $backdrop = this.find('[name="backdropColor"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $backdrop.data('minicolors-initialized', false);
                $backdrop.minicolors('value', hex);
                $backdrop.minicolors('opacity', opacity);
                $backdrop.data('minicolors-initialized', true);
                // $backdrop.trigger.delay(0, $backdrop, ['keyup']);
            },

            /**
             * backdropStretch
             * 
             * @access protected
             * @param  String backdropStretch
             * @return void
             */
            'backdropStretch': function(backdropStretch) {
                var $backdropStretch = this.find('[id="backdropStretch"]');
                $backdropStretch.prop('checked', backdropStretch === 'full');
            },

            /**
             * bold
             * 
             * @access protected
             * @param  Boolean on
             * @return void
             */
            'bold': function(on) {
                var $bold = this.find('[name="bold"]');
                $bold.removeClass('active');
                if (on === true) {
                    $bold.addClass('active');
                }
            },

            /**
             * fontFamily
             * 
             * @note   <select> call below triggers dropdown <select>
                       handler, which triggers <change/fontFamily> handler
             * @access protected
             * @param  String font
             * @return void
             */
            'fontFamily': function(font) {
                var font = Stencil.account().collection('fonts').findByFamilyName(font);
                this._fontsDropdown.selectFont(font);
            },

            /**
             * fontSize
             * 
             * @access protected
             * @param  String size
             * @return void
             */
            'fontSize': function(size) {
                var $range = this.find('input[type="range"][name="fontSize"]');
                if (Stencil.get('config').defaults.skewFontSizeValues === true) {
                    var uiValue = size;
                    size = this._getFontSizeStepValue(size);
                    $range.attr('data-ui-value', uiValue);
                }
                $range.val(size);
                this._positionTooltip($range);
            },

            /**
             * italic
             * 
             * @access protected
             * @param  Boolean on
             * @return void
             */
            'italic': function(on) {
                var $italic = this.find('[name="italic"]');
                $italic.removeClass('active');
                if (on === true) {
                    $italic.addClass('active');
                }
            },

            /**
             * lineHeight
             * 
             * @access protected
             * @param  String height
             * @return void
             */
            'lineHeight': function(height) {
                var $range = this.find(
                    'input[type="range"][name="lineHeight"]'
                );
                $range.val(height);
                this._positionTooltip($range);
            },

            /**
             * position
             * 
             * @access protected
             * @param  Number position
             * @return void
             */
            // 'position': function(position) {
            //     StencilBooter.log('positioning');
            // },

            /**
             * shadowStrength
             * 
             * @note   undefined check here is to prevent possible issues with
             *         text layers created previously that do not have a
             *         shadowStrength property defined
             * @access protected
             * @param  String height
             * @return void
             */
            'shadowStrength': function(value) {
                var $range = this.find(
                    'input[type="range"][name="shadowStrength"]'
                );
                value = value === undefined ? 0 : value;
                $range.val(value);
                this._positionTooltip($range);
            },

            /**
             * strokeColor
             * 
             * @access protected
             * @param  false|String rgba
             * @return void
             */
            'strokeColor': function(rgba) {
                var $outline = this.find('[name="strokeColor"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $outline.data('minicolors-initialized', false);
                $outline.minicolors('value', hex);
                $outline.minicolors('opacity', opacity);
                $outline.data('minicolors-initialized', true);
                // $outline.trigger.delay(0, $outline, ['keyup']);
            },

            /**
             * textColor
             * 
             * @access protected
             * @param  String rgba
             * @return void
             */
            'textColor': function(rgba) {
                var $text = this.find('[name="textColor"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $text.data('minicolors-initialized', false);
                $text.minicolors('value', hex);
                $text.minicolors('opacity', opacity);
                $text.data('minicolors-initialized', true);
                // $text.trigger.delay(0, $text, ['keyup']);
            },

            /**
             * underline
             * 
             * @access protected
             * @param  Boolean on
             * @return void
             */
            'underline': function(on) {
                var $underline = this.find('[name="underline"]');
                $underline.removeClass('active');
                if (on === true) {
                    $underline.addClass('active');
                }
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'TextToolbarView')
         */
        _string: 'TextToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._drawFontsDropdown();
            this._setupBackdropColor();
            this._setupShadowStrength();
            this._setupFontSize();
            this._setupLineHeight();
            this._setupStrokeColor();
            this._setupTextColor();
            this._setupTooltips();
            // this._setupListeners();

            // Outline + Backdrop
            this.on({

                /**
                 * (anonymous)
                 * 
                 * Enables/disables parts of the UI based on what styles of the
                 * font are available.
                 * 
                 * @access private
                 * @param  Object event
                 * @param  FontAccessor font
                 * @return void
                 */
                'change/fontFamily': function(event, font) {
                    font.loadFull();
                    this.toggleBoldAction();
                    this.toggleItalicAction();
                },
                'change/backdropColor': function(event) {
                    this.backdropColor.show.apply(this);
                },
                'change/strokeColor': function(event) {
                    this.strokeColor.show.apply(this);
                }
            });

            // Events
            this.on({
                'clear/backdropColor': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this.backdropColor.clear.apply(this);
                    layer.triggerHandler('clear/backdropColor');
                },
                'clear/strokeColor': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this.strokeColor.clear.apply(this);
                    layer.triggerHandler('clear/strokeColor');
                },
                'set/align/center': function(event) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this._set.align.apply(this, ['center']);
                    layer.triggerHandler('change/align', ['center']);
                },
                'set/align/left': function(event) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this._set.align.apply(this, ['left']);
                    layer.triggerHandler('change/align', ['left']);
                },
                'set/align/right': function(event) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    this._set.align.apply(this, ['right']);
                    layer.triggerHandler('change/align', ['right']);
                },
                'change/backdropStretch': function(event, type) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/backdropStretch', [type]);
                },
                'toggle/bold': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.bold.apply(this, [!on]);
                    layer.triggerHandler('change/bold', [!on]);
                },
                'toggle/italic': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.italic.apply(this, [!on]);
                    layer.triggerHandler('change/italic', [!on]);
                },
                'toggle/underline': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.underline.apply(this, [!on]);
                    layer.triggerHandler('change/underline', [!on]);
                }
            });
        },

        /**
         * _drawFontsDropdown
         * 
         * @access protected
         * @return void
         */
        _drawFontsDropdown: function() {

            // Draw and create view
            var fontsCollection = Stencil.account().collection('fonts'),
                $fontsDropdown = Stencil.render('FontsDropdown', {
                    fontsCollection: fontsCollection
                });
            this._element.find('div.tool.font').append($fontsDropdown);
            this._fontsDropdown = new FontsDropdownView(
                $fontsDropdown,
                fontsCollection
            );

            // Events
            var _this = this;
            this._fontsDropdown.on({

                /**
                 * Note that the order here is very important. Some listeners
                 * on the TextToolbarView's change/fontFamily-event lookup the
                 * selected-layer's font. So to ensure the value it receives is
                 * up-to-date, I need to trigger the layer's
                 * change/fontFamily-event first.
                 */

                /**
                 * (anonymous)
                 * 
                 * @access private
                 * @param  Object event
                 * @param  FontAccessor font
                 * @return void
                 */
                'select': function(event, font) {
                    Canvases.Preview.getSelectedLayer().triggerHandler(
                        'change/fontFamily',
                        [font]
                    );
                    _this.triggerHandler('change/fontFamily', [font]);
                },

                /**
                 * (anonymous)
                 * 
                 * @access private
                 * @param  Object event
                 * @param  FontAccessor font
                 * @return void
                 */
                'hover': function(event, font) {
                    Canvases.Preview.getSelectedLayer().getDrawing().triggerHandler(
                        'preview/fontFamily',
                        [font]
                    );
                },

                /**
                 * (anonymous)
                 * 
                 * @access private
                 * @param  Object event
                 * @param  FontAccessor font
                 * @return void
                 */
                'open': function(event) {
                    this.once({
                        'hover': function(event, font) {
                            var layer = Canvases.Preview.getSelectedLayer();
                            layer.triggerHandler('revert/bold');
                            layer.triggerHandler('revert/italic');
                            _this._set.bold.apply(_this, [false]);
                            _this._set.italic.apply(_this, [false]);
                        }
                    });
                },
                /**
                 * (anonymous)
                 * 
                 * This one is a bit more complicated. It's written to
                 * accommodate two cases:
                 * 1) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click out of the toolbar. In
                 *    that case, the layer becomes the previously selected one
                 *    (since the event that discards it fires first).
                 * 2) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click escape key to get out of
                 *    it. In that case, the layer is still selected, and
                 *    therefore should be accessed through that to have the font
                 *    revert.
                 * 
                 * @note   Always check selected before previous, otherwise
                 *         it might change the wrong text layer.
                 * @access private
                 * @param  Object event
                 * @return void
                 */
                'close': function(event) {
                    var font = this.getSelectedFont(),
                        selectedLayer = Canvases.Preview.getSelectedLayer(),
                        previouslySelectedLayer = Canvases.Preview.getPreviouslySelectedLayer();
                    if (selectedLayer !== false) {
                        selectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    } else if (previouslySelectedLayer !== false) {
                        previouslySelectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    }
                    // else if (selected !== false) {
                    //     selected.triggerHandler('change/fontFamily', [font]);
                    // }
                }
            });
        },

        /**
         * _getFontSizeSkewedValue
         * 
         * @see    http://www.xuru.org/rt/PR.asp
         * @see    https://local.getstencil.com/test/polynomial
         * @access protected
         * @param  Number value
         * @return Number
         */
        _getFontSizeSkewedValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 200) {
                return 2 * value - 101;// incremement by 2
            }
            if (value <= 225) {
                return 4 * value - 503;// incrememnt by 4
            }
            return 400;
        },

        /**
         * _getFontSizeStepValue
         * 
         * Returns the step number (used in the range input) based on the font
         * size value. I'm rounding here, because since we no longer have every
         * font size value represented as a possible step in the range input,
         * it's possible the calculations below result in a non-whole number,
         * which wouldn't make sense when setting the value of the input. It
         * would likely cause issues with the tooltips that are shown.
         * 
         * @access protected
         * @param  Number value
         * @return Number
         */
        _getFontSizeStepValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 301) {
                return ((value + 101) / 2).round(0);
            }
            if (value <= 397) {
                return ((value + 503) / 4).round(0);
            }
            return 226;
        },

        /**
         * _setupBackdropColor
         * 
         * @access protected
         * @return void
         */
        _setupBackdropColor: function() {
            var _this = this;
            this.find('[name="backdropColor"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                opacity: true,

                /**
                 * change
                 * 
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    if (hex !== '') {
                        var type = 'change/backdropColor',
                            color = rgba(hex, opacity.toFloat());
                        color = color.addSpacesToRgba();
                        Canvases.Preview.getSelectedLayer().triggerHandler(
                            type,
                            [color]
                        );
                        _this.triggerHandler(type, [color]);
                    }
                }
            });
        },

        /**
         * _setupFontSize
         * 
         * @see    http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access protected
         * @return void
         */
        _setupFontSize: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="fontSize"]'),
                listener = function(event) {
                    // var tooltip = $range.data('bs.tooltip');
                    // var size = _this._sizes.min + this.getStep()[0] - 1,
                    //     type = 'change/fontSize';
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (Stencil.get('config').defaults.skewFontSizeValues === true) {
                        value = _this._getFontSizeSkewedValue(value);
                        $range.attr('data-ui-value', value);
                    }
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/fontSize', [value]);
                    }
                };
            if (Browser.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupLineHeight
         * 
         * @see    http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access protected
         * @return void
         */
        _setupLineHeight: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="lineHeight"]'),
                listener = function(event) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/lineHeight', [value]);
                    }
                };
            if (Browser.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupShadowStrength
         * 
         * @see    http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access protected
         * @return void
         */
        _setupShadowStrength: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="shadowStrength"]'),
                listener = function(event) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/shadowStrength', [value]);
                    }
                };
            if (Browser.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupTooltips
         * 
         * @access protected
         * @return void
         */
        _setupTooltips: function() {
            this._setupTooltip('fontSize');
            this._setupTooltip('lineHeight');
            this._setupTooltip('shadowStrength');
        },

        /**
         * _setupStrokeColor
         * 
         * @access protected
         * @return void
         */
        _setupStrokeColor: function() {
            var _this = this;
            this.find('[name="strokeColor"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                opacity: true,

                /**
                 * change
                 * 
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    if (hex !== '') {
                        var type = 'change/strokeColor',
                            color = rgba(hex, opacity.toFloat());
                        color = color.addSpacesToRgba();
                        Canvases.Preview.getSelectedLayer().triggerHandler(
                            type,
                            [color]
                        );
                        _this.triggerHandler(type, [color]);
                    }
                }
            });
        },

        /**
         * _setupTextColor
         * 
         * @access protected
         * @return void
         */
        _setupTextColor: function() {
            var _this = this;
            this.find('[name="textColor"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                opacity: true,

                /**
                 * change
                 * 
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    hex = hex === '' ? '#000000' : hex;
                    var type = 'change/textColor',
                        color = rgba(hex, opacity.toFloat());
                    color = color.addSpacesToRgba();
                    Canvases.Preview.getSelectedLayer().triggerHandler(
                        type,
                        [color]
                    );
                }
            });
        },

        /**
         * _setupListeners
         * 
         * @access protected
         * @return void
         */
        // _setupListeners: function() {
        //     var events = [
        //         'change/align',
        //         'change/backdropColor',
        //         'change/bold',
        //         'change/fontFamily',
        //         'change/fontSize',
        //         'change/italic',
        //         'change/strokeColor',
        //         'change/textColor',
        //         'change/underline',
        //         'preview/fontFamily'
        //     ];
        //     this.on(events.join(' '), function(event, value) {
        //         var layer = Canvases.Preview.getSelectedLayer();
        //         if (layer !== false) {
        //             layer.triggerHandler(event.type, [value]);
        //         }
        //     });
        // },

        /**
         * bold
         * 
         * @access protected
         * @var    Object
         */
        bold: {

            /**
             * disable
             * 
             * @access public
             * @return void
             */
            disable: function() {
                this.find('[name="bold"]').attr('disabled', 'disabled');
            },

            /**
             * enable
             * 
             * @access public
             * @return void
             */
            enable: function() {
                this.find('[name="bold"]').removeAttr('disabled');
            }
        },

        /**
         * backdropColor
         * 
         * @access protected
         * @var    Object
         */
        backdropColor: {

            /**
             * clear
             * 
             * @access public
             * @return void
             */
            clear: function() {
                var $clear = this.find('[lookup="clear/backdropColor"]'),
                    $backdropStretch = this.find('[lookup="backdropStretch"]');
                $clear.addClass('hidden');
                $backdropStretch.addClass('hidden');
                this.getElement().removeClass('backdropExpanded');
                this.find('[name="backdropColor"]').minicolors('value', '');
                this.find('[name="backdropColor"]').minicolors('opacity', '1');
                // this.find('[name="backdropColor"]').minicolors('value', {
                //     color: '',
                //     opacity: '1'
                // });
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the backdrop
             * color input (when a value is defined).
             * 
             * @access public
             * @return void
             */
            show: function() {
                var $backdropColor = this.find('[name="backdropColor"]'),
                    $column = $backdropColor.closest('div.column'),
                    $clear = $column.find('a'),
                    $type = $column.find('div.type');
                $clear.addClass('hidden');
                $type.addClass('hidden');
                if ($backdropColor.val() !== '') {
                    $clear.removeClass('hidden');
                    this.getElement().addClass('backdropExpanded');
                    $type.removeClass('hidden');
                }
            }
        },

        /**
         * getFontsDropdown
         * 
         * @access public
         * @return FontsDropdownView
         */
        getFontsDropdown: function() {
            return this._fontsDropdown;
        },

        /**
         * italic
         * 
         * @access protected
         * @var    Object
         */
        italic: {

            /**
             * disable
             * 
             * @access public
             * @return void
             */
            disable: function() {
                this.find('[name="italic"]').attr('disabled', 'disabled');
            },

            /**
             * enable
             * 
             * @access public
             * @return void
             */
            enable: function() {
                this.find('[name="italic"]').removeAttr('disabled');
            }
        },

        /**
         * strokeColor
         * 
         * @access protected
         * @var    Object
         */
        strokeColor: {

            /**
             * clear
             * 
             * @access public
             * @return void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/strokeColor"]');
                $lookup.addClass('hidden');
                this.find('[name="strokeColor"]').minicolors('value', '');
                this.find('[name="strokeColor"]').minicolors('opacity', '1');
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access public
             * @return void
             */
            show: function() {
                var $outline = this.find('[name="strokeColor"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var layer = Canvases.Preview.getSelectedLayer();
            this._super();
            this._set.fontFamily.apply(this, [layer.getStyle('fontFamily')]);
            this._set.align.apply(this, [layer.getStyle('align')]);
            if (layer.getStyle('backdropColor') !== false) {
                this._set.backdropColor.apply(
                    this,
                    [layer.getStyle('backdropColor')]
                );
                this._set.backdropStretch.apply(
                    this,
                    [layer.getStyle('backdropStretch')]
                );
                this.backdropColor.show.apply(this);
            } else {
                this.backdropColor.clear.apply(this);
                this._set.backdropStretch.apply(
                    this,
                    ['slim']
                );
            }
            this._set.bold.apply(this, [layer.getStyle('bold')]);
            this.toggleBoldAction();
            this._set.italic.apply(this, [layer.getStyle('italic')]);
            this.toggleItalicAction();
            // this._set.order.apply(this, [layer.getStyle('order')]);
            this._set.fontSize.apply(this, [layer.getStyle('fontSize')]);
            this._set.lineHeight.apply(this, [layer.getStyle('lineHeight')]);
            this._set.shadowStrength.apply(this, [layer.getStyle('shadowStrength')]);
            this.order.auto.apply(this);
            this._set.underline.apply(this, [layer.getStyle('underline')]);
            this._set.textColor.apply(this, [layer.getStyle('textColor')]);
            if (layer.getStyle('strokeColor') !== false) {
                this._set.strokeColor.apply(
                    this,
                    [layer.getStyle('strokeColor')]
                );
                this.strokeColor.show.apply(this);
            } else {
                this.strokeColor.clear.apply(this);
            }

            /**
             * This resets the internal minicolors object that keeps track of
             * what the last color was. This is to address a bug whereby if the
             * copy + pasted the same color into other fields, the color would
             * not take effect, since minicolors did not think anything has
             * changed (since the input itself is the same one between text
             * layers).
             */
            var selectors = [
                    '[name="textColor"]',
                    '[name="strokeColor"]',
                    '[name="backdropColor"]'
                ],
                selector = selectors.join(',');
            this.find(selector).removeData('minicolors-lastChange');
        },

        /**
         * toggleBoldAction
         * 
         * This method is used to determine whether or not the bold-button
         * should be clickable.
         * 
         * @access public
         * @return void
         */
        toggleBoldAction: function() {
            var layer = Canvases.Preview.getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (font.get('bold').toInt() === 1) {
                this.bold.enable.apply(this);
            } else {
                this.bold.disable.apply(this);
            }
        },

        /**
         * toggleItalicAction
         * 
         * This method is used to determine whether or not the italic-button
         * should be clickable.
         * 
         * @access public
         * @return void
         */
        toggleItalicAction: function() {
            var layer = Canvases.Preview.getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (Browser.italic() === true || font.get('italic').toInt() === 1) {
                this.italic.enable.apply(this);
            } else {
                this.italic.disable.apply(this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * VectorImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.VectorImageToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not touch (and
         * should not) touch any underlying model logic.
         * 
         * @access protected
         * @var    Object
         */
        _set: {

            /**
             * fillColor
             * 
             * @access protected
             * @param  String rgba
             * @return void
             */
            'fillColor': function(rgba) {
                var $fill = this.find('[name="fillColor"]'),
                    color = pusher.color(rgba),
                    hex = color.hex6(),
                    opacity = color.rgba().pop();
                $fill.data('minicolors-initialized', false);
                $fill.minicolors('value', hex);
                $fill.minicolors('opacity', opacity);
                $fill.data('minicolors-initialized', true);
            }
        },

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'VectorImageToolbarView')
         */
        _string: 'VectorImageToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
            this._setupFillColor();
        },

        /**
         * _setupFillColor
         * 
         * @access protected
         * @return void
         */
        _setupFillColor: function() {
            var _this = this;
            this.find('[name="fillColor"]').minicolors({
                format: 'hex',
                position: 'bottom right',
                opacity: true,

                /**
                 * change
                 * 
                 * @access private
                 * @param  String hex When the hex is invalid, it will be an
                 *         empty string
                 * @param  String opacity
                 * @return void
                 */
                change: function(hex, opacity) {
                    if (hex.match(/^rgb/) !== null) {
                        var parsedColor = pusher.color(hex);
                        hex = parsedColor.hex6();
                    }
                    hex = hex === '' ? '#000000' : hex;
                    var type = 'change/fillColor',
                        color = rgba(hex, opacity.toFloat());
                    color = color.addSpacesToRgba();
                    Canvases.Preview.getSelectedLayer().triggerHandler(
                        type,
                        [color]
                    );
                }
            });
        },

        /**
         * show
         * 
         * @access public
         * @return void
         */
        show: function() {
            var layer = Canvases.Preview.getSelectedLayer();
            this._super();
            this.order.auto.apply(this);
            this._set.fillColor.apply(this, [layer.getStyle('fillColor')]);

            /**
             * See TextToolbarView for details on why this is needed.
             */
            this.find('[name="fillColor"]').removeData('minicolors-lastChange');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * WatermarkBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.WatermarkBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'WatermarkBitmapImageToolbarView')
         */
        _string: 'WatermarkBitmapImageToolbarView',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * show
         * 
         * Removing the previously set delete listener to ensure that a weird
         * race-condition does not happen whereby the layer is deleted, and then
         * can no longer (efficiently) be accessed. Cleaner to have the delete
         * listener all here.
         * 
         * @access public
         * @return void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.call(arguments));
            this.unbind('delete');
            this.on({
                'delete': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('delete');
                    layer.getWatermark().set({
                        'settings.active': 0
                    });
                    layer.getWatermark().save(['settings.active']);
                }
            });
            this.order.auto.apply(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Simple', function() {

    /**
     * View
     * 
     * @extends Simple
     */
    window.View = Simple.extend({

        /**
         * _busy
         * 
         * @access protected
         * @var    false|BusyModalView (default: false)
         */
        _busy: false,

        /**
         * _element
         * 
         * @access protected
         * @var    null|jQuery (default: null)
         */
        _element: null,

        /**
         * _events
         * 
         * @access protected
         * @var    Object (default: {})
         */
        _events: {},

        /**
         * _handlerType
         * 
         * @access protected
         * @var    String (default: 'view')
         */
        _handlerType: 'view',

        /**
         * _listeners
         * 
         * @access protected
         * @var    Function
         */
        _listeners: function() {
            return {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @note   Without the <stopPropagation> call below, multiple views
                     *         will catch the event since events are bound as live
                     *         events. This is needed to say "only count it once"
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger]:not([disabled])': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                        var trigger = $element.attr('trigger');
                        this.triggerHandler(trigger, [$element]);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[click][trigger][disabled]': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                focus: {

                    /**
                     * (anonymous)
                     * 
                     * Firefox bug where you can focus on a readonly element
                     * 
                     * @note   Without the <stopPropagation> call below, multiple views
                     *         will catch the event since events are bound as live
                     *         events. This is needed to say "only count it once"
                     * @see    http://stackoverflow.com/questions/7917592/html-cursor-showing-in-readonly-input-text
                     * @access private
                     * @param  jQuery event
                     * @param  jQuery $element
                     * @return void
                     */
                    '[readonly]': function(event, $element) {
                        event.stopPropagation();
                        $element.blur();
                    }
                }
            };
        },

        /**
         * _logEvents
         * 
         * @access protected
         * @var    Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _string
         * 
         * @access protected
         * @var    String (default: 'View')
         */
        _string: 'View',

        /**
         * init
         * 
         * @access public
         * @param  jQuery element
         * @return void
         */
        init: function(element) {
            if (element.length > 1) {
                throw new Error('Invalid view instantiation');
            }
            this._element = element;
            this._super();
            this._setupTabindex();
            this._setupListeners();
            // this._events = this._events();
            // this._setupTooltips();
        },

        /**
         * _getModel
         * 
         * @access protected
         * @param  String model
         * @return void
         */
        _getModel: function(model) {
            return Stencil.getModel(model);
        },

        /**
         * _setupListeners
         * 
         * @note   Passes event and jQuery reference to current target
         * @access protected
         * @return void
         */
        _setupListeners: function() {
            var _this = this,
                listeners = this._listeners();
            // if (this._listeners.constructor === Function.constructor) {
            // this._listeners = this._listeners();
            // }
            jQuery.each(
                listeners,
                function(type, listener) {
                    jQuery.each(
                        listener,
                        function(selector, callback) {
                            _this._element.on(
                                type,
                                selector,
                                function(event) {
                                    if (typeof callback === 'string') {
                                        callback = _this._events[callback];
                                    }
                                    callback.apply(_this, [
                                        event,
                                        $(event.currentTarget)
                                    ]);
                                }
                            );
                        }
                    );
                }
            );
        },

        /**
         * _setupTabindex
         * 
         * Sets the tabindex value for any inputs found within the view,
         * ensuring that it's never a duplicate, and always incremented
         * properly. Important to use .find call to ensure modals do not repeat
         * defining the tabindex on an input.
         * 
         * @access protected
         * @return void
         */
        _setupTabindex: function() {
            if (Browser.firefox() === true) {
                this.find('[tabindex]').removeAttr('tabindex');
            } else {
                var tabindex = Stencil.get('tabindex');
                if (tabindex === undefined) {
                    tabindex = 0;
                }
                var $tabs = this.find('[tabindex]'),
                    $tab;
                jQuery.each($tabs, function(index, tab) {
                    $tab = $(tab);
                    if ($tab.data('tabindexed') === undefined) {
                        tabindex++;
                        $tab.data('tabindexed', true);
                        $tab.attr('tabindex', tabindex);
                    }
                });
                Stencil.set('tabindex', tabindex);
            }
        },

        /**
         * find
         * 
         * @access public
         * @param  String selector
         * @return jQuery
         */
        find: function(selector) {
            return this._element.find(selector);
        },

        /**
         * _setupTooltips
         * 
         * @see    http://stackoverflow.com/questions/9958825/how-do-i-bind-twitter-bootstrap-tooltips-to-dynamically-created-elements
         * @access protected
         * @return void
         */
        // _setupTooltips: function() {
        //     var _this = this,
        //         container = this._tooltip && this._tooltip.container
        //             || this._element;
        //     this._element.find('[tooltip]').each(
        //         function(index, element) {
        //             $(element).tooltip({
        //                 html: true,
        //                 container: container,
        //                 placement: 'bottom',
        //                 title: $(element).attr('tooltip')
        //             });
        //         }
        //     );
        // },

        /**
         * clean
         * 
         * @see    http://stackoverflow.com/questions/446892/how-to-find-event-listeners-on-a-dom-node
         * @see    http://pragmatic-backbone.com/views
         * @access public
         * @return void
         */
        // clean: function() {
        //     $(this).unbind();
        //     // var events = jQuery._data(this, 'events');
        // },

        /**
         * getBusy
         * 
         * @access public
         * @return BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = Stencil.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.append($busy);
            }
            return this._busy;
        },

        /**
         * getElement
         * 
         * @access public
         * @return HTMLElement
         */
        getElement: function() {
            return this._element;
        },

        /**
         * hourglass
         * 
         * @access public
         * @return void
         */
        hourglass: function() {
            this._element.hourglass();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Stencil', function() {

    /**
     * Router
     * 
     * @see     http://pragmatic-backbone.com/routing-and-controllers
     * @see     http://stackoverflow.com/questions/14526752/backbone-refresh-the-same-route-path-for-twice
     * @see     https://viget.com/extend/finally-introducing-routerrouter-a-javascript-routing-library
     * @extends Backbone.Router
     */
    window.Router = Backbone.Router.extend({

        /**
         * _history
         * 
         * Array of paths made during the UX
         * 
         * @var    Array
         * @access protected
         */
        _history: [],

        /**
         * _previous
         * 
         * Records the last non-modal path
         * 
         * @var    String
         * @access protected
         */
        _previous: false,

        /**
         * _redirects
         * 
         * @var    Object
         * @access public
         */
        _redirects: {
            'app/tutorials/(.*)':               'app/help/$1',
            'app/backgrounds/colors':           'app/icons'
        },

        /**
         * routes
         * 
         * @var    Object
         * @access public
         */
        routes: {
            'app/admin/images':                     Stencil.getAction('Admin', ['images', 'results'], 'Admin: Images'),
            'app/admin/users':                      Stencil.getAction('Admin', ['users', 'results'], 'Admin: Users'),
            'app/admin/:section':                   Stencil.getAction('Admin', 'section', 'Admin'),
            'app/admin/users/search':               Stencil.getAction('Admin', ['users', 'search'], 'Admin: Users Search'),
            'app/admin/users/search/:query':        Stencil.getAction('Admin', ['users', 'results'], 'Admin: Users Results'),
            'app/admin/users/:key':                 Stencil.getAction('Admin', ['users', 'update'], 'Admin: Users Update'),
            'app/admin/categories/add':             Stencil.getAction('Categories', 'add', 'Add category modal'),
            'app/admin/coupons/add':                Stencil.getAction('Coupons', 'add', 'Add coupon modal'),
            'app/admin/promoSets/add':              Stencil.getAction('PromoSets', 'add', 'Add promo set modal'),
            'app/admin/cache/refresh':              Stencil.getAction('Admin', 'cacheRefresh', 'Refresh cached object'),
            'app':                                  Stencil.getAction('Backgrounds', 'index', 'Backgrounds: Features'),
            'app/backgrounds/search/:query':        Stencil.getAction('Backgrounds', 'search', 'Backgrounds: Search'),
            'app/backgrounds/uploads':              Stencil.getAction('Backgrounds', 'uploads', 'Backgrounds: Uploads'),
            'app/backgrounds/stars':                Stencil.getAction('Backgrounds', 'stars', 'Backgrounds: Stars'),
            'app/backgrounds/:category':            Stencil.getAction('Backgrounds', 'categories', 'Backgrounds: Categories'),
            'app/fonts/import':                     Stencil.getAction('App', 'googleFonts', 'Google fonts'),
            'app/icons':                            Stencil.getAction('Graphics', 'index', 'Graphics: Features'),
            'app/icons/search/:query':              Stencil.getAction('Graphics', 'search', 'Graphics: Search'),
            'app/icons/uploads':                    Stencil.getAction('Graphics', 'uploads', 'Graphics: Uploads'),
            'app/icons/stars':                      Stencil.getAction('Graphics', 'stars', 'Graphics: Stars'),
            'app/icons/:category':                  Stencil.getAction('Graphics', 'categories', 'Graphics: Categories'),
            'app/quotes':                           Stencil.getAction('Quotes', 'index', 'Quotes: Features'),
            'app/quotes/search/:query':             Stencil.getAction('Quotes', 'search', 'Quotes: Search'),
            'app/quotes/stars':                     Stencil.getAction('Quotes', 'stars', 'Quotes: Stars'),
            'app/quotes/:category':                 Stencil.getAction('Quotes', 'categories', 'Quotes: Categories'),
            'app/templates':                        Stencil.getAction('Templates', 'index', 'Templates: Features'),
            'app/templates/saved':                  Stencil.getAction('Templates', 'saved', 'Templates: Saved'),
            'app/templates/stars':                  Stencil.getAction('Templates', 'stars', 'Templates: Stars'),
            'app/templates/:category':              Stencil.getAction('Templates', 'categories', 'Templates: Categories'),
            'app/logos':                            Stencil.getAction('Watermarks', 'index', 'Watermarks'),
            'app/saved':                            Stencil.getAction('Images', 'index', 'Images: All'),
            'app/saved/stars':                      Stencil.getAction('Images', 'stars', 'Images: Stars'),
            // 'app/images/:key/download':             Stencil.getAction('Images', 'download', 'Image download modal'),
            'app/images/:key/sent':                 Stencil.getAction('Images', 'sent', 'Image sent modal'),
            'app/images/:key/normalize':            Stencil.getAction('Images', 'normalize', 'Image normalize modal'),
            'app/images/:key/share/:network':       Stencil.getAction('Images', 'share', 'Image share modal'),
            'app/images/:key/:connection/error':    Stencil.getAction('Images', 'error', 'Image share error modal'),
            'app/shares/:key/success':              Stencil.getAction('Shares', 'success', 'Image shared modal'),
            'app/delinquent':                       Stencil.getAction('Users', 'delinquent', 'Delinquent modal'),
            'app/login':                            Stencil.getAction('Users', 'login', 'Login modal'),
            'app/signup':                           Stencil.getAction('Users', 'signup', 'Signup modal'),
            'app/password':                         Stencil.getAction('Users', 'password', 'Password modal'),
            'app/promo':                            Stencil.getAction('Users', 'promo', 'Promo modal'),
            'app/promo/:partner':                   Stencil.getAction('Users', 'promo', 'Promo modal (partner)'),
            'app/countdown':                        Stencil.getAction('Accounts', 'countdown', 'Countdown modal'),
            'app/upgraded/:plan':                   Stencil.getAction('Accounts', 'upgraded', 'Upgraded modal'),
            'app/plans':                            Stencil.getAction('Accounts', 'plans', 'Plans modal'),
            'app/browser':                          Stencil.getAction('App', 'browser', 'Browser modal'),
            'app/legacy':                           Stencil.getAction('App', 'legacy', 'Legacy modal'),
            'app/orientation':                      Stencil.getAction('App', 'orientation', 'Orientation modal'),
            'app/alert/:code':                      Stencil.getAction('App', 'alert', 'Alert modal'),
            'app/error/:code/:reference':           Stencil.getAction('App', 'error', 'Error modal'),
            'app/cookies':                          Stencil.getAction('App', 'cookies', 'Cookies modal'),
            'app/help/:section':                    Stencil.getAction('App', 'tutorials', 'Help'),
            'app/upgrade/:plan/:reason':            Stencil.getAction('Accounts', 'upgrade', 'Upgrade modal'),
            'app/checkout/:plan':                   Stencil.getAction('Accounts', 'checkout', 'Checkout modal'),
            'app/checkout/:plan/coupon':            Stencil.getAction('Coupons', 'apply', 'Coupon apply modal'),
            'app/checkout/:plan/coupon/:code':      Stencil.getAction('Coupons', 'apply', 'Coupon apply modal'),
            'app/settings/plan':                    Stencil.getAction('Users', ['settings', 'plan'], 'Settings: Plan'),
            'app/settings/plan/switch/:plan':       Stencil.getAction('Accounts', ['plan', 'switch'], 'Settings: Plan Switch'),
            'app/settings/plan/switched/:plan':     Stencil.getAction('Accounts', ['plan', 'switched'], 'Settings: Plan Switched'),
            'app/settings/profile':                 Stencil.getAction('Users', ['settings', 'profile'], 'Settings: Profile'),
            'app/settings/social':                  Stencil.getAction('Users', ['settings', 'social'], 'Settings: Social'),
            'app/settings/password':                Stencil.getAction('Users', ['settings', 'password'], 'Settings: Password'),
            'app/settings/notifications':           Stencil.getAction('Users', ['settings', 'notifications'], 'Settings: Notifications'),
            'app/settings/payment':                 Stencil.getAction('Users', ['settings', 'payment'], 'Settings: Payment'),
            'app/settings/referral':                Stencil.getAction('Users', ['settings', 'referral'], 'Settings: Referral'),
            'app/settings/:network/connected':      Stencil.getAction('Accounts', 'connections', 'Settings: Connections'),
            'app/extras':                           Stencil.getAction('App', 'extras', 'Extras modal'),
            'app/extras/chrome/success':            Stencil.getAction('App', 'chromeSuccess', 'Chrome installed modal'),
            'app/onboard':                          Stencil.getAction('Users', 'onboard', 'Onboarding modal'),
            'app/welcome':                          Stencil.getAction('Accounts', 'welcomeTour', 'Welcome tour modal'),
            'app/welcome/:step':                    Stencil.getAction('Accounts', 'welcomeTour', 'Welcome tour modal'),
            '*wildcard':                            Stencil.getAction('App', 'wildcard')
        },

        /**
         * initialize
         * 
         * Tracks the fragment the client is currently using, and triggers an
         * event against that fragment.
         * 
         * @access public
         * @return void
         */
        initialize: function() {
            var _this = this;
            this.on(
                'route',
                function() {
                    var fragment = Backbone.history.fragment;
                    this.trigger('route:' + (fragment));
                    _this._history.push(fragment);
                }
            );
        },

        /**
         * execute
         * 
         * @note   Prevents navigation by returning false if the Error modal is
         *         showing.
         * @access public
         * @param  Function callback
         * @param  Array args
         * @param  String name
         * @return false|void
         */
        execute: function(callback, args, name) {
            if (Modals.get('Error') !== false) {
                return false;
            } else if (Modals.get('Alert') !== false) {
                var modal = Modals.get('Alert');
                if (modal.getSettings().closable === false) {
                    return false;
                }
            }
            var params = {},
                query = args.pop();
            if (query !== null) {
                params = this._getParams(query);
            }
            params.event = String(callback);
            args.push(params);
            callback.apply(this, args);
        },

        /**
         * _getParams
         * 
         * @see    http://stackoverflow.com/questions/8486099/how-do-i-parse-a-url-query-parameters-in-javascript
         * @access protected
         * @param  String query
         * @return Object
         */
        _getParams: function(query) {
            var result = {};
            query.split('&').forEach(
                function(part) {
                    if(!part) {
                        return;
                    }
                    var item = part.split('='),
                        key = item[0],
                        val = decodeURIComponent(item[1] || true),
                        from = key.indexOf('[');
                    if (from === -1) {
                        result[key] = val;
                    } else {
                        var to = key.indexOf(']'),
                            index = key.substring(from + 1, to);
                        key = key.substring(0,from);
                        if(!result[key]) {
                            result[key] = [];
                        }
                        if (!index) {
                            result[key].push(val);
                        } else {
                            result[key][index] = val;
                        }
                    }
                }
            );
            return result;
        },

        /**
         * current
         * 
         * @access protected
         * @return Object
         */
        current: function() {
            return this.matching(Backbone.history.fragment);
        },

        /**
         * getPrevious
         * 
         * Returns the last non-modal path
         * 
         * @access public
         * @return String
         */
        getPrevious: function() {
            return this._previous;
        },

        /**
         * getRedirects
         * 
         * @access public
         * @return Object
         */
        getRedirects: function() {
            return this._redirects;
        },

        /**
         * log
         * 
         * @access public
         * @return void
         */
        log: function() {
            var msg = '/' + (this.current().fragment);
            Stencil.log('route', 'Route', msg);
        },

        /**
         * matching
         * 
         * @see    http://stackoverflow.com/questions/7563949/backbone-js-get-current-route/16191880#16191880
         * @access protected
         * @return Object
         */
        matching: function(fragment) {
            var Router = this,
                routes = _.pairs(Router.routes),
                route = null,
                params = null,
                matched;
            matched = _.find(
                routes,
                function(handler) {
                    route = _.isRegExp(handler[0])
                        ? handler[0]
                        : Router._routeToRegExp(handler[0]);
                    return route.test(fragment);
                }
            );
            if (matched) {
                params = Router._extractParameters(route, fragment);
                route = matched[1];
            }
            return {
                route: route,
                fragment: fragment,
                params: params
            };
        },

        /**
         * recent
         * 
         * @access public
         * @access Number recent
         * @return String
         */
        recent: function(recent) {
            var entry = this._history[this._history.length - 1 - recent];
            if (entry === undefined) {
                entry = 'app';
            }
            return entry;
        },

        /**
         * setPrevious
         * 
         * Sets the previous non-modal path.
         * 
         * @access public
         * @param  String|false path
         * @return void
         */
        setPrevious: function(path) {
            this._previous = path;
        }
    });
}));
/*
Paths
/api/features?type=backgrounds|graphics|templates
/api/resources?type=backgrounds|graphics
/api/uploads?type=backgrounds|graphics|watermarks
/api/stars?type=backgrounds|graphics|templates|images
/api/images
/api/templates
*/

/*
    z-index:
        1001: div.modal.alert
        1001: div.modal.busy
        1001: div.modal.loading
        1000: Sticky Modal highlight $elements
          97: div.modal
          98: div.modal > div.overlay
          98: div.modal > div.outer
          99: div.modal > div.outer > div.inner
         100: div.modal > div.outer > div.inner > div.content
           2: div.modal > div.outer > div.inner > div.content a.close
        
        

*/


/**
 * Stencil
 * 
 * @note     Global shortform accessors are:
 *           - App
 *           - Frame
 *           - Canvases.Ghost
 *           - Canvases.Preview
 *           - Toolbars
 *           - Footer
 * @todo     Move script event listening to Scripts class
 * @events   script/loaded
 *           script/facebook/loaded
 *           script/twitter/loaded
 *           script/segment/loaded
 *           script/accountDock/loaded
 *           script/twitter/loaded
 *           resource/feature/complete
 *           resource/operation/complete
 *           resource/save/complete
 *           resource/star/complete
 * @abstract
 */
var Stencil = (function() {

    /**
     * _app
     * 
     * @access private
     * @var    AppView
     */
    var _app;

    /**
     * _addPostMessageListeners
     * 
     * Adds listeners to window to allow for Chrome extension integration.
     * 
     * @note   { check below is to ensure json is being sent. This is sometimes
     *         not the case when the user has extensions installed. They can
     *         call parent frames with string-data that will break the below
     *         parsing.
     * @todo   Add preloading for image upload, to ensure it shows up right away
     *         when the tab is shown?
     * @access private
     * @return void
     */
    var _addPostMessageListeners = function() {
        $(window).on('message', function(event) {
            var original = event.originalEvent;
            if (original.data[0] === '{') {
                var data = JSON.parse(original.data);
// StencilBooter.log(data);
                if (data.action === 'message.app.hide') {
                    App.hide();
                } else if (data.action === 'message.app.show') {
                    App.show();
                } else if (data.action === 'message.app.params.store') {
                    Stencil.set('messageParams', data.params);
                    if (data.params.image !== false) {
                        Stencil.importUrl(
                            data.params.image,
                            data.params.selection
                        );
                    } else {
                        if (data.params.selection !== false) {
                            _launch(function() {
                                msg = Stencil.getMessage('image.import.almost');
                                App.getBusy().show(msg);
                                var canvas = Canvases.Preview;
                                canvas.once({
                                    'render': function(event) {
                                        canvas.clear(false);
                                        canvas.getBusy().hide();
                                        App.getBusy().hide();
                                        var layer = canvas.addTextLayer({
                                                text: data.params.selection.trim(),
                                                width: 80
                                            }),
                                            drawing = layer.getDrawing();
                                        drawing.once({
                                            'draw': function(event) {
                                                drawing.animate();
                                            }
                                        });
                                        drawing.draw();
                                    }
                                });
                            });
                        } else {
                            _launch();
                        }
                    }
                }
            }
        });
    };

    /**
     * _adjustDefaultCanvases
     * 
     * Currently limited to changing the default font family for the app default
     * canvases, to the value stored in the AccountAccessor's settings.
     * 
     * @access private
     * @return void
     */
    var _adjustDefaultCanvases = function() {
        var canvases = Stencil.get('config').defaults.canvases,
            account = Stencil.get('account'),
            guest = canvases.guest,
            user = canvases.user,
            defaultFontFamily = account.setting('defaultFontFamily');
        guest.layers[2].fontFamily = defaultFontFamily;
        user.layers[2].fontFamily = defaultFontFamily;
    };

    /**
     * _askForNativeNotificationsPermission
     * 
     * @access private
     * @param  String relativeTime
     * @return void
     */
    var _askForNativeNotificationsPermission = function(relativeTime) {
        if (Stencil.account().createdBefore(relativeTime) === true) {
            if (Browser.chrome() === true || Browser.firefox() === true) {
                // if (Browser.extension() === true) {
                    if (Notification !== undefined && Notification !== null) {
                        if (Notification.permission !== 'granted') {
                            Notification.requestPermission(function(permission) {
                                if (permission === 'granted') {
                                    var notificationObject = Stencil.get('config').defaults.notifications.current;
                                    Stencil.cookies.set(
                                        'nativeNotificationLastShow',
                                        notificationObject.stamp
                                    );
                                }
                            });
                        }
                    }
                // }
            }
        }
    };

    /**
     * _checkForAdBlockers
     * 
     * @access private
     * @return void
     */
    var _checkForAdBlockers = function() {
        if (Cookies.get('adBlocker/notified') === undefined) {
            var image = new Image();
            image.onerror = function() {
                Stencil.alert('adBlocker.found');
                Stencil.cookies.set('adBlocker/notified', 1);
            };
            image.src = 'https://www.facebook.com/impression.php';
        }
    };

    /**
     * _checkForConflictingExtensions
     * 
     * @access private
     * @return Boolean
     */
    var _checkForConflictingExtensions = function() {
        if (_app.find('#ezLinkPreviewDIV').length > 0) {
            if (Cookies.get('conflictingExtension/ezLinkPreview') === undefined) {
                Stencil.alert('extension.conflicting.ezLinkPreview');
                Stencil.cookies.set('conflictingExtension/ezLinkPreview', 1);
                return true;
            }
        }
        if (_app.find('#ghostery-purple-box').length > 0) {
            if (Cookies.get('conflictingExtension/ghostery') === undefined) {
                Stencil.alert('extension.conflicting.ghostery');
                Stencil.cookies.set('conflictingExtension/ghostery', 1);
                return true;
            }
        }
        return false;
    };

    /**
     * _connect
     * 
     * @access private
     * @param  Function callback
     * @return void
     */
    var _connect = function(callback) {
        var email = 'hello@getstencil.com',
            fallback = 'Something went wrong. Please email ' + (email);
        Stencil.ajax({
            signature: {file: 'Stencil', line: 138},
            url: '/connect',
            type: 'GET',
            error: function(jqXHR, textStatus, errorThrown) {
                if (window.console && window.console.log) {
                    console.log(arguments);
                }
                alert('#100 - ' + (fallback));
            },
            success: function(response) {
                if (response.success === true) {
                    callback(response);
                } else {
                    if (window.console && window.console.log) {
                        console.log(arguments);
                    }
                    alert('#101 - ' + (fallback));
                }
            }
        });
    };

    /**
     * _dead
     * 
     * Tracks whether the app is already been killed to prevent multiple calls
     * to Stencil.kill from having any effect. This would happen if, for
     * example, requests were queued up. When the first one would timeout, any
     * subsequent ones would be aborted, which would then trigger a
     * Stencil.error, which would result in a Stencil.kill.
     * 
     * @access private
     * @var    Boolean (default: false)
     */
    var _dead = false;

    /**
     * _drawTemplates
     * 
     * @access private
     * @param  Array templates
     * @return void
     */
    var _drawTemplates = function (templates) {
        for (var index in templates) {
            $('#templates').append(templates[index]);
        }
    };

    /**
     * _templateStorageMethod
     * 
     * @access private
     * @var    String (default: 'dom')
     */
    // var _templateStorageMethod = 'memory';
    var _templateStorageMethod = 'dom';

    /**
     * _storeTemplates
     * 
     * @access private
     * @param  Array templates
     * @return void
     */
    var _storeTemplates = function (templates) {
        var hash = {},
            template,
            index,
            name,
            markup;
        for (index in templates) {
            template = templates[index];
            name = template.match(/name="([^"]+)"/).pop();
            markup = template;
            markup = markup.replace('</script>', '');
            markup = markup.replace(/\<script .*?>/, '');
            // markup = markup.replace(/\<\!--.*--\>/g, '');
            // markup = markup.trim();
            hash[name] = markup;
        }
        Stencil.set('templates', hash);
    };

    /**
     * _launch
     * 
     * @access private
     * @param  Function callback
     * @return void
     */
    var _launch = function (callback) {

        // Router logging + init
        _router.on({
            'route': _router.log.proxy(_router)
        });
        _connect(function(response) {
            var data = response.data;

            // Set the static server path
            window.STATIC = data.config.hosts.static;

            // Config
            Stencil.set('config', data.config);
            Stencil.set('features', data.features);

            // Templates
            if (_templateStorageMethod === 'memory') {
                _storeTemplates(data.config.markup.templates);
            } else {
                _drawTemplates(data.config.markup.templates);
            }

            // Defaults
            Frames.store(data.config.defaults.frames);

            // S3 upload tracking
            // Stencil.set('s3.uploads', []);

            // Account
            var model = Stencil.getModel('Account'),
                account = model.setAccessor(data.account);
            Stencil.set('account', account);

            // Adjust default canvases with account's default font
            _adjustDefaultCanvases();

            // Categories
            var collection = new CategoriesCollection();
            collection.map(data.config.categories);
            Stencil.set('categories', collection);

            /**
             * Wait for all the normal fonts to be have been loaded before
             * continuing.
             */
            var fontsCollection = Stencil.account().collection('fonts');
            fontsCollection.once({
                'load/all/normal': function(event) {
                    var latoFont = fontsCollection.findByFamilyName('Lato');
                    latoFont.loadFull(function() {

                        // User
                        var user = false;
                        if (data.user !== false) {
                            model = Stencil.getModel('User');
                            user = model.setAccessor(data.user);
                            user.on({
                                'change': Track.user
                            });
                            Stencil.account().on({
                                'change': Track.user
                            });
                        }
                        Stencil.set('user', user);

                        // Scripts
                        Stencil.on('script/accountDock/loaded', _setupAccountDock);
                        Stencil.on('script/facebook/loaded', _setupFacebook);

                        // Headway setup
                        if (Services.check('headway') === true) {
                            var id = data.config.headway.apps.paid.auth.id;
                            _setupHeadway(id);
                            Scripts.load('headway');
                        }
                        
                        Stencil.on('script/stripe/loaded', _setupStripe);
                        Stencil.on('script/tapfiliate/loaded', _setupTapfiliate);
                        Scripts.load('tapfiliate');

                        // Resource operations
                        _setupResourceOperationListeners();

                        // Segment booting
                        var segment = Scripts.get('segment');
                        segment = segment.replace(
                            'key',
                            data.config.segment.key
                        );
                        Scripts.set('segment', segment);
                        if (Track.enabled() === true) {
                            Scripts.load('segment');
                        }

                        // View
                        var $app = $('body.app');
                        _app = new AppPageView($app);
                        _app.setSelectedFrame();
                        Stencil.set('smartToggleWatermarks', true);
                        _app.getStage().getContent().drawPreviewCanvas();

                        // Initialize change history
                        ChangeHistory.setOperationType('initial');
                        ChangeHistory.track(true, false);

                        // Pre loading (must be after AppPageView init)
                        _preload = Stencil.get('config').defaults.preload;
                        Stencil.preload();

                        // Preloading
                        User.once({
                            'login': function(event, user) {
                                _queue.active = _queue.repeat;
                                Stencil.preload();
                            }
                        });
                        // if (user !== false) {
                        //     User.triggerHandler('login', [user]);
                        // }

                        // Start navigation
                        Backbone.history.start({
                            pushState: true
                        });

                        // Blocking
                        if (Modernizr.cookies === false) {
                            Stencil.navigate('/app/cookies?clean=1');
                        } else if (Browser.valid() === false) {
                            Stencil.navigate('/app/browser?clean=1');
                        } else if (Browser.ipad() === true) {
                            if (Browser.orientation() === 'portrait') {
                                Stencil.navigate('/app/orientation?clean=1');
                            }
                        } else if (_store.user !== false) {
                            _store.user.showLegacyWelcome();
                        }

                        // Done
                        callback && callback();

                        // Check for ad blockers
                        if (_checkForConflictingExtensions() === false) {
                            // _checkForAdBlockers();
                        }

                        // Notification requests
                        var nativeNotifications = Stencil.get('config').defaults.nativeNotifications;
                        if (nativeNotifications === true) {
                            var relativeTime = Stencil.get('config').defaults.nativeNotificationMinRelativeTime;
                            _askForNativeNotificationsPermission(relativeTime);
                        }

                        /**
                         * @todo Add blocking check in above that ensures a minium width
                         *       for non-tablet devices. Can compare $('body').width()
                         *       and window.screen.availWidth. The latter provides the
                         *       possible width the window could be based on their OS
                         *       settings. Show a simple modal (that can be dismissed)
                         *       which suggests they make the window as big as possible
                         *       for the best experience.
                         */

                        // Login welcome modal
                        // User.on('login', function(event) {

                        // });
                    });
                }
            });

            /**
             * Excluding the Stencil app font Lato, since I'll load that in
             * after all the normal ones have been.
             */
            fontsCollection.loadAllNormal(['Lato']);
        });
    };

    /**
     * _options
     * 
     * @access private
     * @var    Object (default: {})
     */
    var _options = {};

    /**
     * _preload
     * 
     * Stores configuration details on preloading tabs.
     * 
     * @access private
     * @var    Object
     */
    var _preload = {};

    /**
     * _queue
     * 
     * Keeps track of the sections that can be preloaded. Contains two copies so
     * that some sections (eg. ones that might have user / account-specific
     * content) can be preloaded again after login.
     * 
     * An example of areas that would not be repeated are featured backgrouds,
     * featured graphics and featured templates. This is because once they are
     * loaded, nothing changes between them having been loaded and the user logs
     * in (other than one possibly being marked as starred, which is done in the
     * AccountAccessor.reload method).
     * 
     * @access protected
     * @var    Array
     */
    var _queue = {
        active: [],
        repeat: []
    };

    /**
     * _router
     * 
     * @access private
     * @var    Router
     */
    var _router;

    /**
     * _setupAccountDock
     * 
     * @access private
     * @return void
     */
    var _setupAccountDock = function() {
        AccountDock.configure({
            key: Stencil.get('config').accountDock.key
        });
    };

    /**
     * _setupFacebook
     * 
     * @access private
     * @return void
     */
    var _setupFacebook = function() {
        FB.init({
            appId: Stencil.get('config').facebook.id,
            status: true,
            cookie: true,
            xfbml: true,
            version: 'v2.5'
        });
    };

    /**
     * _setupHeadway
     * 
     * @access private
     * @param  String id
     * @return void
     */
    var _setupHeadway = function(id) {
        window.HW_config = {
            selector: 'header div.headway',
            account: id
        };
    };

    /**
     * _setupMoment
     * 
     * @access private
     * @return void
     */
    var _setupMoment = function() {
        moment.locale('en', {
            calendar: {
                lastDay: '[Yday @] LT',
                sameDay: '[Today @] LT',
                nextDay: '[Tomorrow @] LT',
                // lastWeek: '[Last] ddd [@] LT',
                lastWeek: 'ddd [@] LT',
                nextWeek: 'ddd [@] LT',
                sameElse: 'L @ LT'
            }
        });
    };

    /**
     * _setupResourceOperationListeners
     * 
     * Listens for successful resource features, saves and stars in order to
     * keep track of how many are running at any point. Currently being used to
     * throttle resource-operations to prevent overloading the server, as well
     * as queueing up too many front-end ajax calls.
     * 
     * @access private
     * @return void
     */
    var _setupResourceOperationListeners = function() {
        Stencil.on({
            /**
             * @param String event
             * @param AssetAccessor asset
             */
            'resource/feature/complete': function(event, asset) {
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures');
                --parallelResourceFeatures;
                Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
            },
            /**
             * @param String event
             * @param String operation
             * @param AssetAccessor asset
             */
            'resource/operation/complete': function(event, operation, asset) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations');
                --parallelResourceOperations;
                Stencil.set('parallelResourceOperations', parallelResourceOperations);
            },
            /**
             * @param String event
             * @param AssetAccessor asset
             */
            'resource/save/complete': function(event, asset) {
                var parallelResourceSaves = Stencil.get('parallelResourceSaves');
                --parallelResourceSaves;
                Stencil.set('parallelResourceSaves', parallelResourceSaves);
            },
            /**
             * @param String event
             * @param AssetAccessor asset
             */
            'resource/star/complete': function(event, asset) {
                var parallelResourceStars = Stencil.get('parallelResourceStars');
                --parallelResourceStars;
                Stencil.set('parallelResourceStars', parallelResourceStars);
            }
        });
    };

    /**
     * _setupStripe
     * 
     * @access private
     * @return void
     */
    var _setupStripe = function() {
        Stripe.setPublishableKey(
            Stencil.get('config').stripe.publishableKey
        );
    };

    /**
     * _setupTapfiliate
     * 
     * @access private
     * @return void
     */
    var _setupTapfiliate = function() {
        var accountId = Stencil.get('config').tapfiliate.auth.accountId;
        tap('create', accountId);
        tap('detectClick');
    };

    /**
     * _store
     * 
     * @access private
     * @var    Object
     */
    var _store = {};

    // Public
    return {

        /**
         * account
         * 
         * @access public
         * @return AccountAccessor
         */
        account: function() {
            return Stencil.get('account');
        },

        /**
         * active
         * 
         * Returns whether or not any remote connections are active. This
         * includes ajax calls and S3 pushes.
         * 
         * @note   The way jQuery.active works is if the server responds (with
         *         anything), or the jQuery timeout value for ajax calls is
         *         reached, jQuery.active is decremented. But if no response
         *         comes back (eg. their is a browser-security issue, or
         *         something else unforseen), the error handler for the outbound
         *         ajax call will be triggered, but jQuery.active won't be
         *         decremented. So this means that sometimes, jQuery.active
         *         could be 1. Now, <Stencil.kill> sets jQuery.active to 0 since
         *         it's known that the app is no longer live. But the issue was
         *         that when <Stencil.kill> was called from within an ajax error
         *         handler, jQuery's internal logic would fire _after_ that,
         *         which would then further decrement the jQuery.active value.
         *         This means it's possible for jQuery.active to be less than 0
         *         (currently, I think only -1). So to accommodate for this, I
         *         no longer check jQuery.active against a non-zero value, but
         *         rather a _greater than_ zero value.
         * @access public
         * @return Boolean
         */
        // active: function() {
        //     return jQuery.active > 0
        //     // return jQuery.active > 0
        //         || Stencil.get('s3.uploads').length !== 0;
        // },

        /**
         * ajax
         * 
         * Proxy for ajax calls. Initially created to facilitate a Safari bug
         * whereby ajax calls were being killed when a location change happens
         * (which included downloading an image). To deal with that, I am
         * checking to see if a redirect is happening, and if it is, I delay the
         * ajax call until after (by listening for the redirect/complete event).
         * 
         * That being said, it is also nice to have all the logic in one place.
         * Should result in a cleaner development experience.
         * 
         * @todo!! Update default error handler to work independent of AppView
         *         having been intantiated. This will probably require a Logging
         *         helper class. The value of modifying things is to ensure that
         *         a logging method is always accessible regardless of whether
         *         the app view has been instantiated (eg. /import or /sign
         *         fails).
         * @access public
         * @param  Object obj
         * @return void
         */
        ajax: function(obj) {
            if (Stencil.get('redirecting') === true) {
                Stencil.once({
                    'redirect/complete': Stencil.ajax.proxy(Stencil, [obj])
                });
            } else {
                if (obj.sign === false) {
                    var currentUnixTimestamp = new Date().getTime() / 1000;
                    data = obj.data || {};
                    data.security = {
                        time: {
                            unix: {
                                full: currentUnixTimestamp,
                                simple: Math.floor(currentUnixTimestamp)
                            }
                        },
                        version: Stencil.get('version')
                    };
                    jQuery.ajax({
                        // cache: obj.cache || false,
                        cache: obj.cache === undefined ? true: obj.cache,
                        crossdomain: obj.crossdomain || false,
                        url: obj.url,
                        type: obj.type,
                        data: obj.data || {},
                        error: obj.error || function(jqXHR, textStatus, errorThrown) {

                            // Segment tracking
                            Track.event('Ajax Error (Stencil)', {
                                _code: obj.signature.line,
                                _reference: obj.signature.file,
                                _data: JSON.stringify(obj.data || {}),
                                _url: obj.url,
                                _textStatus: textStatus
                            });

                            // Console logging
                            App.log('jQuery AJAX error', true);
                            App.log(obj.signature, true);
                            App.log(arguments, true);

                            // Connection check
                            Stencil.alive(function() {
                                var code = obj.signature.line,
                                    reference = obj.signature.file;
                                Stencil.error(code, reference);
                            });
                        },
                        success: [function(response) {
                            if (Stencil.get('version') === undefined) {
                                if (typeof response === 'object') {
                                    var version = response.version;
                                    if (version !== undefined) {
                                        Stencil.set('version', version);
                                    }
                                }
                            }
                        }, obj.success],
                        dataType: obj.dataType || 'json',
                        timeout: obj.timeout || 25 * 1000
                        // timeout: obj.timeout || 10 * 1000
                    });
                } else {
                    Stencil.prepare.ajax.sign(function(csrf) {
                        obj.sign = false;
                        obj.data = obj.data && obj.data.constructor === Function.constructor
                            ? obj.data(csrf) : {
                                csrf: csrf,
                                data: obj.data || {}
                            };
                        Stencil.ajax(obj);
                    });
                }
            }
        },

        /**
         * alert
         * 
         * @access public
         * @param  String code
         * @return void
         */
        alert: function(code) {
            Stencil.navigate('/app/alert/' + (code) + '?clean=1');
        },

        /**
         * alive
         * 
         * Attempts to load a small image to determine if a connection to the
         * server can be made. If yes, the callback is run. Otherwise, an alert
         * is shown informing them that they need to reload the app. At the
         * moment, trying to load from imgur instead of static file on app
         * server, since if they can't reach imgur, it's almost certain their
         * connection is donw. But if they can't reach static file on app
         * server, it's possible that app server is down, instead of internet
         * connection.
         * 
         * Stencil.set call is made against alive-key to prevent Stencil.alert
         * from tracking the alert (via Segment).
         * 
         * @todo!  Tier this so connection tests are made to both a local static
         *         asset as well as one on a 3rd-party site (eg. imgur).
         * @note   Keep in mind some countries (eg. Turkey) can block certain
         *         domains (eg. imgur).
         * @access public
         * @param  Function callback
         * @return void
         */
        alive: function(callback) {
            // var src = 'https://i.imgur.com/GqNxmpB.png',
            var src = '/app/static/images/200.png',
                image = new Image();
            image.onload = callback;
            image.src = (src) + '?' + random();
            image.onerror = function() {
                Track.disable();
                Stencil.set('alive', false);
                Stencil.alert('connection');
                Stencil.kill();
            };
        },

        /**
         * cookies
         * 
         * @access public
         * @var    Object
         */
        cookies: {

            /**
             * remove
             * 
             * @access public
             * @param  Array key
             * @return void
             */
            remove: function(key) {
                Cookies.remove(key, {
                    path: '/',
                    domain: ''
                });
            },

            /**
             * set
             * 
             * @note   Not currently being used anywhere.
             * @access public
             * @param  Array key
             * @param  mixed value
             * @return void
             */
            set: function(key, value) {
                Cookies.set(key, value, {
                    domain: '',
                    expires: 365,
                    path: '/',
                    secure: true
                });
            }
        },

        /**
         * error
         * 
         * Redirects the user to an error view (via AppController). Multiple
         * error-redirects is prevented within Router.js by checking if an
         * ErrorModal is already open, or else if an AlertModal that is not
         * closable is open.
         * 
         * @access public
         * @param  String code
         * @param  String reference
         * @return void
         */
        error: function(code, reference) {
            var path = '/app/error/' + (code) + '/' + (reference) + '?clean=1';
            Stencil.navigate(path);
            Stencil.kill();
        },

        /**
         * extractError
         * 
         * Attempts to drill down into an ajax response to find a failed rule
         * error. This is used with Stencil.error for debugging purposes.
         * 
         * @access public
         * @param  Object response
         * @return Object
         */
        extractError: function(response) {
            if (response.failedRules) {
                if (response.failedRules[0]) {
                    if (response.failedRules[0].error) {
                        var error = response.failedRules[0].error;
                        return {
                            validator: response.failedRules[0].validator,
                            code: error.code || 'uk1',
                            reference: error.reference || 'crash1'
                        };
                    }
                }
            }
            return {
                validator: false,
                code: 'uk0',
                reference: 'crash0'
            };
        },

        /**
         * features
         * 
         * @access public
         * @var    Object
         */
        features: {

            /**
             * add
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            add: function(accessor) {
                var features = Stencil.get('features'),
                    key = accessor.get('key');
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                features.push(key);
            },

            /**
             * remove
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            remove: function(accessor) {
                var features = Stencil.get('features'),
                    key = accessor.get('key'),
                    index;
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = features.indexOf(key);
                if (index !== -1) {
                    features.splice(index, 1);
                }
            }
        },

        /**
         * kill
         * 
         * Runs a kind of clean up when the app is no longer alive. Examples of
         * this include an alert that forces a page reload or an error.
         * 
         * @note   I set active to 0 to ensure they don't get the unbeforeunlock
         *         alert
         *         [OLD]
         * @note   I believe the way jQuery.active works is as follows:
         *         If any response comes back (eg. a 503, 500, 404),
         *         jQuery.active will be decremented. It is possible that it's
         *         not decremented when no response comes back. Notably, this
         *         happens in VectorImageDrawing instances if there is a CORS
         *         issue. The error handler for the outbound jQuery check is
         *         fired, but since no actual response comes back, jQuery does
         *         not decrement it. At least, that's what I think. So it seems
         *         like I need to decrement the jQuery.active property in cases
         *         where there might not be a response, possibly do to a
         *         cross domain or permissions issue (like, an invalid CORS
         *         request).
         *         [OLD]
         * @access public
         * @return void
         */
        kill: function () {
            if (_dead === false) {
                _dead = true;
                $('*').unbind();
                $(window).unbind('resize');
                jQuery.timeoutPool.clearAll();
                jQuery.intervalPool.clearAll();
                jQuery.xhrPool.abortAll();
            }
        },

        /**
         * get
         * 
         * @access public
         * @param  String key
         * @return mixed
         */
        get: function (key) {
            return _store[key];
        },

        /**
         * getAccessor
         * 
         * @access public
         * @param  String key
         * @return Accessor|false
         */
        getAccessor: function (key) {
            return _store.accessors && _store.accessors[key] || false;
        },

        /**
         * getAction
         * 
         * Returns a function, which proxies through to a controller and action.
         * The advantage of this approach is that since <getAction> is used
         * within Router upon page-load, I can return this reference without
         * having to wait for the appropriate controllers to be loaded into
         * memory.
         * 
         * @access public
         * @param  String controller
         * @param  String|Array action
         * @param  String event
         * @return Function
         */
        getAction: function (controller, action, event) {
            if (jQuery.isArray(action) === false) {
                action = [action];
            }
            var closure = function() {
                var reference = Stencil.getController(controller);
                if (action.length === 1) {
                    reference[action[0]].apply(reference, arguments);
                } else if (action.length === 2) {
                    reference[action[0]][action[1]].apply(reference, arguments);
                } else {
                    throw new Error('Invalid action length');
                }
            };
            closure.toString = function() {
                return event;
            }
            return closure;
        },

        /**
         * getCategories
         * 
         * @access public
         * @param  String type
         * @return Array
         */
        getCategories: function (type) {
            var categories = Stencil.get('config').categories,
                matches = [];
            for (var index in categories) {
                if (categories[index].type === type) {
                    matches.push(categories[index]);
                }
            }
            return matches;
        },

        /**
         * getCollection
         * 
         * @access public
         * @param  String id
         * @return Collection
         */
        // getCollection: function (id) {
        //     return _store.collections && _store.collections[id] || false;
        // },

        /**
         * getController
         * 
         * @access public
         * @param  String name
         * @return Controller
         */
        getController: function (name) {
            if (_store.controllers && _store.controllers[name]) {
                return _store.controllers[name];
            }
            var reference = (name) + 'Controller';
            _store.controllers = _store.controllers || {};
            _store.controllers[name] = new window[reference]();
            return _store.controllers[name];
        },

        /**
         * getFilterResampleDelay
         * 
         * @access public
         * @return Number
         */
        getFilterResampleDelay: function (key) {
            return Stencil.get('config').defaults.filterResampleDelay.toInt();
        },

        /**
         * getMessage
         * 
         * @access public
         * @param  String key
         * @return String
         */
        getMessage: function (key) {
            return Stencil.get('config').defaults.messages[key];
        },

        /**
         * getModel
         * 
         * @access public
         * @param  String name
         * @return Model
         */
        getModel: function (name) {
            if (_store.models && _store.models[name]) {
                return _store.models[name];
            }
            var reference = (name) + 'Model';
            _store.models = _store.models || {};
            _store.models[name] = new window[reference]();
            return _store.models[name];
        },

        /**
         * getOptions
         * 
         * @access public
         * @return Object
         */
        getOptions: function () {
            return _options;
        },

        /**
         * getPhotoPartnerImageCount
         * 
         * @access public
         * @return Number
         */
        getPhotoPartnerImageCount: function () {
            var defaults = Stencil.get('config').defaults,
                gateway = defaults.backgroundSearchGateway,
                range = defaults.backgroundSearchRange;
            gateway = gateway.toLowerCase();
            if (range === 'single') {
                return Stencil.get('config')[gateway].total;
            }
            return Stencil.get('config').pixabay.total + Stencil.get('config').pexels.total;
        },

        /**
         * getQuotesCount
         * 
         * @access public
         * @return Number
         */
        getQuotesCount: function () {
            return Stencil.get('config').algolia.total;
        },

        /**
         * getResizeDelay
         * 
         * @access public
         * @param  String key
         * @return Number
         */
        getResizeDelay: function (key) {
            return Stencil.get('config').defaults.resizeDelays[key];
        },

        /**
         * getRouter
         * 
         * @access public
         * @return Router
         */
        getRouter: function () {
            return _router;
        },

        /**
         * getSaveDelay
         * 
         * @access public
         * @param  String key
         * @return Number
         */
        getSaveDelay: function (key) {
            return Stencil.get('config').defaults.saveDelays[key];
        },

        /**
         * init
         * 
         * @access public
         * @param  Object options
         * @return void
         */
        init: function (options) {

            // 
            _options = options;
            if (_options.source.external === true) {

                /**
                 * This click event is intended to capture the user clicking on
                 * body element outside of the app, which we interpret to mean
                 * "close the app". There's a bug with Chrome whereby
                 * right-clicking in the app (which shows the context menu),
                 * pressing escape, switching to a new tab, and then focusing on
                 * the original tab again triggers a <click> event against the
                 * body. I'm not sure why this happens, but to prevent the app
                 * from closing when the user focuses back on the tab, I check
                 * the coordinates of the mouse, and when it seems unlikely it
                 * was the user, I do not close it. The first screen shot below
                 * shows the event object when a user manually clicks on the
                 * body. The second shows the event when the body:click event is
                 * triggered by some unknown process:
                 * https://i.imgur.com/ulb9YzW.png
                 * https://i.imgur.com/1TFn0iV.png
                 * 
                 * @todo Look into why this is happening; there is likely a more
                 *       elegant way of handling this.
                 */
                $('body').click(function(event) {
                    var $target = $(event.target);
                    if ($target.tag() === 'body') {
                        if (event.clientX !== 0 && event.clientY !== 0) {
                            App.hide();
                        }
                    }
                });
            }

            // Create router
            _router = new Router();
            Stencil.set('alive', true);
            _setupMoment();

            // Posting
            if (_options.source.external === true) {
                _addPostMessageListeners();
                Stencil.postMessage('message.app.opened');
            } else {
                _launch(function() {
                    if (Account.showWelcomeTour() === true) {
                        Stencil.account().push('settings.hasSeenWelcomeTour', 1);
                        Stencil.navigate('/app/welcome');
                    }
                });
            }
        },

        /**
         * import
         * 
         * Notice that in the error handler, I've created a logProxy function.
         * This is because traditionally, I access the logging method through
         * App.log, but in this case, if import fails, the App view will not
         * have yet been instantiated. So in that case, I go straight to
         * Stencil.
         * 
         * Hmm, maybe I should always be going through Stencil? The problem at
         * the time of writing is that the Stencil.log method has too many
         * parameters. So maybe a Logging js helper file should be created, and
         * all log calls are simply proxies to that?
         * 
         * @todo!  See note above about creating a Logging.js file
         * @access public
         * @param  String url
         * @param  Function success
         * @param  Function fail
         * @return void
         */
        import: function (url, success, fail) {
            Stencil.ajax({
                signature: {file: 'Stencil', line: 1038},
                url: '/import',
                type: 'POST',
                data: {
                    url: url
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    var logProxy = function(message, alwaysLog) {
                        Stencil.log(
                            'view',
                            'Stencil',
                            message,
                            [],
                            alwaysLog
                        );
                    };
                    logProxy('jQuery AJAX error', true);
                    logProxy(arguments, true);
                    logProxy('s893', true);
                },
                success: function(response) {
                    if (response.success === true) {
                        success && success(response.data);
                    } else {
                        var error = Stencil.extractError(response);
                        fail && fail(error);
                    }
                }
            });
        },

        /**
         * importUrl
         * 
         * @note   This method works a bit differently because an AppView is not
         *         yet instantiated.
         * @access public
         * @param  String url
         * @param  false|string selection
         * @return void
         */
        importUrl: function (url, selection) {
            var msg = _options.messages['image.import.loading'];
            $('body div.busy div.copy').html(msg);
            Stencil.import(
                url,
                function(data) {
                    var model = Stencil.getModel('Upload'),
                        upload = model.setAccessor(data.object);
                    // upload.preload(function() {
                        _launch(function() {
                            msg = Stencil.getMessage('image.import.almost');
                            App.getBusy().show(msg);
                            Stencil.navigate('/app/backgrounds/uploads');
                            App.getBusy().show(msg);
                            var canvas = Canvases.Preview;
                            canvas.once({
                                'render': function(event) {
                                    canvas.clear(false);
                                    var layer = canvas.getBackgroundImageLayer(),
                                        drawing = layer.getDrawing();
                                    canvas.getBusy().show();
                                    drawing.once({
                                        'refresh': function() {
                                            canvas.getBusy().hide();
                                            App.getBusy().hide();
                                            if (selection !== false) {
                                                layer = canvas.addTextLayer({
                                                    text: selection.trim(),
                                                    width: 80
                                                });
                                                drawing = layer.getDrawing();
                                                drawing.once({
                                                    'draw': function(event) {
                                                        drawing.animate();
                                                    }
                                                });
                                                drawing.draw();
                                            }
                                        }
                                    });
                                    upload.select(
                                        'background',
                                        'load',
                                        false,
                                        {}
                                    );
                                }
                            });
                        });
                    // });
                },
                function(error) {
                    var key = 'import.failed';
                    if (error.validator !== false) {
                        if (error.validator[1] === 'validFilesize') {
                            key = 'import.failed.max.filesize';
                        }
                    }
                    _launch(function() {
                        Canvases.Preview.once({
                            'render': function(event) {
                                Stencil.alert(key);
                            }
                        });
                    });
                }
            );
        },

        /**
         * log
         * 
         * Notice that I check for alwaysLog first. This is partially to
         * accommodate the case where a call to /import fails. In that case,
         * it is likely that the config file will not be availble, and thus
         * the next check will fail. This should probably be more elegant.
         * 
         * @todo!  See note above
         * @see    http://www.w3schools.com/cssref/css_colornames.asp
         * @access public
         * @param  String type
         * @param  String label
         * @param  String message
         * @param  Array args
         * @param  Boolean alwaysLog
         * @return void
         */
        log: function(type, label, message, args, alwaysLog) {
            var account = Stencil.account();
            if (
                alwaysLog === true
                || Stencil.get('config').defaults.logging === true
                || (
                    account !== undefined
                    && account.userAccount() !== undefined
                    && account.userAccount().setting('logging').toInt() === 1
                )
            ) {
                var colors = {
                        'accessor': 'orange',
                        'account': 'green',
                        'collection': 'red',
                        'drawing': 'blueviolet',
                        'layer': 'cadetblue',
                        'model': 'brown',
                        'route': 'purple',
                        'stencil': 'chocolate',
                        // 'user': 'crimson',
                        'user': 'darkolivegreen',
                        'view': 'blue'
                    },
                    color = colors[type];
                label = moment().format('HH:mm:ss (0.SSSS)') + '  ' + (label);
                // label = moment().format('HH:mm:ss') + '  ' + (label);
                console && console.log(
                    '%c' + (label),
                    'color:' + (color) + ';',
                    message//,
                    // args
                );
            }
        },

        /**
         * navigate
         * 
         * Either proxies the routing method if the param <clean> is found, or
         * else uses Backbone's url-routing system for the app-state.
         * 
         * @note   replace value below is designed to prevent parent window from
         *         having navigational-records added to it when the app is
         *         laoded externally (eg. Chrome Extension).
         * @access public
         * @param  String path
         * @param  Boolean trigger
         * @param  Boolean refresh whether a navigate should be forced, even if
         *         the agent is already at that url (used in searching)
         * @return void
         */
        navigate: function(path, trigger, refresh) {
            if (path.indexOf('clean') !== -1) {
                Backbone.history.loadUrl(path);
            } else {
                if (trigger === undefined) {
                    trigger = true;
                }
                // var routed = _router.navigate(path, trigger);
                var routed = Backbone.history.navigate(path, {
                    trigger: trigger,
                    replace: _options.source.external === true
                });
                if (!routed && refresh) {
                    Backbone.history.loadUrl(path);
                }
            }
        },

        /**
         * on
         * 
         * @access public
         * @return void
         */
        on: function() {
            $(Stencil).on.apply($(Stencil), $(arguments).toArray());
        },

        /**
         * once
         * 
         * Proxy for jQuery one method.
         * 
         * @access public
         * @return void
         */
        once: function() {
            $(Stencil).one.apply($(this), $(arguments).toArray());
        },

        /**
         * preload
         * 
         * Facilitates preloading of paths within the app, such as:
         * - /app/backgrounds/uploads
         * - /app/backgrounds/stars
         * 
         * @access public
         * @return void
         */
        preload: function() {
            if (_preload.active === true) {
                var callback = function() {
                    if (_queue.active.length === 0) {
                        jQuery.intervalPool.clear(_preload.interval);
                    } else {
                        Stencil.queue.next();
                    }
                };
                _preload.interval = callback.interval(_preload.delay);
            }
        },

        /**
         * prepare
         * 
         * @access public
         * @var    Object
         */
        prepare: {

            /**
             * ajax
             * 
             * @access public
             * @var    Object
             */
            ajax: {

                /**
                 * data
                 * 
                 * Appends the options passed into <init> to all ajax requests.
                 * This includes GET calls, along with all the usual suspects
                 * (DELETE, POST, PATCH).
                 * 
                 * @access public
                 * @param  Object data
                 * @return Object
                 */
                data: function (data) {
                    // data.options = _options.source;
                    return data;
                },

                /**
                 * path
                 * 
                 * This wrapper was originally created to ensure the request is
                 * always being made to the app server. This was possibly not
                 * the case when the app itself was being served from a static
                 * server. Might still be useful to ensure this is always the
                 * case.
                 * 
                 * @note   Should not rely on config object, since it won't be
                 *         available for the first requests to /sign and
                 *         /connect.
                 * @access public
                 * @param  String path
                 * @return String
                 */
                path: function (path) {
                    return path;
                    // return 'https://local.getstencil.com' + (path);
                },

                /**
                 * sign
                 * 
                 * Requests a token to act as a signing process for subsequent requests.
                 * It should only ever fail if a connection to the server cannot be
                 * made. In that case, the error handler attempts to check whether the
                 * the connection is alive at all by requesting a static file via the
                 * alive method. If it can get that, then I error out via Stencil.error
                 * which implies that there might be a server side error not related to
                 * validating the /sign request (for example, mysql server could not be
                 * reached, or something application related).
                 * 
                 * @todo   Update so that this check call only occurs for non-pro users.
                 *         This is likely a safe-bet, since the user is paying, and will
                 *         speed up their experience. (Not positive of this yet, since
                 *         maybe Pro users it's more important since they're the most
                 *         valuable to a CSRF attack?)
                 * @note   Added timeout check here to communicate a bit better than a
                 *         general error. If timeout is reached here, it's likely that
                 *         the server is overloaded with traffic.
                 * @update At the moment, I'm not using the /sign call simply
                 *         because it's slow. I'll prob add it back at some
                 *         point. But because of this change, I had add a call
                 *         Stencil.alive in all ajax calls, Stencil-wide, to
                 *         determine whether an error-callback was reached
                 *         because their internet connection died. I did not
                 *         have to do this before since all calls were routed
                 *         through /sign, and an internet connection would have
                 *         been found there before the actual call was even
                 *         made.
                 * @access public
                 * @param  Function callback
                 * @return void
                 */
                sign: function(callback) {
                    if (_options.security.csrf === true) {
                        Stencil.ajax({
                            signature: {file: 'Stencil', line: 1359},
                            url: '/sign',
                            sign: false,
                            type: 'POST',
                            success: function(response) {
                                if (response.success === true) {
                                    callback(response.data.csrf);
                                } else {
                                    alert('Error #s1188');
                                }
                            }
                        });
                    } else {
                        // callback('null');
                        var csrf = random(16);
                        callback(csrf);
                    }
                }
            }
        },

        /**
         * queue
         * 
         * Manages background loading of sections
         * 
         * @access public
         * @return Object
         */
        queue: {

            /**
             * add
             * 
             * @access public
             * @param  Object signature
             * @return void
             */
            add: function(signature) {
                _queue.active.push(signature);
                if (signature.repeat && signature.repeat === true) {
                    _queue.repeat.push(signature);
                }
            },

            /**
             * get
             * 
             * @access public
             * @param  String type
             * @return Array
             */
            // get: function(type) {
            //     return _queue[type];
            // },

            /**
             * next
             * 
             * Loads the next resource within the active queue.
             * 
             * @access public
             * @return void
             */
            next: function() {
                if (_queue.active.length > 0) {
                    var signature = _queue.active[0],
                        area = App.getEditor().getArea(signature.area),
                        child = area.getChild(signature.children[0]);
                    if (signature.children.length > 1) {
                        for (var x = 1, l = signature.children.length; x < l; ++x) {
                            child = child.getChild(signature.children[x]);
                        }
                    }
                    child.load();
                }
            },

            /**
             * pause
             * 
             * @access public
             * @return void
             */
            pause: function() {
                jQuery.intervalPool.clear(_preload.interval);
            },

            /**
             * remove
             * 
             * @access public
             * @param  Object obj
             * @return void
             */
            remove: function(obj) {
                $(_queue.active).each(
                    function(index, item) {
                        if (item.area === obj.area) {
                            if (String(item.children) === String(obj.children)) {
                                _queue.active.splice(index, 1);
                            }
                        }
                    }
                );
            }
        },

        /**
         * render
         * 
         * @access public
         * @param  String view
         * @param  Object|undefined data
         * @return jQuery
         */
        render: function(view, data) {
            var markup;
            if (_templateStorageMethod === 'memory') {
                var templates = Stencil.get('templates');
                markup = templates[view];
            } else {
                markup = $('script[name="' + (view) + '"]').html();
            }
            var compiler = _.template(markup),
                rendered = compiler(data || {});
            return $(jQuery.parseHTML(rendered.trim()));
        },

        /**
         * postMessage
         * 
         * @access protected
         * @param  String action
         * @return void
         */
        postMessage: function(action) {
            window.parent.postMessage(
                JSON.stringify({
                    action: action
                }),
                '*'
            );
        },

        /**
         * report
         * 
         * @access protected
         * @param  mixed msg
         * @return void
         */
        report: function(msg) {
            Stencil.ajax({
                signature: {file: 'Stencil', line: 1758},
                url: '/admin/report',
                type: 'POST',
                data: {
                    msg: msg
                }
            });
        },

        /**
         * scrollbars
         * 
         * @access public
         * @return Boolean
         */
        scrollbars: function () {
            return Modernizr.cssscrollbar === false;
        },

        /**
         * set
         * 
         * Helper for application-wide hash map.
         * 
         * @access public
         * @param  String key
         * @param  mixed value
         * @return void
         */
        set: function (key, value) {
            _store[key] = value;
        },

        /**
         * server
         * 
         * This wrapper was originally created to ensure the request is always
         * being made to the app server. This was possibly not the case when the
         * app itself was being served from a static server. Might still be
         * useful to ensure this is alwas the case.
         * 
         * @note   Should not rely on config object, since it won't be available
         *         for the first requests to /sign and /connect.
         * @access public
         * @param  String path
         * @return void
         */
        server: function (path) {
            return path;

            // return 'https://local.getstencil.com' + (path);
        },

        /**
         * setAccessor
         * 
         * @access public
         * @param  String key
         * @param  String name
         * @param  Object data
         * @return Accessor
         */
        setAccessor: function (key, name, data) {
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                var reference = (name) + 'Accessor';
                _store.accessors = _store.accessors || {};
                _store.accessors[key] = new window[reference](data);
                accessor = _store.accessors[key];
            } else {
                accessor.merge(data);
            }
            return accessor;
        },

        /**
         * setCollection
         * 
         * @access public
         * @param  String id
         * @param  String name
         * @return Collection
         */
        // setCollection: function (id, name) {
        //     var reference = (name) + 'Collection';
        //     _store.collections = _store.collections || {};
        //     _store.collections[id] = new window[reference]();
        //     return _store.collections[id];
        // },

        /**
         * stars
         * 
         * @access public
         * @var    Object
         */
        stars: {

            /**
             * add
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            add: function(accessor) {
                var stars = Stencil.account().get('stars'),
                    key = accessor.get('key');
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                stars.push(key);
            },

            /**
             * remove
             * 
             * @access public
             * @param  Accessor accessor
             * @return void
             */
            remove: function(accessor) {
                var stars = Stencil.account().get('stars'),
                    key = accessor.get('key'),
                    index;
                if (String(accessor) === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = stars.indexOf(key);
                if (index !== -1) {
                    stars.splice(index, 1);
                }
            }
        },

        /**
         * triggerHandler
         * 
         * @access public
         * @return void
         */
        triggerHandler: function() {
            var msg = arguments[0];
            Stencil.log('stencil', 'Stencil Event', msg);
            $(Stencil).triggerHandler.apply($(Stencil), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * @access public
         * @return void
         */
        unbind: function() {
            $(Stencil).unbind.apply($(Stencil), $(arguments).toArray());
        }
    };
})();
